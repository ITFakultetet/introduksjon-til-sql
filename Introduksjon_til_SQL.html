<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=windows-1252"/>
	<title>Introduksjon til SQL</title>
	<meta name="generator" content="LibreOffice 6.3.3.2 (Windows)"/>
	<meta name="author" content="Terje Berg-Hansen"/>
	<meta name="created" content="2017-02-14T19:47:17.217240198"/>
	<meta name="changed" content="2020-06-19T10:39:15.179727127"/>
	<meta name="classification" content="Databaser"/>
	<meta name="keywords" content="Databaser, SQL"/>
	<style type="text/css">
		@page:right { size: 19.05cm 23.5cm; margin: 2cm }
		@page:left { size: 19.05cm 23.5cm; margin: 2cm }
		@page:first { }
		p { margin-bottom: 0.25cm; direction: inherit; line-height: 108%; background: transparent; page-break-before: auto }
		p.western { font-size: 10pt }
		p.cjk { font-size: 10pt }
		h2 { margin-top: 0.21cm; margin-bottom: 0.21cm; border: none; padding: 0cm; direction: inherit; background: transparent; background: transparent; page-break-before: auto; page-break-after: avoid }
		h2.western { font-family: "Liberation Serif", serif; font-size: 15pt; font-weight: normal }
		h2.cjk { font-family: "Noto Sans CJK SC Regular"; font-size: 18pt; font-weight: normal }
		h2.ctl { font-family: "FreeSans"; font-size: 18pt; font-weight: normal }
		h2:first-letter { float: left; font-size: 0% }
		pre { margin-top: 0.1cm; margin-bottom: 0.2cm; border-top: none; border-bottom: none; border-left: 7.00pt solid #adc5e7; border-right: none; padding-top: 0cm; padding-bottom: 0cm; padding-left: 0.3cm; padding-right: 0cm; direction: inherit; line-height: 108%; background: #efefef; page-break-before: auto }
		pre.western { font-family: "Liberation Mono", monospace; font-size: 9pt }
		pre.cjk { font-family: "Courier New", monospace; font-size: 10pt }
		pre.ctl { font-family: "Liberation Mono", monospace; font-size: 10pt }
		h3 { margin-top: 0.25cm; margin-bottom: 0.21cm; border-top: none; border-bottom: 1px solid #999999; border-left: none; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0cm; padding-right: 0cm; direction: inherit; background: transparent; page-break-before: auto; page-break-after: avoid }
		h3.western { font-family: "Liberation Serif", serif; font-size: 13pt; font-weight: normal }
		h3.cjk { font-family: "Noto Sans CJK SC Regular"; font-size: 14pt; font-weight: bold }
		h3.ctl { font-family: "FreeSans"; font-size: 14pt; font-weight: demi-bold }
		h4 { margin-top: 0.21cm; margin-bottom: 0.21cm; direction: inherit; background: transparent; page-break-after: avoid }
		h4.western { font-family: "Liberation Serif", serif; font-size: 10pt; font-weight: bold }
		h4.cjk { font-family: "Noto Sans CJK SC Regular"; font-size: 12pt; font-weight: bold }
		h4.ctl { font-family: "FreeSans"; font-size: 12pt; font-weight: demi-bold }
		td p { direction: inherit; background: transparent }
		td p.western { font-size: 9pt }
		td p.cjk { font-size: 10pt }
		th p { direction: inherit; text-align: center; background: transparent }
		th p.western { font-size: 9pt; font-weight: bold }
		th p.cjk { font-size: 10pt; font-weight: bold }
		th p.ctl { font-weight: bold }
		h1 { margin-top: 0.42cm; margin-bottom: 1.3cm; border-top: none; border-bottom: 3.00pt solid #999999; border-left: none; border-right: none; padding-top: 0cm; padding-bottom: 0.3cm; padding-left: 0cm; padding-right: 0cm; direction: inherit; background: #efefef; page-break-before: auto; page-break-after: avoid }
		h1.western { font-family: "Liberation Sans", sans-serif; font-size: 30pt; font-weight: bold }
		h1.cjk { font-family: "Noto Sans CJK SC Regular"; font-size: 18pt; font-weight: bold }
		h1.ctl { font-family: "FreeSans"; font-size: 18pt; font-weight: demi-bold }
		p.merk { border: 1px solid #666666; padding: 0.1cm; background: #cccc99 }
		p.ressurs { border: 1px solid #000000; padding: 0.2cm 0.1cm; background: #ccffcc }
		a:link { color: #000080; so-language: zxx; text-decoration: underline }
		strong { font-weight: bold }
		em { font-style: italic }
		a:visited { color: #800000; so-language: zxx; text-decoration: underline }
		code.western { font-family: "Liberation Mono", monospace }
		code.cjk { font-family: "Nimbus Mono L", monospace }
		code.ctl { font-family: "Liberation Mono", monospace }
		tt.western { font-family: "Liberation Mono", monospace }
		tt.cjk { font-family: "Nimbus Mono L", monospace }
		tt.ctl { font-family: "Liberation Mono", monospace }
	</style>
</head>
<body lang="nb-NO" link="#000080" vlink="#800000" dir="ltr">
<ol><li><p align="left" style="margin-top: 0.11cm; margin-bottom: 0.21cm; line-height: 100%; page-break-before: always; page-break-after: avoid">
	<img src="Introduksjon_til_SQL_html_7a53fd680db981a0.png" name="Bilde2" align="left" width="899" height="1110" border="0"/>
</p>
</ol>
<p class="western" align="left" style="page-break-before: always"><br/>
<br/>

</p>
<p align="center" style="margin-top: 0.42cm; margin-bottom: 0.21cm; line-height: 100%; page-break-before: auto; page-break-after: avoid">
<font face="Liberation Sans, sans-serif"><font size="7" style="font-size: 40pt"><b>Introduksjon
til SQL </b></font></font>
</p>
<p align="center" style="margin-top: 0.11cm; margin-bottom: 0.21cm; line-height: 100%; page-break-before: auto; page-break-after: avoid">
<font face="Liberation Sans, sans-serif"><font size="5" style="font-size: 18pt">for
relasjonelle og distribuerte databaser</font></font></p>
<p class="western" align="center"><br/>
<br/>

</p>
<p class="western" align="center"><br/>
<br/>

</p>
<p align="center" style="margin-top: 0.11cm; margin-bottom: 0.21cm; line-height: 100%; page-break-before: auto; page-break-after: avoid">
<font face="Liberation Sans, sans-serif"><font size="5" style="font-size: 18pt">Terje
Berg-Hansen</font></font></p>
<p align="center" style="margin-top: 0.11cm; margin-bottom: 0.21cm; line-height: 100%; page-break-before: auto; page-break-after: avoid">
<font face="Liberation Sans, sans-serif"><font size="5" style="font-size: 18pt">Ravi
Alexander Brunsvik</font></font></p>
<p align="center" style="margin-top: 0.11cm; margin-bottom: 0.21cm; line-height: 100%; page-break-before: auto; page-break-after: avoid">
<font face="Liberation Sans, sans-serif"><font size="4" style="font-size: 14pt">ITFakultetet.no</font></font></p>
<p align="left" style="margin-top: 0.11cm; margin-bottom: 0.21cm; line-height: 100%; page-break-before: always; page-break-after: avoid">
<font face="Liberation Sans, sans-serif"><font size="5" style="font-size: 18pt">Introduksjon
til SQL</font></font></p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><a name="__RefHeading___Toc15174_820443553"></a>Av
Terje Berg-Hansen og Ravi Alexander Brunsvik</p>
<p class="western"><a name="__RefHeading___Toc15176_820443553"></a>Copyright
<font face="Liberation Serif, serif">&copy;</font><font face="Liberation Serif, serif">
20</font><font face="Liberation Serif, serif">20</font><font face="Liberation Serif, serif">
ITFakultetet.no &ndash; Alle rettigheter reservert</font></p>
<p class="western"><a name="__RefHeading___Toc15178_820443553"></a>Publisert
av ITFakultetet, K&aring;sabakken 28, 3804 B&oslash; i Telemark,
Norge</p>
<p class="western"><a name="__RefHeading___Toc15180_820443553"></a><font size="2" style="font-size: 10pt">F</font><font size="2" style="font-size: 10pt">ebruar</font>
2020 &ndash; F&oslash;rste utgave</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><font face="Liberation Serif, serif">ISBN-13:
</font>978-1542801478 
</p>
<p class="western">ISBN-10: 1542801478</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><a name="__RefHeading___Toc15182_820443553"></a>Boken
kan leses som supplement til bl.a. disse kursene hos ITFakultetet.no:</p>
<ul>
	<li><p class="western"><a name="__RefHeading___Toc15184_820443553"></a>
	SQL Grunnkurs</p>
	<li><p class="western">SQL for Viderekomne (p&aring;byggingskurs)</p>
	<li><p class="western">PostgreSQL for Utviklere 
	</p>
	<li><p class="western"><a name="__RefHeading___Toc15186_820443553"></a>
	Hive og HiveQL Grunnkurs 
	</p>
	<li><p class="western"><a name="__RefHeading___Toc15188_820443553"></a>
	HBase Grunnkurs</p>
	<p class="western"></p>
</ul>
<p class="western">Sjekk gjerne <a href="http://www.itfakultetet.no/">www.itfakultetet.no</a>
for kursbeskrivelser og aktuelle kursdatoer.</p>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc14191_140935937"></a>
Forord</h1>
<p class="western"><a name="__RefHeading___Toc14193_140935937"></a>Velkommen
som leser av denne introduksjonsboken om sp&oslash;rrespr&aring;ket
SQL. Boken er skrevet p&aring; bakgrunn av at vi gjennom flere &aring;r
har holdt et 3-dagers SQL Grunnkurs med et 2-dagers p&aring;bygningskurs
for en rekke norske bedrifter og organisasjoner, og erfaring fra
disse kursene har dannet grunnlaget for b&aring;de struktur, innhold,
eksempler og ikke minst oppgavene til hvert kapittel. Boken kan
dermed ogs&aring; godt leses som et supplement til disse kursene &ndash;
for de som er i ferd med &aring; ta dem, vurderer om de skal ta dem,
eller har tatt dem tidligere og gjerne vil gjenoppfriske kunnskapene.
Boken dekker boken ogs&aring; distribuerte databaser, noe det ikke er
tid til p&aring; de allerede tettpakkede SQL-kursene.</p>
<p class="western"><a name="__RefHeading___Toc14195_140935937"></a>Boken
er skrevet for den komplette nybegynner, men b&oslash;r ogs&aring;
fungere bra for de som har jobbet en del med SQL fra f&oslash;r,
kanskje uten noen formell oppl&aelig;ring i spr&aring;ket, men som
har &laquo;Googlet&raquo; l&oslash;sninger, klippet og limt litt, og
gjerne vil ha litt st&oslash;rre forst&aring;else for hva som
egentlig foreg&aring;r n&aring;r SQL-setningene gir forventede eller
overraskende resultater &ndash; eller ikke vil kj&oslash;res i det
hele tatt.</p>
<p class="western"><a name="__RefHeading___Toc14197_140935937"></a>Alle
tilbakemeldinger mottas med takk, spesielt slike som kan forbedre
boken og gj&oslash;re den mest mulig tilgjengelig og nyttig for
leseren.  
</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><a name="__RefHeading___Toc14199_140935937"></a>Oslo,
 2020</p>
<p class="western"><a name="__RefHeading___Toc14201_140935937"></a>Terje
Berg-Hansen			Ravi Alexander Brunsvik</p>
<p class="western">Kursleder				Kursleder
<br/>
ITFakultetet.no				ITFakultetet.no</p>
<p class="western"><a name="__RefHeading___Toc14205_140935937"></a>Epost:
<a href="mailto:terje@itfakultetet.no">terje@itfakultetet.no</a>		Epost:
<a href="mailto:ravi@itfakultetet.no">ravi@itfakultetet.no</a></p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western" style="page-break-before: always"><br/>
<br/>

</p>
<div id="Innholdsliste1" dir="ltr">
	<div id="Table of Contents1_Head" dir="ltr"><p style="margin-top: 0.42cm; margin-bottom: 0.21cm; line-height: 100%; page-break-before: auto; page-break-after: avoid">
		<font face="Liberation Sans, sans-serif"><font size="4" style="font-size: 16pt"><b>INNHOLD</b></font></font></p>
	</div>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc14191_140935937">Forord	5</a></b></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc15235_820443553">Innledning	14</a></b></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc6135_317907475">Del 1 Relasjonelle
	Databaser	15</a></b></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc18222_1557834486">Kapittel 1
	Introduksjon til relasjonelle databaser og SQL	16</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc18224_1557834486">&#61609; Hva er en
	database?	16</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13923_140935937">&#61609; Hva er en
	relasjonell database?	16</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16104_604779659">&#61609; To ulike typer
	relasjonelle databaser: OLTP og OLAP	17</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16106_604779659">OLTP-databaser	17</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16108_604779659">OLAP-databaser	17</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc6461_841703319">&#61609;
	Relasjonsmodellen	17</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13925_140935937">&#61609; Andre modeller
	for organisering av data	18</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15760_820443553">&#61609; Hva er SQL?	18</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc10408_1613255157">DDL (Data Definition
	Language)	18</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc10410_1613255157">DML (Data Manipulation
	Language)	19</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc10412_1613255157">DCL (Data Control
	Language)	19</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc10414_1613255157">TCL (Transaction
	Control Language)	19</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12577_268258650">&#61609; SQL-standarder
	og dialekter	19</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12579_268258650">&#61609; &laquo;De fire
	store&raquo;	20</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16751_3466130985">Kort om MySQL og
	MariaDB	20</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16753_3466130985">Kort om Oracle	21</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16755_3466130985">Kort om Microsoft SQL
	Server	21</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16877_1783146702">Kort om PostgreSQL	22</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc20016_3710899157">Hvilken RDBMS b&oslash;r
	jeg velge til eksemplene og oppgavene i denne boken?	22</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc6463_841703319">&#61609;
	Normalisering	22</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc6465_841703319">F&oslash;rste normalform
	(1NF)	23</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc6467_841703319">Andre normalform
	(2NF)	24</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc6469_841703319">Tredje normalform
	(3NF)	24</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc6471_841703319">Boyce-Codd normalform
	(BCNF)	24</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16110_604779659">Normalformene forklart
	med &eacute;n setning	24</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15453_3971551474">Normalisering forklart
	med et eksempel	25</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc6473_841703319">&#61609;
	Denormalisering	26</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc6475_841703319">&#61609; ACID	26</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc19551_1580825334">Kapittel 2 DDL
	(Data Definition Language) CREATE, ALTER, DROP, TRUNCATE, COMMENT og
	RENAME	28</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc20018_3710899157">Datamodellering	28</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc24594_3325804077">Forholdet mellom en
	enhet og dens egenskaper	28</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc24596_3325804077">1 til 1	28</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc24598_3325804077">1 til mange	29</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc24600_3325804077">Mange til mange	30</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc24602_3325804077">Eksempel p&aring;
	modellering av en enkel database	32</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc20020_3710899157">EER	33</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc20022_3710899157">&#61609; Opprette og
	endre databaser	33</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc295_487959650">MySQL / MariaDB	33</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc297_487959650">PostgreSQL	34</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13963_140935937">&#61609; Opprette
	Tabeller	36</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc301_487959650">MySQL / MariaDB	37</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc303_487959650">PostgreSQL	37</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23560_2548419322">Oracle og MS SQL
	Server	38</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc305_487959650">&#61609; Selv-&oslash;kende
	prim&aelig;rn&oslash;kler	38</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13965_140935937">MySQL / MariaDB	38</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23946_604322462">MS SQL Server.	39</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13967_140935937">PostgreSQL og Oracle	39</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13969_140935937">Oracle f&oslash;r
	versjon 12c	41</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23948_604322462">&#61609;
	Default-verdier	41</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23950_604322462">&#61609; Tegnsett,
	spr&aring;k og lagringsformat	42</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc26779_3154182490">MySQL / MariaDB	42</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc26781_3154182490">PostgreSQL	42</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc26783_3154182490"> MS SQL Server	42</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc26785_3154182490">Oracle	43</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc307_487959650">&#61609; Endre
	eksisterende tabeller	43</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc309_487959650">&#61609; Legge til en
	kolonne	43</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc311_487959650">MySQL / MariaDB	43</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc313_487959650">PostgreSQL	44</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc26109_1526864018">MS SQL Server	44</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc315_487959650">&#61609; Endre en
	kolonne	44</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc317_487959650">MySQL / MariaDB	44</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc319_487959650">Endre navn p&aring; en
	kolonne	46</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc321_487959650">PostgreSQL	46</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc323_487959650">Endre navn p&aring; en
	kolonne	47</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc325_487959650">Endre begrensninger ved
	en kolonne	47</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc327_487959650">&#61609; Slette en
	kolonne	48</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc329_487959650">&#61609; Slette hele
	tabeller	48</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc331_487959650">&#61609; Opprette og
	fjerne begrensninger p&aring; tabell-kolonner	48</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc333_487959650">&#61609; Legge til
	begrensninger n&aring;r en tabell lages	48</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc335_487959650">Oracle / MySQL/ MariaDB /
	Microsoft SQL Server / PostgreSQL :	48</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc337_487959650">&#61609; Legge til
	begrensninger etter at en tabell er laget	49</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc339_487959650">PostgreSQL / MySQL /
	MariaDB / Oracle / MS SQL Server	49</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc341_487959650">MS SQL Server / Oracle /
	MariaDB / PostgreSQL	50</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc343_487959650">SQL Server / Oracle /
	MariaDB / PostgreSQL	50</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc345_487959650">&#61609; Fjerne
	begrensninger	50</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc347_487959650">SQL Server / Oracle /
	PostgreSQL:	50</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc349_487959650">MySQL / MariaDB	51</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc351_487959650">Fjerne prim&aelig;r- og
	fremmedn&oslash;kler	51</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc10035_122421868">&#61609; Datasettet
	HR	53</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc18228_1557834486">Kapittel 3 DML
	(Data Manipulation Language) SELECT, INSERT, UPDATE og DELETE	54</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc18230_1557834486">&#61609; Hente data
	med SELECT	54</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15455_3971551474">&#61609; Hente en
	enkelt kolonne fra en tabell	55</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19082_961426616">&#61609; Hente flere
	kolonner / felt fra en tabell	55</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13937_140935937">&#61609; Hente alle
	kolonner fra en tabell	56</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13939_140935937">&#61609; Hente alle
	unike rader fra en kolonne i en tabell	57</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13941_140935937">&#61609; Begrense
	antall rader i resultatet	57</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16206_413252541">Begrense antall rader
	med Microsoft SQL Server	58</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16208_413252541">Begrense antall rader
	med Oracle	58</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16210_413252541">Begrense antall rader
	med MySQL/MariaDB og PostgreSQL	58</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc191_487959650">&#61609; Sortere data med
	ORDER BY	59</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15763_604779659">ORDER BY med
	begrensning av resultatet i Oracle	60</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4484_762629072">&#61609; Sortering etter
	flere kolonner	60</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4486_762629072">&#61609; Angi
	sorterings-retning	61</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4488_762629072">Sorteringsrekkef&oslash;lge	62</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc9301_974749821">&#61609; Sortering etter
	spr&aring;k	62</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4490_762629072">Sortering etter spr&aring;k
	med MySQL / MariaDB	62</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4492_762629072">Endre spr&aring;k per
	s&oslash;k	63</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4494_762629072">Sortering etter spr&aring;k
	med PostgreSQL	65</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc14210_2514959757">Sortering etter spr&aring;k
	med Microsoft SQL Server	66</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc14212_2514959757">Sortering etter spr&aring;k
	med Oracle	69</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15457_3971551474">&#61609; Filtrering av
	data med </a><a href="#__RefHeading___Toc15457_3971551474"><span style="font-style: normal">WHERE</span></a><a href="#__RefHeading___Toc15457_3971551474">	70</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4499_762629072">Flere eksempler p&aring;
	filtrering	71</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15459_3971551474">Filtrere etter en gitt
	verdi	71</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15461_3971551474">Filtrere etter
	kolonner som ikke har en gitt verdi	72</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15463_3971551474">Filtrere etter en
	rekke gitte verdier	72</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15465_3971551474">Filtrere etter rader
	hvor det ikker er satt noen verdi for en kolonne	72</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc9303_974749821">&#61609; Kombinerte
	betingelser med AND, OR og IN	73</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4508_762629072">Bruk av AND	73</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4510_762629072">Bruk av OR	73</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15467_3971551474">Kombinasjon av OR og
	AND	74</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4512_762629072">Bruk av IN	75</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4514_762629072">Bruk av NOT	76</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc221_487959650">&#61609; Filtrering med
	bruk av jokertegn	77</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc9305_974749821">Bruk av LIKE	77</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15765_604779659">Skille mellom sm&aring;
	og store bokstaver ved bruk av jokertegn	77</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc223_487959650">Prosent-tegn (%)	77</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc225_487959650">Understrekingstegn (_)	79</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc227_487959650">Rette klammer ([ ])	79</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc14626_541183064">&#61609;
	Fullteksts&oslash;k	80</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc14628_541183064">Fullteksts&oslash;k med
	PostgreSQL	80</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc14630_541183064">Fullteksts&oslash;k med
	Microsoft SQL-server	83</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc13177_1590063026">Kapittel 4
	Funksjoner og beregnede kolonner	85</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc231_487959650">&#61609; Beregnede
	kolonner	85</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc233_487959650">&#61609; Skj&oslash;te
	sammen kolonner	85</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc235_487959650">Microsoft SQL-server	85</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc237_487959650">Oracle	86</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc239_487959650">MySQL/MariaDB	87</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc241_487959650">PostgreSQL	87</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc243_487959650">&#61609; Bruk av
	aliaser	88</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc245_487959650">&#61609; Kalkulerte
	kolonner	89</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16212_413252541">Kalkulerte kolonner med
	MySQL / MariaDB og PostgreSQL:	89</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16214_413252541">Kalkulerte kolonner med
	Microsoft SQL Server:	90</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16216_413252541">Kalkulerte kolonner med
	Oracle:	90</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16218_413252541">Kalkulering via
	undersp&oslash;rringer med MySQL / MariaDB:	90</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16220_413252541">Kalkulering via
	undersp&oslash;rringer med PostgreSQL:	91</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16222_413252541">Kalkulering via
	undersp&oslash;rringer med Oracle:	91</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16224_413252541">Kalkulering via
	undersp&oslash;rringer med Microsoft SQL Server:	92</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc10137_1613255157">&#61609; Betingelser
	med CASE	92</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15469_3971551474">CASE med MySQL /
	MariaDB, PostgreSQL, MS SQL Server og Oracle	93</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc247_487959650">&#61609; Bruk av
	funksjoner	95</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc249_487959650">&#61609; Funksjoner for
	manipulering av tekst:	95</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16226_413252541">Noen av de vanligste
	tekst-funksjonene:	95</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc251_487959650">&#61609; Funksjoner for
	manipulering av Dato og Tid	97</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15738_2263950102">TIMESTAMP	97</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc253_487959650">Datofunksjoner med MySQL
	/ MariaDB	98</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15740_2263950102">Navn p&aring; m&aring;neder
	og dager p&aring; ulike spr&aring;k	98</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15742_2263950102">Eksempler fra
	HR-databasen	99</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15744_2263950102">Beregne differansen
	mellom to datoer med funksjonen TIMESTAMPDIFF()	101</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc255_487959650">Datofunksjoner med
	Microsoft SQL Server	102</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15746_2263950102">Eksempler p&aring;
	bruk av datofunksjoner med Microsoft SQL Server	102</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15748_2263950102">Navn p&aring; m&aring;neder
	og dager p&aring; ulike spr&aring;k	103</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15750_2263950102">Eksempler fra
	HR-databasen	104</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc257_487959650">Datofunksjoner med
	Oracle	105</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16405_3466130985">Eksempler fra
	HR-databasen	106</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc259_487959650">Datofunksjoner med
	PostgreSQL	106</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23691_3962996256">Egne funksjoner med
	PostgreSQL	108</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc18232_1557834486">Kapittel 5
	Aggregering av data	111</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12160_1251604522">&#61609; AVG()	111</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12378_1251604522">MS SQL Server og
	AVG()	112</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12162_1251604522">&#61609; COUNT()	113</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12164_1251604522">&#61609; MAX()	113</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12166_1251604522">&#61609; MIN()	113</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12168_1251604522">&#61609; SUM()	113</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12380_1251604522">MS SQL Server og
	SUM()	114</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12170_1251604522">&#61609; Aggregering
	med distinkte verdier	115</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12172_1251604522">&#61609; Kombinering
	av aggregerte funksjoner	115</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc18234_1557834486">Kapittel 6
	Gruppering av Data	116</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc18236_1557834486">&#61609; Gruppering av
	data med GROUP BY	116</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc263_487959650">&#61609; Filtrering av
	grupper med HAVING	117</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13352_1054794037">&#61609; Gruppering
	med ROLLUP og CUBE	117</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12933_1158268304">ROLLUP og CUBE med
	Oracle	118</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12935_1158268304">ROLLUP med MySQL /
	MariaDB	119</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12937_1158268304">ROLLUP og CUBE med
	PostgreSQL	120</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12939_1158268304">ROLLUP og CUBE med MS
	SQL Server	122</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc26955_1534934292">Sorterte sett	123</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc18238_1557834486">Kapittel 7
	Undersp&oslash;rringer	124</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc18240_1557834486">&#61609; Filtrere med
	undersp&oslash;rringer	124</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc54925_1647982490">Eksempel 1: Hent
	titlene til de ansatte i utviklingsavdelingen.	124</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc54927_1647982490">Eksempel 2: Hent
	dagens l&oslash;nn for alle ansatte	125</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16234_413252541">Eksempel 3: Hente et
	resultat basert p&aring; en verdi vi ikke kjenner (men kan sl&aring;
	opp i en annen tabell)	126</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc26939_4124954731">&#61609; Bruke
	undersp&oslash;rringer til &aring; lage tabeller vi kan s&oslash;ke
	i med hovedsp&oslash;rringen	127</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc5699_920682125">&#61609; Bruke
	undersp&oslash;rringer til &aring; lage beregnede kolonner	129</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc18242_1557834486">Kapittel 8
	Joins	130</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc18244_1557834486">&#61609; Koble data
	fra flere tabeller med Join-setninger	130</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc17607_2563936057">Ulike typer joins	131</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc17609_2563936057">&#61609; INNER
	JOIN	132</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc17613_2563936057">INNER JOIN skrevet med
	EQUIJOIN-syntaks	132</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4436_762629072">INNER JOIN skrevet med
	INNER JOIN-syntaks	133</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19107_2730267216">Hvilken syntaks er
	best for &aring; skrive en INNER JOIN-setning?	134</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19109_2730267216">&#61609; OUTER
	JOIN	134</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc17615_2563936057">LEFT OUTER JOIN	134</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc17617_2563936057">RIGHT OUTER JOIN	135</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc17619_2563936057">FULL OUTER JOIN	135</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc17621_2563936057">&#61609; NATURAL
	JOIN	136</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4438_762629072">&#61609; Joins med flere
	enn to tabeller	137</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16236_413252541">Et mer komplekst
	eksempel:	138</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4440_762629072">Eksempler p&aring; OUTER
	JOINS	139</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc24604_3325804077"> &#61609;
	Sett-operasjoner med UNION, INTERSECT og EXCEPT	141</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc24606_3325804077">&#61609; Kombinerte
	Sp&oslash;rringer med UNION og UNION ALL	141</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4442_762629072">Bruk av UNION og UNION
	ALL	141</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23952_604322462">&#61609; Kombinerte
	sp&oslash;rringer med INTERSECT og EXCEPT	144</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23954_604322462">INTERSECT og EXCEPT med
	MS SQL server	144</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc24608_3325804077">&#61609;
	PIVOT-tabeller med SQL	145</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc24610_3325804077">PostgreSQL: PIVOT med
	CROSSTAB()	145</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc26599_1493065540">PIVOT og UNPIVOT med
	MS SQL Server	146</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc23693_3962996256">Kapittel 9
	Vindusfunksjoner	148</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23695_3962996256">&#61609;
	Vindusfunksjoner	148</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc14634_541183064">&#61609; Eksempel 1:
	Bruke en vindusfunksjon til &aring; lage et l&oslash;penummer	148</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19093_2730267216">Med MariaDB /
	MySQL	148</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19095_2730267216">Med PostgreSQL	149</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc14636_541183064">Med Oracle	150</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19097_2730267216">Med Microsoft SQL
	Server	150</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc14638_541183064">&#61609; Eksempel 2:
	Bruke en vindusfunksjon til &aring; lage en rangering	151</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<span style="font-style: normal"><a href="#__RefHeading___Toc16230_413252541">M</a><a href="#__RefHeading___Toc16230_413252541">ed
	</a><a href="#__RefHeading___Toc16230_413252541">MySQL/</a><a href="#__RefHeading___Toc16230_413252541">MariaDB,
	</a><a href="#__RefHeading___Toc16230_413252541">Oracle </a><a href="#__RefHeading___Toc16230_413252541">og
	PostgreSQL</a></span><a href="#__RefHeading___Toc16230_413252541">	151</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<span style="font-style: normal"><a href="#__RefHeading___Toc16232_413252541">M</a><a href="#__RefHeading___Toc16232_413252541">ed
	</a><a href="#__RefHeading___Toc16232_413252541">Microsoft
	SQL-server</a></span><a href="#__RefHeading___Toc16232_413252541">	154</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16899_3466130985">&#61609; Eksempel 3:
	Bruke vindusfunksjon til &aring; liste ut forskjellen mellom de
	ansattes l&oslash;nn og snittl&oslash;nnen for avdelingen de jobber
	i	156</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19099_2730267216">Med Oracle,
	MySQL/MariaDB og PostgreSQL	156</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19101_2730267216">Med Microsoft SQL
	Server	157</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc20653_3962996256">&#61609; Eksempel 4:
	Beregne l&oslash;nns&oslash;kning for en ansatt i forhold til l&oslash;nnen
	&aring;ret f&oslash;r med vindusfunksjonen lag()	157</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23697_3962996256">Med Oracle, PostgreSQL
	og MySQL/MariaDB	158</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23699_3962996256">Med Microsoft
	SQL-Server	158</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc24871_158302049">&#61609; Eksempel 5:
	Beregne l&oslash;nn i kvantiler	159</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc24873_158302049">NTILE() med MS SQL
	Server, PostgreSQL, MariaDB og Oracle	159</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23701_3962996256">&#61609; Aggregering
	med vindusfunksjoner	160</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23703_3962996256">&#61609; Eksempel 5:
	L&oslash;nnshistorikk med kumulativ sum	160</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23705_3962996256">Med Microsoft SQL
	Server	160</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23707_3962996256">Med Oracle, PostgreSQL
	og MySQL/MariaDB	161</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16409_3466130985">&#61609; Eksempel 6:
	En overforenklet bank-applikasjon	162</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19103_2730267216">Med PostgreSQL	162</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19105_2730267216">Med MySQL/MariaDB	166</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc18246_1557834486">Kapittel 10 Views
	og Materialized Views	170</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc18248_1557834486">&#61609; Bruk av
	Views	170</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4451_762629072">Views med MySQL /
	MariaDB	171</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4453_762629072">Views med PostgreSQL	172</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23709_3962996256">VIEWS med Oracle	172</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc26001_2626130113">Views med MS SQL
	Server	173</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4455_762629072">&#61609; Hvordan vise
	alle views i en database	174</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4457_762629072">MySQL / MariaDB	174</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4459_762629072">Oracle	175</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4461_762629072">PostgreSQL	175</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc26003_2626130113">MS SQL Server	176</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23711_3962996256">&#61609; Materialized
	Views	176</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23713_3962996256">For Oracle,
	PostgreSQL, MS SQL Server og MySQL/MariaDB	176</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23715_3962996256">&#61609; Ulike typer
	Materialized Views	177</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc23717_3962996256">Kapittel 11 Common
	Table Expressions (CTE)	178</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23719_3962996256">&#61609; CTE med
	PostgreSQL	178</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23721_3962996256">Eksempel 1: CTE med
	SELECT	178</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23723_3962996256">Eksempel 2: CTE med
	DELETE	179</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc26740_1534934292">Eksempel 3: CTE med
	Undersp&oslash;rring	181</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc25488_2464819632">&#61609; CTE med MS
	SQL Server	181</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc25490_2464819632">Eksempel 1: Rekursiv
	CTE	181</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc25763_1131955894">Eksempel 2: DELETE
	uten CTE	183</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc18250_1557834486">Kapittel 12
	Indekser	184</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13957_140935937">&#61609; N&aring;r b&oslash;r
	vi bruke indekser?	184</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc14214_2514959757">&#61609; Ulike typer
	indekser	184</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc14216_2514959757">B-Tree	185</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc14220_2514959757">GIN - Generalized
	Inverted Index	185</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc24612_3325804077">GIST - Generalized
	Search Tree	185</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19111_2730267216">Brin	185</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19113_2730267216">Hash	185</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19115_2730267216">Bit	186</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13959_140935937">&#61609; Oppretting av
	indekser	186</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc289_487959650">&#61609; Hvor effektiv er
	indeksen?	187</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16238_413252541">Med MySQL / MariaDB	187</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc18252_1557834486">Med MS SQL Server	188</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc18256_1557834486">Kapittel 13
	Innsetting, oppdatering og sletting av data	189</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc18258_1557834486">&#61609; Insetting av
	nye rader med INSERT INTO	189</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4471_762629072">&#61609; Bruk av INSERT
	INTO uten feltnavn	190</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4473_762629072">MySQL / MariaDB	190</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc357_487959650">&#61609; Oppdatere
	eksisterende rader med UPDATE	190</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4464_762629072">MySQL / MariaDB	191</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc17623_2563936057">&#61609; &laquo;UPSERT&raquo;
	og MERGE	192</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc17625_2563936057">UPSERT med MySQL /
	MariaDB	192</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc17627_2563936057">UPSERT / MERGE med
	ORACLE	193</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc17629_2563936057">UPSERT med Microsoft
	SQL Server	195</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc17631_2563936057">UPSERT med
	PostgreSQL	196</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc359_487959650">&#61609; Slette data med
	DELETE og TRUNCATE	196</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc23529_1624848858">Kapittel 14
	Komplekse Datatyper: Arrays, JSON og XML	198</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc18262_15578344861">&#61609; Komplekse
	datatyper	198</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23531_1624848858">&#61609; Arrays	198</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23533_1624848858">Arrays med
	PostgreSQL	198</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23535_1624848858">Innsetting av
	elementer i et array	199</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23537_1624848858">S&oslash;ke etter
	elementer i et array	199</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23539_1624848858">Oppdatering og
	sletting av elementer i et array:	201</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23541_1624848858">Operander og
	funksjoner for arrays i PostgreSQL	201</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23543_1624848858">&#61609; JSON	204</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23545_1624848858">JSON med
	PostgreSQL	204</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc23547_1624848858">Operander som kun
	gjelder for JSONB	207</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc25221_2723464228">&#61609; XML	209</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc25223_2723464228">XML med MS SQL
	Server	209</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc25225_2723464228">FOR XML PATH	210</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc25546_4206096343">Kapittel 15
	Geometriske og Geografiske data	212</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc25548_4206096343">&#61609; Geometriske
	datatyper	212</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc25550_4206096343">Geografiske og
	geometriske data med MS SQL Server	212</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc25552_4206096343">Datatypen
	Geography	213</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc25554_4206096343">Point Geography Data
	Type	213</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc25556_4206096343">Point Geometry Data
	Type	213</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc25558_4206096343">Eksempler	214</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc25765_1131955894">Eksempel 2 &ndash;
	byer som punkter	215</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc26111_1526864018">Oversikt over
	OGC-metoder som st&oslash;ttes av SQL Server	216</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc14069_140935937">Del 2 Distribuerte
	Databaser	218</a></b></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc18260_1557834486">Kapittel 16
	Introduksjon til Distribuerte databaser	219</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc18262_1557834486">&#61609; Hva er
	distribuerte databaser?	219</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc8276_1995625076">&#61609; Hva er
	NoSQL?	219</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc6095_317907475">&#61609; Brewers
	CAP-teorem	220</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4523_762629072">Konsistens	220</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4525_762629072">Tilgjengelighet	220</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4527_762629072">Partisjons-toleranse	220</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc4529_762629072">&#61609; Hva betyr dette
	i praksis?	223</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc18076_1687682778">&#61609; BASE
	erstatter ACID	223</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc13187_1590063026">Kapittel 17 Apache
	Hive og HiveQL	224</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13979_140935937">&#61609; Apache
	Hive	224</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13981_140935937">&#61609; Hive QL	224</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc6477_841703319">&#61609;
	Terminalklienten Beeline	224</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc13983_140935937">Kapittel 18 Apache
	Phoenix - SQL for HBase	228</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc8278_1995625076">&#61609; Hva er
	Phoenix?	228</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc13189_1590063026">&#61609; Noen
	eksempler	228</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19959_1644708593">Selv-&oslash;kende
	felt ved bruk av sekvenser	233</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc13987_140935937">Kapittel 19 Spark
	SQL	235</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc8282_1995625076">&#61609; Hva er
	Spark?	235</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc15659_820443553">&#61609; Hva er Spark
	SQL?	235</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc8284_1995625076">&#61609; Sparks
	terminalklienter	235</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc8286_1995625076">&#61609; SQL direkte
	mot en fil	237</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc8288_1995625076">&#61609; Spark SQL via
	Scala, Python, Java og R	238</a></p>
	<p style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<b><a href="#__RefHeading___Toc9929_2115805896">Vedlegg 1
	Installasjon og konfigurering av MySQL, MariaDB, PostgreSQL, Oracle
	Express og MS SQL Server	241</a></b></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19553_1580825334">&#61609; MySQL	241</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc5706_920682125">Linux	241</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19081_2730267216">Ubuntu / Debian /
	Linux Mint	241</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19083_2730267216">Fedora / Red Hat /
	Centos:	241</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19085_2730267216">SuSE / OpenSuse	241</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc5708_920682125">&#61609; Installasjon av
	MariaDB	242</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc5710_920682125">Windows / Mac	242</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc5712_920682125">Linux	242</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19087_2730267216">Ubuntu / Debian /
	Linux Mint	242</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19089_2730267216">Fedora / Red Hat /
	Centos	242</a></p>
	<p style="margin-left: 1.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc19091_2730267216">SuSE / OpenSuse	242</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc6017_317907475">&#61609; Installasjon av
	PostgreSQL og pgAdmin	242</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc6019_317907475">Windows / Mac	242</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc16240_413252541">&#61609; Installere
	PostgreSQL p&aring; en Linux-server (eller laptop e.l.)	243</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12583_268258650">Red Hat (RHEL) /
	Centos	243</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12585_268258650">Fedora	243</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12587_268258650">Ubuntu / Debian	243</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc12589_268258650">OpenSuSE / SuSE Linux
	Enterprise Server (SLES)	243</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<a href="#__RefHeading___Toc9931_2115805896">&#61609; Installere
	Microsoft SQL-server p&aring; en Linux-server	244</a></p>
</div>
<p class="western"><br/>
<br/>

</p>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc15235_820443553"></a>
Innledning</h1>
<p class="western">Denne boken er delt i to hoveddeler:</p>
<p class="western"><b>Del 1</b> tar for seg SQL slik spr&aring;ket
brukes i relasjonelle databaser, med eksempler p&aring;
dialektforskjeller mellom de 4 store relasjonelle databasene: Oracle,
MySQL/MariaDB, Microsoft SQL Server og PostgreSQL. 
</p>
<p class="western"><b>Del 2</b> introduserer distribuerte databaser
og hvordan SQL blir brukt i stadig st&oslash;rre grad innenfor det
som gjerne kalles NoSQL-databaser, som p&aring; grunn av SQLs
popularitet har blitt redefinert til &aring; representere <i>Not Only
SQL</i>. Her vises eksempler p&aring; forskjeller og spesialiteter
knyttet til databaser som bruker innen Big Data, som Apache Hive,
Phoenix (SQL for HBase), Hawq (distribuert PostgreSQL/Greenplum) og
Spark SQL. 
</p>
<p class="western">Hovedfokus i begge hoveddelene er selve spr&aring;ket
SQL, med vekt p&aring; kompatibilitet og belysing av
dialektforskjeller mellom ulike implementeringer av SQL. Boken
inneholder ogs&aring; informasjon om nedlasting, installasjon og
konfigurering av de databaseh&aring;ndteringsystemene som omtales.</p>
<p class="western">Som tittelen antyder er boken ment som en
introduksjon til spr&aring;ket SQL og pretenderer ikke &aring; gi
noen utfyllende eller komplett beskrivelse av spr&aring;ket. Det er
lenker til videre dokumentasjon og veiledninger for de ulike
databasesystemene i de kapitlene hvor de omtales. Som all annen IT er
ogs&aring; SQL i konstant utvikling, og ikke minst legges det hele
tiden til ny funksjonalitet fra de ulike database-leverand&oslash;rene.
S&aring; hvis du er i tvil, sjekk alltid dokumentasjonen til
versjonen av den databasen du bruker SQL mot.</p>
<p class="western" align="center"><br/>
<br/>

</p>
<h1 class="western" align="center" style="page-break-before: always"></h1>
<h1 class="western" align="center"><a name="__RefHeading___Toc6135_317907475"></a>
<font size="7" style="font-size: 36pt">Del 1<br/>
</font>Relasjonelle
Databaser<br/>
<br/>
<br/>
<br/>

</h1>
<p class="western" align="center"><br/>
<br/>

</p>
<p class="western" align="center"><br/>
<br/>

</p>
<p class="western" style="page-break-before: always"><br/>
<br/>

</p>
<h1 class="western"><a name="__RefHeading___Toc18222_1557834486"></a><font size="6" style="font-size: 24pt">Kapittel
1</font><font size="6" style="font-size: 24pt"><br/>
</font>Introduksjon
til relasjonelle databaser og SQL</h1>
<h2 class="western"><a name="__RefHeading___Toc18224_1557834486"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Hva er en database?</h2>
<p class="western" align="left">N&aring;r vi snakker om en <b>database
</b>mener vi gjerne &eacute;n av to ting, enten: 
</p>
<p class="western" align="left">1) Databaseh&aring;ndteringsystemet<b>,
</b><span style="font-weight: normal">som gjerne forkortes til </span><b>DBMS</b>
(Data Base Management System) og er <b>programvaren</b> som
administrerer systemet, dvs. organiserer dataene og styrer all lesing
og skriving til databasen. Popul&aelig;re DBMSer er MySQL,
PostgreSQL, Microsoft SQL Server og Oracle. En av disse er gjerne
svaret p&aring; sp&oslash;rsm&aring;let: Hvilken database bruker
dere?</p>
<p class="western" align="left">eller</p>
<p class="western" align="left">2) <b>D</b><b>atabasen</b>, som er de
<b>lagrede </b><b>data </b>som h&aring;ndteres av systemet. Dette er
f.eks. betydningen som ligger i sp&oslash;rsm&aring;let: Har du
sikkerhetskopiert databasen? 
</p>
<h2 class="western" style="font-weight: normal"><a name="__RefHeading___Toc13923_140935937"></a>
<strong><font color="#1b75bc">&#61609;</font></strong> Hva er en
relasjonell database?</h2>
<p class="western">Det finnes ulike typer databasesystemer. En vanlig
m&aring;te &aring; kategorisere dem p&aring; er etter <b>datamodellen</b>
de bruker, dvs etter hvordan databasen organiserer data. Den mest
brukte datamodellen er <b>relasjonsmodellen, </b><span style="font-weight: normal">og
</span><span style="font-weight: normal">en database som organiserer
data etter relasjonsmodellen kalles en </span><b>relasjonell
database,</b>  ofte forkortet til det engelske akronymet RDBMS
(Relational Data Base Management System). 
</p>
<p class="western">En <b>relasjonell database</b> er m.a.o. en
database som er organisert etter <b>relasjonsmodellen</b>.</p>
<h2 class="western"><a name="__RefHeading___Toc16104_604779659"></a><strong><font color="#1b75bc">&#61609;</font></strong>
To ulike typer relasjonelle databaser: OLTP og OLAP 
</h2>
<p class="western">Relasjonelle databaser har blitt delt inn i to
ulike hovedtyper etter bruksomr&aring;de: <b>OLTP</b> (Online
Transaction Processing) og <b>OLAP</b> (Online Analytical
Processing). Her er en kort beskrivelse av hovedforskjellene mellom
dem:</p>
<h3 class="western"><a name="__RefHeading___Toc16106_604779659"></a>OLTP-databaser</h3>
<p class="western">En typisk OLTP-database er for eksempel knyttet
til <b>kassa-apparatet i en butikk</b>. Hver gang en vare skannes
registrerer databasen en ny rad med informasjon som varenummer,
antall m.m., og til slutt lagres dette sammen med kortinformasjonen
til kunden, tidspunktet for handelen osv. Det skrives mao nye rader
til tabeller i databasen kontinuerlig, derav betegnelsen <b>Transaction
Processing</b><span style="font-weight: normal">,</span> for slike
databaser brukes prim&aelig;rt til &aring; prosessere transaksjoner. 
</p>
<p class="western"><b>En OLTP-database er en database som det skrives
ofte til og leses sjelden fra</b>. For n&aring;r butikksjefen, eller
butikk-kjedesjefen skal hente en oversikt over hvor mye potetgull som
ble solgt i Bergen i uke 34 i forhold til uke 34 i fjor, g&aring;r
han eller hun ikke inn i kassasystemet og summerer opp. Det ville
tatt altfor lang tid, og ville i tillegg v&aelig;rt en belastning p&aring;
databasen som er opptatt med &aring; hele tiden lagre nye varekj&oslash;p.
I stedet knas og aggregeres data fra OLTP-databasene med jevne
mellomrom og lastes  over i OLAP-databaser, hvor det kan s&oslash;kes
i ferdig summerte tabeller.</p>
<h3 class="western"><a name="__RefHeading___Toc16108_604779659"></a>OLAP-databaser
    
</h3>
<p class="western">Som det fremg&aring;r av begrepet <b>Analytical
Processing </b><span style="font-weight: normal">er </span>OLAP-databaser
er databaser som er laget for analyser. Det s&oslash;kes kontinuerlig
i OLAP-databasens tabeller, hvor data grupperes og summeres p&aring;
ulike m&aring;ter til ulike analyseform&aring;l. Typiske
OLAP-databaser er <b>Datavarehus</b> og systemer for <b>Business
Intelligence (BI)</b><span style="font-weight: normal">.</span></p>
<p class="western"><b>En OLAP-database er mao en database som det
leses mye fra og skives sjelden til. </b>
</p>
<h2 class="western" style="font-weight: normal"><a name="__RefHeading___Toc6461_841703319"></a>
<strong><font color="#1b75bc">&#61609;</font></strong>
Relasjonsmodellen</h2>
<p class="western"><b>Relasjonsmodellen</b> ble utarbeidet av Edgar
Codd i 1969-70 . Databaser basert p&aring; denne modellen organiserer
dataene i <b>tabeller</b> som igjen inneholder <b>kolonner</b> (ogs&aring;
kalt <b>felt</b>). <b>Normalisering</b> er et sentralt begrep i
relasjonelle databaser, og kort fortalt inneb&aelig;rer normalisering
at data splittes opp i flere tabeller som s&aring; bindes sammen og
reguleres av <b>n&oslash;kler</b>. En kolonne kan defineres som
<b>fremmedn&oslash;kkel</b> i en tabell, som f.eks. refererer til en
kolonne som er definert som <b>prim&aelig;rn&oslash;kkel </b><span style="font-weight: normal">i
en annen tabell, og tabellene kan s&aring; bindes sammen ved hjelp av
SQL-setninger som inneholder </span><b>joins </b><span style="font-weight: normal">eller</span><b>
under-sp&oslash;rringer.</b><b> </b><span style="font-weight: normal">Vi
skal g&aring; igjennom dette i detalj i senere kapitler.</span></p>
<h2 class="western"><a name="__RefHeading___Toc13925_140935937"></a><strong><font color="#1b75bc">&#61609;</font></strong>
<span style="font-weight: normal">A</span><span style="font-weight: normal">ndre
modeller for organisering av data</span></h2>
<p class="western"><span style="font-weight: normal">D</span><span style="font-weight: normal">et
finnes flere andre m&aring;ter &aring; organisere data i en database
p&aring; enn relasjonsmodellen. </span><b>Dokument-orienterte
databaser </b><span style="font-weight: normal">organiserer f.eks.
data i dokumenter som lagres i dokumentsamlinger, mye likt filer og
mapper i et filsystem. Databaseh&aring;ndteringsystemet</span><span style="font-weight: normal">
</span><b>MongoDB </b><span style="font-weight: normal">er et
eksempel p&aring; en database som bruker </span><b>dokumentmodellen</b><span style="font-weight: normal">,
og MongoDB har utviklet et eget sp&oslash;rrespr&aring;k til &aring;
s&oslash;ke i databasens dokumenter. </span>
</p>
<p class="western"><b>Grafiske database</b><b>r</b><b> </b><span style="font-weight: normal">organiserer
data i noder og forbindelseslinjer (nodes and edges) og bruker heller
ikke relasjonsmodellen. Den svensk-utviklede databasen </span><b>Neo4j</b><span style="font-weight: normal">
(utt: Neo-for-Jay) er f.eks. et mye brukt grafisk
databaseh&aring;ndteringsystem.</span></p>
<p class="western"><b>Kolonnebaserte databaser </b><span style="font-weight: normal">organiserer
data i kolonner, som av og til igjen er organisert i </span><b>kolonnefamilier,
</b><span style="font-weight: normal">og dette gj&oslash;r det bl.a.
raskt &aring; s&oslash;ke opp data fra hele kolonner av gangen.
Kolonnebaserte databaser, som f.eks. HBase og Cassandra st&oslash;tter
vanligvis ikke relasjonsmodellen fullt ut, men det er blitt laget
tiln&aelig;rminger som gj&oslash;r at man kan bruke i alle fall deler
av SQL til &aring; s&oslash;ke ogs&aring; i noen av disse databasene
&ndash; f.eks. Apache Phoenix som tilbyr et SQL-grensesnitt mot
HBase, og CQL som er et SQL-liknende sp&oslash;rrespr&aring;k for
Cassandra. </span>
</p>
<h2 class="western"><a name="__RefHeading___Toc15760_820443553"></a><strong><font color="#1b75bc">&#61609;</font></strong>
<span style="font-weight: normal">H</span><span style="font-weight: normal">va
er SQL?</span></h2>
<p class="western" align="left"><b>SQL </b><span style="font-weight: normal">(Structured
Query Language), </span><span style="font-weight: normal">som denne
boken </span><span style="font-weight: normal">omhandler</span><span style="font-weight: normal">,
</span><span style="font-weight: normal">er et  </span><b>sp&oslash;rrespr&aring;k
</b><span style="font-weight: normal">som brukes mot relasjonelle
databaser, og de senere &aring;rene ogs&aring; mot noen distribuerte
databaser (se del 2 av denne boken). </span>
</p>
<p class="western" align="left"><span style="font-weight: normal">SQL
er et s&aring;kalt </span><b>deklarativt spr&aring;k </b><b>-</b><b>
</b><span style="font-weight: normal">i motsetning til</span><b>
</b><b>imperativ</b><b>e, objektorienterte </b><span style="font-weight: normal">eller</span><b>
funksjonelle</b><b> </b><b>spr&aring;k </b><span style="font-weight: normal">(som
de fleste vanlige  programmeringsspr&aring;k er)</span><b>  </b><b>-
</b><span style="font-weight: normal">og SQL-syntaksen er laget for &aring;
ligne mest mulig p&aring; vanlig engelsk</span><span style="font-weight: normal">.
</span><span style="font-weight: normal">I</span><span style="font-weight: normal">
praksis bet</span><span style="font-weight: normal">yr dette at du
skriver en sp&oslash;rresetning som ligner en del p&aring; hvordan du
ville sp&oslash;rre etter data p&aring; vanlig engelsk, og uten &aring;
m&aring;tte tenke p&aring; </span><b>hvordan</b><span style="font-weight: normal">
data s&oslash;kes opp. </span><span style="font-weight: normal">Du
beskriver hvilke data du vil hente med SQL,
d</span><span style="font-weight: normal">atabase</span><span style="font-weight: normal">h&aring;ndteringssystemet
analyserer SQL-setningen,  finner den mest effektive m&aring;ten</span><span style="font-weight: normal">
&aring; gjennomf&oslash;re s&oslash;ket </span><span style="font-weight: normal">p&aring;</span><span style="font-weight: normal">
og gi</span><span style="font-weight: normal">r</span><span style="font-weight: normal">
deg tilbake en tabell med data. </span>
</p>
<p class="western" align="left" style="font-weight: normal">SQL
brukes b&aring;de til &aring; lese fra og skrive til databaser. SQL
kan opprette og slette databaser og  tabellstrukturer, sette inn data
organisert i rader og kolonner, og SQL kan endre data, slette data og
gjennomf&oslash;re enkle og avanserte s&oslash;k etter data i en
eller flere tabeller. 
</p>
<p class="western" align="left" style="font-weight: normal">For &aring;
skille de ulike bruksomr&aring;dene fra hverandre har man delt SQL
inn i f&oslash;lgende deler:</p>
<h3 class="western"><a name="__RefHeading___Toc10408_1613255157"></a>DDL
(Data Definition Language)</h3>
<p class="western" align="left" style="font-weight: normal">Med DDL
kan man opprette databaser og tabeller, lage tabellstrukturer, views
og indekser, samt endre og slette dem. Typiske n&oslash;kkelord innen
DDL er feks.:</p>
<pre class="western">CREATE, ALTER, DROP, TRUNCATE, COMMENT, RENAME </pre><h3 class="western">
<a name="__RefHeading___Toc10410_1613255157"></a>DML (Data
Manipulation Language)</h3>
<p class="western" align="left" style="font-weight: normal">Med DML
kan man jobbe med data i de strukturene man har opprettet med DDL.
N&oslash;kkelord innen DML er f.eks.:</p>
<pre class="western"><span style="font-weight: normal">SELECT, </span>INSERT, UPDATE, DELETE</pre><h3 class="western">
<a name="__RefHeading___Toc10412_1613255157"></a>DCL (Data Control
Language)</h3>
<p class="western" align="left"><b>DCL </b><span style="font-weight: normal">inneholder
setninger for &aring; gi eller frata tilgangsrettigheter til brukere.
Avhengig </span><span style="font-weight: normal">av hvilken DBMS man
bruker kan rettigheter gis p&aring; ulike niv&aring;er (database,
tabell, rad, rute) for s&oslash;k, innsetting, oppdatering sletting
osv. Det er to hoved-n&oslash;kkelord innen DCL, som henholdsvis
tildeler og tilbakekaller rettigheter:</span></p>
<pre class="western" style="font-weight: normal">GRANT og REVOKE</pre><h3 class="western">
<a name="__RefHeading___Toc10414_1613255157"></a>TCL (Transaction
Control Language)</h3>
<p class="western" align="left"><b>TCL </b><span style="font-weight: normal">brukes
innenfor transaksjoner (se kapittel XXX), dvs. n&aring;r vi vil sikre
at hele </span><span style="font-weight: normal">(</span><span style="font-weight: normal">og
ikke bare deler</span><span style="font-weight: normal">)</span><span style="font-weight: normal">
av en databaseoperasjon utf&oslash;res. </span><span style="font-weight: normal">TCL
lar m</span><span style="font-weight: normal">ed andre ord</span><span style="font-weight: normal">
</span><span style="font-weight: normal">SQL-</span><span style="font-weight: normal">setninger
bli gruppert i logiske transaksjoner. </span><span style="font-weight: normal">N&oslash;kkelord
her er f.eks.:</span></p>
<pre class="western">BEGIN, COMMIT, SAVEPOINT, ROLLBACK, SET TRANSACTION<span style="font-weight: normal"> </span></pre><h2 class="western" align="left" style="font-weight: normal">
<a name="__RefHeading___Toc12577_268258650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
SQL-standarder og dialekter</h2>
<p class="western">Det finnes flere standarder for SQL, blant annet
<b>ANSI SQL</b> <span style="font-weight: normal">etter den
amerikanske organisasjonen American National Standardization
Institute (ANSI) hvor SQL ble en standard i 1986 eller </span><b>ISO
SQL</b> <span style="font-weight: normal">etter organisasjonen
International Organization for Standardization (ISO) hvor SQL ble en
standard i 1987. SQL-standarden er under utvikling, og den versjonen
som er st&oslash;ttet av flest teknologier er fremdeles SQL-92, mens
det finnes flere nyere versjoner: SQL-99 og SQL-2003, SQL-2008 og
SQL-2011. Ulike versjoner av ulike databasesystemer</span> <span style="font-weight: normal">st&oslash;tter
ulike deler av de ulike standardene &ndash; det er mao. tiln&aelig;rmet
umulig &aring; vite hvilke deler av hvilken standard databasen din
st&oslash;tter uten &aring; sjekke dokumentasjonen for den versjonen
du bruker.</span></p>
<p class="western" align="left"><span style="font-weight: normal">De
mest popul&aelig;re databasesystemene har (dessverre</span> <span style="font-weight: normal">eller
heldigvis, avhengig av st&aring;sted) lagt til egne funksjoner og
spr&aring;klige s&aelig;regenheter til SQL-standarden, og ingen av
dem f&oslash;lger den 100%. Dermed har det utviklet seg
</span><b>dialektforskjeller </b><span style="font-weight: normal">i
spr&aring;ket, og vi skal bruke en del plass i dette kurset p&aring;
&aring; belyse disse forskjellene, som ikke minst blir viktige n&aring;r
man skal skrive SQL-setninger som skal v&aelig;re mest mulig portable
mellom de ulike systemene.</span></p>
<h2 class="western" align="left" style="font-weight: normal"><a name="__RefHeading___Toc12579_268258650"></a>
<strong><font color="#1b75bc">&#61609;</font></strong> &laquo;De fire
store&raquo;</h2>
<p class="western" style="font-weight: normal">I denne boken skal vi
hovedsakelig se p&aring; dialektforskjellene mellom de fire mest
brukte SQL-baserte relasjonsdatabasene: 
</p>
<ol>
	<li><p class="western" style="margin-bottom: 0cm"><strong>MySQL /
	</strong><strong>MariaDB</strong></p>
	<li><p class="western" style="margin-bottom: 0cm"><strong>Oracle</strong></p>
	<li><p class="western" style="margin-bottom: 0cm"><strong>Microsoft
	SQL Server</strong></p>
	<li><p class="western"><strong>PostgreSQL</strong></p>
</ol>
<p class="western"><strong><span style="font-weight: normal">D</span></strong><strong><span style="font-weight: normal">isse
</span></strong><strong><span style="font-weight: normal">fire
RDBMSene </span></strong><strong><span style="font-weight: normal">forholder
seg til SQL-standardene p&aring; litt forskjellige m&aring;ter. De
har ogs&aring; ulike funksjoner, datatyper og lagringsformater. Og
ikke minst har de forskjellige server- og klientverkt&oslash;y for
administrasjon, drift, s&oslash;k i data osv. </span></strong>
</p>
<p class="western"><strong><span style="font-weight: normal">Men alle
</span></strong><strong><span style="font-weight: normal">fire </span></strong><strong><span style="font-weight: normal">har
en terminalklient, dvs. et klientverkt&oslash;y som man kan koble seg
til databaser med og utf&oslash;re diverse oppgaver med </span></strong><strong><span style="font-weight: normal">via
</span></strong><strong><span style="font-weight: normal">SQL. Og vi
skal bruke disse terminalklientene gjennom denne boken. Dermed
fjerner vi oss fra de grafiske verkt&oslash;yenes ulike grensesnitt
og f&aring;r fokus p&aring; rene SQL-setninger, skrevet i et
tekstbasert terminalvindu. </span></strong><strong><span style="font-weight: normal">Vi
skal introdusere ulike grafiske verkt&oslash;y ogs&aring;, for de har
av og til mer funksjonalitet enn terminalklientene og gj&oslash;r det
som regel enklere &aring; skrive og ta vare p&aring; lengre,
komplekse SQL-setninger.</span></strong></p>
<p class="western"><strong><span style="font-weight: normal">Det
finnes selvf&oslash;lgelig en rekke andre RDBMSer som bruker SQL som
sp&oslash;rrespr&aring;k. Nettstedet <a href="https://db-engines.com/">https://db-engines.com</a>
har </span></strong><strong><span style="font-weight: normal">p.t. </span></strong><strong><span style="font-weight: normal">en
rangering av 330 ulike DBMSer, hvorav 132 er av den Relasjonelle
typen. </span></strong><strong><span style="font-weight: normal">Blant
disse finner vi IBMs DB2, Microsofts Access, SQLite, Teradata,
Netezza og den arkaiske dBase, en av de f&oslash;rste RDBMSene man
kunne installere p&aring; en PC </span></strong><strong><span style="font-weight: normal">og
den f&oslash;rste databasen denne forfatteren programmerte mot. </span></strong><strong><span style="font-weight: normal">
</span></strong>
</p>
<h3 class="western"><a name="__RefHeading___Toc16751_3466130985"></a><strong><span style="font-weight: normal">Kort
om MySQL og MariaDB</span></strong></h3>
<p class="western"><b>MySQL</b> er et SQL-basert
databaseadministrasjonssystem som er lisensiert under GPL. Denne
databasetjeneren er veldig mye brukt, og er en vesentlig del av den
s&aring;kalte LAMP-stacken, hvor M-en st&aring;r for nettopp MySQL
(og L for Linux operativsystem, A for Apache webserver og P for PHP
programmeringsspr&aring;k). MySQL ble utviklet av bl.a. finnen
<b>Michael &laquo;Monty&raquo; Widenius</b> (oppkalt etter hans
datter My), som solgte MySQL AB til Sun Microsystems for 1 milliard
dollar i 2008. Det h&oslash;rer med til historien at Monty skal ha
lagt inn en klausul i kj&oslash;psavtalen om at Sun ikke fikk lov til
&aring; videreselge MySQL til Oracle, siden det var frykt for at
Oracle skulle kj&oslash;pe den irriterende gratis-konkurrenten MySQL
og f.eks. legge den ned. Det ingen p&aring; det tidspunktet klarte &aring;
forutse var det som faktisk skjedde, nedlig at Oracle i 2010 kj&oslash;pte
opp <i>hel</i>e Sun og dermed ogs&aring; ble eier og videreutvikler
av MySQL.</p>
<p class="western">&laquo;Monty&raquo; Widenius og andre
kjerneutviklere startet sitt eget selskap <b>MariaDB AB</b> (oppkalt
etter Montys andre datter Maria) med en kopi av kildekoden til MySQL,
som de siden har videreutviklet. MariaDB er fremdeles en &quot;drop
in replacement&quot; for MySQL, og mange har valgt &aring; bruke
denne, mens andre foretrekker Oracles MySQL. 
</p>
<h3 class="western"><a name="__RefHeading___Toc16753_3466130985"></a><strong><span style="font-weight: normal">Kort
om Oracle</span></strong></h3>
<p class="western"><strong><b>Oracle Database</b></strong><strong>
</strong><strong><span style="font-weight: normal">(</span></strong><strong><span style="font-weight: normal">ogs&aring;
kalt </span></strong><strong><span style="font-weight: normal">Oracle
RDBMS  </span></strong><strong><span style="font-weight: normal">eller
bare </span></strong><strong><span style="font-weight: normal">Oracle)
</span></strong><strong><span style="font-weight: normal">er</span></strong><strong><span style="font-weight: normal">
</span></strong><strong><span style="font-weight: normal">et</span></strong><strong><span style="font-weight: normal">
object-relational database management system. </span></strong><strong><b>(ORDBMS)</b></strong><strong><span style="font-weight: normal">,
</span></strong><strong><span style="font-weight: normal">og den
ekstra O&rsquo;en </span></strong><strong><span style="font-weight: normal">henspeiler
p&aring; at </span></strong><strong><span style="font-weight: normal">den
er objekt-orientert, slik at man </span></strong><strong><span style="font-weight: normal">kan
lage database-objekter som bla. kan arve egenskaper fra hverandre
</span></strong><strong><span style="font-weight: normal">osv.
Oracle-databasen er utviklet og selges av av </span></strong><strong>Oracle
Corporation.</strong></p>
<p class="western">Larry Ellison, Bob Miner og Ed Oates startet
selskapet Software Development Laboratories (SDL) i 1977, og dette
firmaet utviklet den f&oslash;rste utgaven av Oracle. Dagens
versjon(er) av Oracle er en sofistikert RDBMS med en rekke
konfigurerbare parametre, en relativt dyr lisens og en stor
brukermasse. 
</p>
<p class="western">Det finnes en rekke grafiske klienter som kan
kommunisere med Oracle, bl.a. <b>Oracle SQL Developer</b> som kan
lastes ned gratis fra Oracles nettsider. <b>Toad </b><span style="font-weight: normal">er
en annen popul&aelig;r klient, som ogs&aring; finnes som en gratis
plugin til </span><b>Eclipse</b><span style="font-weight: normal">
(som kan lastes ned gratis fra www.eclipse.org). </span>
</p>
<p class="western">Oracle kommer ogs&aring; med en terminalklient -
<b>sqlplus</b> &ndash; som er best egnet til &aring; kj&oslash;re
SQL-skript som er skrevet i en annen editor, lagret som en tekstfil
og som sendes til terminalklienten. Men det er ogs&aring; mulig, om
enn lite elegant, &aring; skrive SQL rett i kommandolinjen til
sqlplus. 
</p>
<h3 class="western"><a name="__RefHeading___Toc16755_3466130985"></a><strong><span style="font-weight: normal">Kort
om Microsoft SQL Server</span></strong></h3>
<p class="western"><strong><b>Microsoft SQL</b></strong><strong><span style="font-weight: normal">
Server </span></strong><strong><span style="font-weight: normal">ble
opprinnelig utviklet av Microsoft sammen med</span></strong><strong><span style="font-weight: normal">
</span></strong><strong><span style="font-weight: normal">selskapene
</span></strong><strong><span style="font-weight: normal">Sybase </span></strong><strong><span style="font-weight: normal">og
Ashton Tate og </span></strong><strong><span style="font-weight: normal">&laquo;portet&raquo;
til OS/2 i 1988. </span></strong><strong><span style="font-weight: normal">(</span></strong><strong><span style="font-weight: normal">Sybase
ble for&oslash;vrig kj&oslash;pt av SAP i 2010 og er idag en
integrert del av SAP</span></strong><strong><span style="font-weight: normal">)</span></strong><strong><span style="font-weight: normal">.</span></strong><strong><span style="font-weight: normal">
 Sp&oslash;rrespr&aring;ket som benyttes </span></strong><strong><span style="font-weight: normal">av
Microsoft SQL Server </span></strong><strong><span style="font-weight: normal">er
</span></strong><strong><b>Transact-SQL</b></strong><strong><span style="font-weight: normal">,
en implementasjon av ANSI/ISO standard SQL. SQL Server </span></strong><strong><span style="font-weight: normal">7.0.
fra 1998 inkluderte OLAP-funksjonalitet og i 2000-versjonen ble det
lagt til rapporterings-funksjoner. Nye versjoner med forbedringer og
tillegg har blitt utviklet via SQLServer 2005, 2008, osv til vi ved
denne bokens tilblivelse er p&aring; versjonen </span></strong><strong><b>SQL
Server 2017. </b></strong>
</p>
<p class="western"><strong><span style="font-weight: normal">To
interessante endringer skjedde med SQL Server 2016: Det ble lansert
en </span></strong><strong><b>Linux-versjon</b></strong><strong><span style="font-weight: normal">
av serveren, som frem til da bare hadde kunnet installeres p&aring;
en Windows-server. Og en ved &aring; registrere en utvikler-konto hos
Microsoft kunne man fra da av laste ned og installere serveren </span></strong><strong><b>gratis
for utviklings- og demonstrasjons-form&aring;l</b></strong><strong><span style="font-weight: normal">.
Noe bla. forfatteren av denne boken har benyttet seg av til
undervisning ved diverse SQL-kurs. </span></strong><strong><span style="font-weight: normal">Installasjonen
p&aring; en Linux-server er enkel og rask, og inneholder bla. en helt
grei terminalklient for Linux, i tillegg til</span></strong><strong><span style="font-weight: normal">
</span></strong><strong><span style="font-weight: normal">at man ogs&aring;
kan installere Microsoft SQL Management Studio for Windows. </span></strong><strong><span style="font-weight: normal">Se
vedlegg xxx for installasjonsveiledning. </span></strong>
</p>
<h3 class="western"><a name="__RefHeading___Toc16877_1783146702"></a><strong><span style="font-weight: normal">Kort
om PostgreSQL</span></strong></h3>
<p class="western"><strong><span style="font-weight: normal">PostgreSQL
het opprinnelig Postgres og </span></strong><strong><span style="font-weight: normal">ble
utviklet ved </span></strong><strong><span style="font-weight: normal">University
of California, </span></strong><strong><span style="font-weight: normal">Berkeley
i USA </span></strong><strong><span style="font-weight: normal">av
bl.a. </span></strong><strong><span style="font-weight: normal">Michael
Stonebraker,</span></strong><strong><span style="font-weight: normal">som
en videref&oslash;ring av databasen </span></strong><strong><b>Ingres</b></strong><strong><span style="font-weight: normal">
p&aring; 1980-tallet. Etter noen navneendringer (Post-Ingres,
Postgres, Postgres95) ble det endelige navnet PostgreSQL valgt i 1996
for &aring; understreke at databasen n&aring; </span></strong><strong><span style="font-weight: normal">-
</span></strong><strong><span style="font-weight: normal">takket v&aelig;re
studentene Andrew Yu og Jolly Chen </span></strong><strong><span style="font-weight: normal">-
</span></strong><strong><span style="font-weight: normal">st&oslash;ttet
SQL som sp&oslash;rrespr&aring;k.  </span></strong>
</p>
<p class="western"><strong><span style="font-weight: normal">I likhet
med Oracle er </span></strong><strong><span style="font-weight: normal">PostgreSQL
en </span></strong><strong><span style="font-weight: normal">s&aring;kalt
</span></strong><strong><b>object-relational database management
system </b></strong><strong><b>(ORDBMS)</b></strong><strong><b>.</b></strong><strong><span style="font-weight: normal">
</span></strong><strong><span style="font-weight: normal">For&oslash;vrig
legger PostgreSQL vekt p&aring; at den fors&oslash;ker &aring; f&oslash;lge
standarder</span></strong><strong><span style="font-weight: normal">
</span></strong><strong><span style="font-weight: normal">strikt,
bl.a. </span></strong><strong><b>ANSI-SQL:2008</b></strong><strong><span style="font-weight: normal">-</span></strong><strong><span style="font-weight: normal">standard</span></strong><strong><span style="font-weight: normal">en,
og at  den er bygget slik at det er enkelt for andre &aring; lage
utvidelser til den. Og det finnes en rekke slike utvidelser man kan
installere og bruke sammen med kjernefunksjonene i databasen. En av
de mest kjente er antagelig </span></strong><strong><b>PostGIS</b></strong><strong><span style="font-weight: normal">,
som gj&oslash;r PostgreSQL til et komplett system for h&aring;ndtering
av geografiske data.  </span></strong><strong><span style="font-weight: normal">PostgreSQL
har antagelig den beste terminalklienten av de fire - </span></strong><strong><b>psql</b></strong><strong><span style="font-weight: normal">
- som er enkel og oversiktlig &aring; bruke og har en rekke
funksjoner. Av grafiske verkt&oslash;y er </span></strong><strong><b>pgAdmin4
</b></strong><strong><span style="font-weight: normal">det meste
avanserte </span></strong><strong><span style="font-weight: normal">n&aring;r
denne boken publiseres.</span></strong><strong><span style="font-weight: normal">.
 </span></strong><strong><b> </b></strong>
</p>
<p class="western"><strong><span style="font-weight: normal">PostgreSQL
er den minst brukte av de fire store RDBMSene, men &oslash;ker stadig
i bruk, spesielt siden versjon 9 ble lansert, hvor bl.a. databasens
hastighet &oslash;kte vesentlig. Utviklingen skjer gjennom en
kjernegruppe sammensatt av utviklere fra ulike organisasjoner, og </span></strong><strong><span style="font-weight: normal">det
er mao. ikke ett firma alene som har eierskap til produktet.</span></strong></p>
<h3 class="western"><a name="__RefHeading___Toc20016_3710899157"></a>Hvilken
RDBMS b&oslash;r jeg velge til eksemplene og oppgavene i denne boken?</h3>
<p class="western"><strong><span style="font-weight: normal">Alle de
4 nevnte RDBMSene kan brukes til &aring; gjennomf&oslash;re
eksemplene og oppgavene i denne boken. </span></strong><strong><span style="font-weight: normal">B&aring;de
MySQL og MariaDB kan brukes</span></strong><strong><span style="font-weight: normal">.
</span></strong><strong><span style="font-weight: normal">Hvis du
velger &aring; bruke MariaDB, </span></strong><strong><span style="font-weight: normal">kan
du fremdeles </span></strong><strong><span style="font-weight: normal">laste
ned </span></strong><strong><b>MySQL Workbench</b></strong><strong><span style="font-weight: normal">
fra Oracle, og kobler denne til MariaDB-installasjonen din. MySQL
Workbench fungerer stort sett like bra for begge databasene, </span></strong><strong><span style="font-weight: normal">men
</span></strong><strong><span style="font-weight: normal">har ikke
like god st&oslash;tte </span></strong><strong><span style="font-weight: normal">for
MariaDB </span></strong><strong><span style="font-weight: normal">n&aring;r
det gjelder enkelte funksjoner, som for eksempel</span></strong><strong><span style="font-weight: normal">
&laquo;intellisense&raquo; (dvs. at du f&aring;r forslag til
utfylling av feltnavn, funksjoner osv)</span></strong><strong><span style="font-weight: normal">.</span></strong></p>
<h2 class="western"><a name="__RefHeading___Toc6463_841703319"></a><strong><font color="#1b75bc">&#61609;</font></strong>
<span style="font-weight: normal">N</span><span style="font-weight: normal">ormalisering</span></h2>
<p class="western"><b>Normalisering (av databaser)</b> er en teknikk
for &aring; designe tabeller i relasjonsdatabaser slik at man
forhindrer dobbeltlagring av informasjon og minimerer kilder til
feil. Hvis samme informasjon lagres p&aring; flere ulike steder i en
tabell, risikerer man at en endring f&oslash;rer til at databasen
blir inkonsistent n&aring;r noe endres. Hvis for eksempel en persons
adresse er lagret p&aring; flere ulike steder i tabellen og adressen
endres kun p&aring; ett av stedene kan man ikke lenger vite hvilken
adresse som er riktig. 
</p>
<p class="western">En database normaliseres ved &aring; designe den
slik at den tilfredsstiller kravene til et hierarki av normalformer
som bygger p&aring; hverandre. For at en database skal v&aelig;re
<i>normalisert p&aring; tredje normalform</i> (som ofte er det
anbefalte) m&aring; den ogs&aring; oppfylle kravene til f&oslash;rste
og andre normalform. H&oslash;yere <i>normaliseringsgrad</i> f&oslash;rer
vanligvis til flere tabeller i databasen, noe som kan gi redusert
ytelse (hastighet) fordi man m&aring; koble tabellene sammen igjen
med <i>Joins</i> eller <i>Undersp&oslash;rringer </i>for &aring;
finne sammensatt informasjon. Som vi skal se er det derfor ikke alle
typer databaser som egner seg til normalisering.</p>
<p class="western">Normalisering er basert p&aring; matematisk
relasjonsalgebra og beskriver forholdet mellom <i><b>enheter</b></i>
og enhetenes <i><b>attributter</b></i> eller egenskaper. En enhet
identifiseres gjennom en <i><b>identifikator</b></i>, som er en
attributt eller en kombinasjon av attributter som er unik for den
aktuelle enheten. En enhet kan f.eks. v&aelig;re en person, en vare,
et firma e.l. og attributtene er da egenskaper <span style="text-decoration: none">ved
disse, slik som fornavn, </span><span style="text-decoration: none">etternavn,
</span><span style="text-decoration: none">vekt, adresse,
organisasjonsnummer osv. </span><span style="text-decoration: none">Gjennom
&aring; normalisere en database organiserer vi enhetene og deres
attributter p&aring; en optimal m&aring;te ved at ulike typer enheter
skilles ut i ulike tabeller og en enhets egenskaper samles i &eacute;n
unik tabellrad.</span></p>
<p class="western">Nedenfor f&oslash;lger en kortfattet gjennomgang
av hva de ulike normalformene inneb&aelig;rer.</p>
<h3 class="western"><a name="__RefHeading___Toc6465_841703319"></a><a name="F.C3.B8rste_normalform"></a>
F&oslash;rste normalform (1NF)</h3>
<p class="western">En tabell oppfyller f&oslash;rste normalform hvis
<strong>alle kolonner i </strong><strong>tabellen</strong><strong> er
atom&aelig;re</strong>. Det vil si at vi splitter data opp i s&aring;
mange kolonner som det er naturlig &aring; dele opp data i. For
eksempel kan vi dele en persons fulle navn over to eller tre
kolonner: Fornavn, evt. Mellomnavn og Etternavn. 
</p>
<p class="western">Tabellen under bryter f&oslash;rste normalform
fordi verdiene ikke er atom&aelig;re;</p>
<table width="407" cellpadding="2" cellspacing="0">
	<col width="200"/>

	<col width="197"/>

	<tr>
		<th width="200" style="border-top: 1px solid #b2b2b2; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			navn</p>
		</th>
		<th width="197" style="border: 1px solid #b2b2b2; padding: 0.05cm"><p class="western">
			telefonnummer</p>
		</th>
	</tr>
	<tr>
		<td width="200" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			Ivar B&oslash;, Hilde Svanhjell</p>
		</td>
		<td width="197" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
			750 55 647</p>
		</td>
	</tr>
	<tr>
		<td width="200" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			Ole Iversen</p>
		</td>
		<td width="197" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
			750 13 113, 750 54 524</p>
		</td>
	</tr>
</table>
<p class="western"><br/>
Nedenfor er samme data normalisert p&aring;
f&oslash;rste normalform (1NF).</p>
<table width="406" cellpadding="2" cellspacing="0">
	<col width="99"/>

	<col width="96"/>

	<col width="198"/>

	<tr>
		<th width="99" style="border-top: 1px solid #b2b2b2; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			fornavn</p>
		</th>
		<th width="96" style="border-top: 1px solid #b2b2b2; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			etternavn</p>
		</th>
		<th width="198" style="border: 1px solid #b2b2b2; padding: 0.05cm"><p class="western">
			telefonnummer</p>
		</th>
	</tr>
	<tr>
		<td width="99" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			Ivar</p>
		</td>
		<td width="96" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			B&oslash;</p>
		</td>
		<td width="198" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
			750 55 647</p>
		</td>
	</tr>
	<tr>
		<td width="99" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			Hilde</p>
		</td>
		<td width="96" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			Svanhjell</p>
		</td>
		<td width="198" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
			750 55 647</p>
		</td>
	</tr>
	<tr>
		<td width="99" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			Ole</p>
		</td>
		<td width="96" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			Iversen</p>
		</td>
		<td width="198" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
			750 13 113</p>
		</td>
	</tr>
	<tr>
		<td width="99" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			Ole</p>
		</td>
		<td width="96" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			Iversen</p>
		</td>
		<td width="198" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
			750 54 524</p>
		</td>
	</tr>
</table>
<p class="western"><br/>
<br/>

</p>
<p class="western">Vi ser at Ivar B&oslash; og Hilde Svanhjell har
f&aring;tt hver sin rad selv om de har samme telefonnummer, og at Ole
Iversen har f&aring;tt to rader siden han har to telefonnumre. Vi har
ogs&aring; skilt fornavn og etternavn i to separate kolonner. Vi ser
ogs&aring; at vi har m&aring;ttet skrive navnet til Ole Iversen og
telefonnummeret 750 55 647 to ganger, s&aring; 1NF er ikke nok til &aring;
unng&aring; dobbeltlagring.</p>
<p class="western">Hver rad i den nederste av tabellene over er unik.
En <b>prim&aelig;rn&oslash;kkel</b> er et felt eller en kombinasjon
av felter i en tabell som alene eller tilsammen er unik for hver rad.
Det vil si at kombinasjonen av de tre feltene i tabellen kan
defineres som en prim&aelig;r-n&oslash;kkel for tabellen. Det er ogs&aring;
vanlig - og anbefalelsesverdig - &aring; legge til et eget felt med
for eksempel et l&oslash;penummer, og s&aring; definere dette feltet
som prim&aelig;r-n&oslash;kkel for tabellen.</p>
<h3 class="western" style="border-top: none; border-bottom: 1px solid #808080; border-left: none; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0cm; padding-right: 0cm"><a name="__RefHeading___Toc6467_841703319"></a>
Andre normalform (2NF)</h3>
<p class="western">For at en relasjon skal v&aelig;re p&aring; andre
normalform m&aring; den oppfylle kravene til f&oslash;rste
normalform. I tillegg skal <strong>alle </strong><strong>felt som
ikke er definert som n&oslash;kler</strong><strong> v&aelig;re
avhengige av hele prim&aelig;r-n&oslash;kkelen</strong>.</p>
<p class="western">Derfor skal alle felt som ikke er n&oslash;kler
v&aelig;re avhengig av <i><b>hele</b></i> prim&aelig;rn&oslash;kkelen.
Eksempler p&aring; prim&aelig;rn&oslash;kler er Personnummer i en
tabell med personer, organisasjonsnummer i en tabell med 
organisasjoner, kombinasjon av et dato-felt og en ansatt-id for en
tabell med daglige arbeidsplaner etc. At et felt er avhengig av en
prim&aelig;rn&oslash;kkel vil si at det er knyttet opp til denne,
slik for eksempel feltene fornavn, etternavn, epost, telefon osv. er
knyttet til ett og bare ett personnummer. Putter vi telefonnummeret
til Per p&aring; samme rad som personnummeret til P&aring;l, bryter
vi 2NF (dersom personnummeret er prim&aelig;rn&oslash;kkel i
tabellen).      
</p>
<h3 class="western"><a name="__RefHeading___Toc6469_841703319"></a><a name="Tredje_normalform_.283NF.29"></a>
Tredje normalform (3NF)</h3>
<p class="western">For at en relasjon skal v&aelig;re p&aring; tredje
normalform m&aring; den oppfylle kravene til f&oslash;rste og andre
normalform. I tillegg skal <strong>alle kolonner som ikke er en del
av prim&aelig;rn&oslash;kkelen </strong><strong>v&aelig;re</strong><strong>
gjensidig uavhengige </strong><strong>av hverandre</strong><strong>.</strong></p>
<p class="western"><strong><span style="font-weight: normal">At
felter som ikke er en del av prim&aelig;rn&oslash;kkelen er
uavhengige av hverandre betyr i praksis at man skal kunne bytte epost
uten samtidig &aring; m&aring;tte bytte telefonnummer, at et firma
kan bytte adresse uten &aring; m&aring;tte bytte daglig leder osv.,
gitt at epost, telefonnummer, adresse og daglig leder er kolonner som
ikke er en del av prim&aelig;r</span></strong><strong><span style="font-weight: normal">n</span></strong><strong><span style="font-weight: normal">&oslash;kkelen
i de tabellene de opptrer i.</span></strong></p>
<h3 class="western"><a name="__RefHeading___Toc6471_841703319"></a><a name="Boyce-Codd_normalform_.28BCNF.29"></a>
Boyce-Codd normalform (BCNF)</h3>
<p class="western">Denne denne normalformen  er oppkalt etter Edgar
Boyce og Raymond Codd. En relasjon er p&aring; Boyce-Codd normalform
hvis alle attributter som er en del av en n&oslash;kkel, ikke er
avhengig av andre n&oslash;kler. Vanligvis vil relasjoner som er p&aring;
tredje normalform ogs&aring; oppfylle kravene til BCNF, men BCNF er
litt strengere enn 3NF, hvor n&oslash;kler i prinsippet kan v&aelig;re
avhengige av andre n&oslash;kler. 
</p>
<h3 class="western"><a name="__RefHeading___Toc16110_604779659"></a>Normalformene
forklart med &eacute;n setning</h3>
<p class="western">Med utgangspunkt i eden som avsverges i
amerikanske rettssaler - to tell the truth, the whole truth and
nothing but the truth &ndash; har smarte hoder kommet opp med denne
setningen for &aring; forklare de tre f&oslash;rste normalformene:</p>
<ul>
	<li><p class="western"><b>Alle felt som ikke er definert som n&oslash;kler
	skal v&aelig;re avhengige av prim&aelig;r-n&oslash;kkelen (1NF),
	hele prim&aelig;r-n&oslash;kkelen (2NF) og ikke noe annet enn
	prim&aelig;r-n&oslash;kkelen (3NF) </b>
	</p>
</ul>
<h3 class="western"><a name="__RefHeading___Toc15453_3971551474"></a>Normalisering
forklart med et eksempel</h3>
<p class="western">Jeg har ovenfor fors&oslash;kt &aring; forklare
normalisering med et ikke-matematisk spr&aring;k. Det finnes ogs&aring;
presise matematiske formler for hver normalform (forklart for
eksempel p&aring; Wikipedia). Men for mange vil antagelig et eksempel
v&aelig;re mer oppklarende: 
</p>
<p class="western"><b>Eksempel: </b>Vi skal bestille en pizza. Det
finnes tre ulike typer toppinger vi kan velge til pizzaene p&aring;
denne restauranten: 
</p>
<ul>
	<li><p class="western" style="margin-bottom: 0cm">type ost</p>
	<li><p class="western" style="margin-bottom: 0cm">type kj&oslash;tt 
	</p>
	<li><p class="western">type gr&oslash;nnsak</p>
</ul>
<p class="western">S&aring; vi bestiller 2 pizzaer og velger f&oslash;lgende
toppinger:</p>
<pre class="western"><code class="western">Pizza    Topping     Topping</code><code class="western">t</code><code class="western">ype</code>
<code class="western">-------- ----------  -------------</code>
<code class="western">1        mozzarella  </code><code class="western">ost</code>
<code class="western">1        pepperoni   </code><code class="western">kj&oslash;tt</code>
<code class="western">1        olive</code><code class="western">n</code><code class="western">      </code><code class="western">gr&oslash;nnsak</code>

<code class="western">2        mozzarella  </code><code class="western">kj&oslash;tt</code>
<code class="western">2        </code><code class="western">p&oslash;lse</code><code class="western">   	    </code><code class="western">ost</code>
<code class="western">2        </code><code class="western">paprika</code><code class="western">     </code><code class="western">gr&oslash;nnsak</code></pre><p class="western">
Men vent litt - mozzarella kan ikke v&aelig;re b&aring;de ost og
kj&oslash;tt! Og p&oslash;lse er ikke en ost!</p>
<p class="western">For &aring; unng&aring; denne typen feil, for &aring;
sikre at mozzarella alltid vil v&aelig;re topping av typen ost, kan
vi bruke en egen tabell for dette, slik at vi skriver det ned kun p&aring;
ett sted:</p>
<pre class="western"><code class="western">Pizza    Topping</code>
<code class="western">-------- ----------</code>
<code class="western">1        mozzarella</code>
<code class="western">1        pepperoni</code>
<code class="western">1        olive</code><code class="western">n</code>

<code class="western">2        mozzarella </code>
<code class="western">2        </code><code class="western">p&oslash;lse</code>
<code class="western">2        </code><code class="western">paprika</code>

<code class="western">Topping     Topping Type</code>
<code class="western">----------  -------------</code>
<code class="western">mozzarella  </code><code class="western">ost</code>
<code class="western">pepperoni   </code><code class="western">kj&oslash;tt</code>
<code class="western">olive</code><code class="western">n</code><code class="western">      </code><code class="western"><span style="font-weight: normal">gr&oslash;nnsak</span></code>
<code class="western">p&oslash;lse  </code><code class="western">     </code><code class="western">kj&oslash;tt</code>
<code class="western">paprika</code><code class="western">     </code><code class="western">gr&oslash;nnsak</code></pre><p class="western">
Ved &aring; skille ut topping-typen i en egen tabell, kan vi sl&aring;
opp i denne tabellen og se der hvilken type topping mozzarella eller
paprika er, og f&aring; det riktig hver gang. Vi har nomalisert p&aring;
3NF (og ogs&aring; p&aring; BCNF).  
</p>
<h2 class="western" style="font-weight: normal"><a name="__RefHeading___Toc6473_841703319"></a>
<strong><font color="#1b75bc">&#61609;</font></strong>
Denormalisering</h2>
<p class="western">Databaser som brukes til <b>online transaction
processing</b> (OLTP) er typisk mer normalisert enn de som brukes til
<b>online analytical processing</b> (OLAP). OLTP-applikasjoner har et
stort antall mindre transaksjoner - slik som oppdatering av salgsdata
i en kasse p&aring; et supermarked. Det forventes at hver transaksjon
vil bli gjennomf&oslash;rt uten at databasen blir inkonsistent.</p>
<p class="western">Databaser som brukes til OLAP-operasjoner er f&oslash;rst
og fremst &quot;read mostly&quot;-databaser. OLAP-applikasjoner
trekker ofte ut historiske data som er samlet inn over en lang
tidsperiode. For en slik database kan &quot;denormaliserte&quot; data
lette arbeidet for applikasjoner innen business intelligence. 
</p>
<p class="western">Spesielt vil dimensjonelle tabeller organiserte i
stjerne-skjemaer ofte inneholde denormaliserte data. Slike data m&aring;
kontrolleres n&oslash;ye av ETL-prosesser (ETL: Extract, Transform,
Load). Et normalisert alternativ til stjerne-skjema er
sn&oslash;flak-skjema. I praksis bruker OLAP-databaser fremdeles ofte
denormaliserte skjemaer.</p>
<h2 class="western"><a name="__RefHeading___Toc6475_841703319"></a><strong><font color="#1b75bc">&#61609;</font></strong>
<span style="font-weight: normal">A</span><span style="font-weight: normal">CID</span></h2>
<p class="western"><strong>ACID (Atomicity, Consistency, Isolation,
Durability) </strong>er et sett av krav som sikrer at operasjoner p&aring;
databaser utf&oslash;res p&aring;litelig.</p>
<p class="western"><b>Atom&aelig;re operasjoner</b></p>
<p class="western">En operasjon p&aring; en database er <b>atom&aelig;r</b>
hvis DBMSen sikrer at hvis en del av operasjonen ikke utf&oslash;res
s&aring; utf&oslash;res heller ikke andre deler &ndash; alt eller
ingenting. Id&eacute;en er &aring; splitte opp en databaseoperasjon i
sine enkeltdeler, utf&oslash;re en del av gangen, og ha mulighet til
&aring; &laquo;g&aring; tilbake til start&raquo; (eller et fastsatt
stopp-punkt) dersom noe g&aring;r galt. Viktigheten av dette kan
enkelt illustreres med et eksempel fra en bank-transaksjon hvor
oppgaven er &aring; overf&oslash;re et 1000 kroner fra konto A til
konto B. Del 1 er &aring; ta pengene ut av konto A, dvs. senke
saldoen p&aring; konto A med kr. 1000. Del 2 er &aring; settes
bel&oslash;pet inn p&aring; konto B, dvs. &oslash;ke saldoen p&aring;
konto B med kr. 1000. N&aring;r begge delene er utf&oslash;rt er
transaksjonen gjennomf&oslash;rt, og transaksjonen avsluttes i SQL
med en <b>commit</b> Hvis noe derimot g&aring;r galt underveis,
f.eks. at linjen g&aring;r ned eller en server d&oslash;r etter del
1, slik at del 2 ikke kan utf&oslash;res, skal man kunne oppheve hele
transaksjonen, dvs. f&oslash;re pengene tilbake til konto A, og evt.
fors&oslash;ke p&aring; nytt senere. En slik tilbakef&oslash;ring
kalles i SQL for en <b>rollback. </b>
</p>
<p class="western"><b>Konsistens</b></p>
<p class="western">Databasen skal v&aelig;re <b>konsistent</b> b&aring;de
f&oslash;r en operasjon utf&oslash;res og etter at den er avsluttet
(men den kan v&aelig;re inkonsistent mens operasjoner utf&oslash;res).
I relasjonsdatabaser opprettes derfor <b>n&oslash;kler</b> som
inneholder regler som sikrer integriteten b&aring;de innenfor og
mellom tabeller. En <b>prim&aelig;rn&oslash;kkel</b> <span style="font-weight: normal">kan
for eksempel opprettes p&aring; et felt (eller en kombinasjon av
felt) i en tabell for &aring; sikre at feltet er unikt, siden to
rader ikke kan ha samme prim&aelig;rn&oslash;kkel-verdi. S&aring;
hvis for eksempel et felt som inneholder personnummer blir definert
som prim&aelig;rn&oslash;kkel, s&aring; sikrer vi at det ikke kan
finnes flere rader med samme personnummer. En rad inneholder mao
informasjon knyttet til en person, og det kan ikke finnes to rader
for samme person. Vi kan ogs&aring; opprette </span><b>fremmen&oslash;kler</b><span style="font-weight: normal">,
som er n&oslash;kler som</span><b> </b><span style="font-weight: normal">knyttes
til et felt i en tabell og refererer til et tilsvarende felt (som
regel prim&aelig;rn&oslash;kkelen) i en annen tabell. For eksempel
kan vi ha en tabell med ansatte og en annen tabell med avdelinger. I
tabellen over ansatte legger vi inn et felt sm heter </span><i><span style="font-weight: normal">avdelings_id</span></i><span style="font-weight: normal">
</span><span style="font-style: normal"><span style="font-weight: normal">som
vi definerer som en fremmen&oslash;kkel som refererer til
prim&aelig;rn&oslash;kkelen i tabellen over avdelinger. S&aring; n&aring;r
en ansatt har avdelings_id 5, kan vi sl&aring; opp i
avdelings-tabellen og se at avdelingen med prim&aelig;rn&oslash;kkel-verdi
5 er utviklingsavdelingen. Navnet til avdelingen ligger som et annet
felt i avdelings-tabellen, og hvis den skulle skifte navn, vil vi kun
gj&oslash;re det der, og alle aktuelle ansatte vil fremdeles v&aelig;re
knyttet til avdeling 5, som n&aring; har et nytt navn. Integriteten
mellom tabellene sikres ved at vi n&aring; kan lage en regel som gj&oslash;r
det ulovlig &aring; legge inn en ny ansatt i ansatte-tabellen med et
avdelingsnummer som ikke finnes i avdelings-tabellen. Og vi kan lage
en regel som sier at vi ikke f&aring;r lov til &aring; slette en
avdeling i avdelings-tabellen hvis det finnes ansatte i
ansatte-tabellen som er knyttet til dens avdelings_id. S&aring; vi
kan unng&aring; vanlige feilkilder som &aring; knytte en ansatt til
en avdeling som ikke finnes, eller slette en avdeling som har ansatte
knyttet til seg, og slik bevare integriteten i databasen.  </span></span>
</p>
<p class="western"><b>Isolasjon</b></p>
<p class="western"><span style="font-weight: normal">Moderne RDBMSer
er gjerne servere med mange samtidige brukere, og det er viktig &aring;
isolere disse fra hverandre slik at de ikke kan endre samme data
samtidig.  </span><b>Isolasjon</b> inneb&aelig;rer at operasjoner
ikke kan arbeide med data som er i en midlertidig endret tilstand p&aring;
grunn av at andre prosesser arbeider med dem. Dette er ikke noe
problem hvis systemet arbeider serielt &ndash; hvis det bare
behandler en og en operasjon. Men i praksis designes databasesystemer
for at mange prosesser skal kunne arbeide parallelt. Prinsippet om
serialiserbarhet inneb&aelig;rer at operasjoner skal utf&oslash;res
slik at det finnes en seriell utf&oslash;relse som gir samme
resultat. Rekkef&oslash;lgen av operasjonene kan ha stor betydning
for resultatet, men det skal ikke v&aelig;re slik at forskjellige
operasjoner blandes sammen og gir et helt uventet resultat.</p>
<p class="western"><b>Varighet</b> inneb&aelig;rer at resultatet av
utf&oslash;rte transaksjoner aldri kan forsvinne. Dette inneb&aelig;rer
at databasen skal takle ulike forventede og ikke-forventede
hendelser, som for eksempel systemkrasj eller fysiske feil.</p>
<p class="western"><br/>
<br/>

</p>
<ul>
	<p class="ressurs" align="center"><b>Eksterne ressurser</b></p>
	<li><p class="ressurs"><a href="http://troels.arvin.dk/db/rdbms/">Comparison
	of Different SQL Implementations</a> This comparison of various SQL
	implementations is intended to serve as a guide to those interested
	in porting SQL code between various RDBMS products, and includes
	comparisons between SQL:2008, PostgreSQL, DB2, MS SQL Server, MySQL,
	Oracle, and Informix.</p>
</ul>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc19551_1580825334"></a>
<font size="6" style="font-size: 24pt">Kapittel 2</font><br/>
DDL
<font size="6" style="font-size: 26pt">(Data Definition Language)</font>
<font size="5" style="font-size: 18pt">CREATE, ALTER, DROP, TRUNCATE,
COMMENT og RENAME </font>
</h1>
<p class="western">I dette kapitlet skal vi se p&aring; hvordan vi
lager en database med SQLs Data Definition Language (DDL) . Kapitlet
forutsetter at du har tilgang til en RDBMS. Se vedlegg 1 for hvordan
du installerer en av RDBMSene: Oracle Express, Microsoft SQL Server,
MySQL, MariaDB eller PostgreSQL.</p>
<p class="western">N&oslash;kkelordene CREATE, ALTER, DROP, TRUNCATE,
COMMENT og RENAME brukes for &aring; implementere DDL til &aring;
opprette, endre og slette databaser, tabeller og kolonner. 
</p>
<h2 class="western"><a name="__RefHeading___Toc20018_3710899157"></a>Datamodellering</h2>
<p class="western">F&oslash;r vi g&aring;r igang med &aring; opprette
en database kan det v&aelig;re nyttig med en enkel gjennomgang av
hvordan vi modellerer en database, dvs. designer en datamodell og
implementerer denne i kolonner og tabeller og regulerer forholdet
mellom disse slik at vi s&oslash;rger for best mulig dataintegritet
og minimerer dobbeltlagring og feilkilder. 
</p>
<h3 class="western"><a name="__RefHeading___Toc24594_3325804077"></a>Forholdet
mellom en enhet og dens egenskaper</h3>
<p class="western">Forholdet mellom en enhet og dens egenskaper
(attributter) er avgj&oslash;rende for hvordan vi strukturerer data i
tabeller. Dette forholdet kan inndeles i tre hovedkategorier:</p>
<ol>
	<li><p class="western">1 til 1  (1:1)</p>
	<li><p class="western">1 til mange (1:n)</p>
	<li><p class="western">mange til mange (n:m)</p>
</ol>
<h3 class="western"><a name="__RefHeading___Toc24596_3325804077"></a>1
til 1</h3>
<p class="western">Denne kategorien omfatter f.eks. forholdet mellom
en person og personens etternavn, siden en person kun kan ha ett
etternavn, eller en bedrift og dens organisasjonsnummer, en bok og
dens tittel osv. Her er et eksempel. Vi lager en tabell &laquo;kontakter&raquo;
som skal inneholde oversikt over kontaktene v&aring;re. Til &aring;
begynne med lager vi et felt som heter &laquo;kontakt_id&raquo; som
vil v&aelig;re et unikt l&oslash;penummer som vi kan bruke som
prim&aelig;rn&oslash;kkel (identifikator) for hver kontakt. S&aring;
legger vi inn feltene &laquo;fornavn&raquo;, &laquo;etternavn&raquo;
og feltet &laquo;epost&raquo; hvor vi vil legge inn kontaktens
epostadresse, og s&aring; evt. andre felt vi trenger.</p>
<p class="western">Hovedregelen er &aring; lage en kolonne for hver
egenskap som har et 1 til 1-forhold til enheten, f.eks. slik:</p>
<p class="western"><i>Tabell over kontakter med navn og epost </i><i>(kun
en epostadresse per kontakt)</i><i>:</i> 
</p>
<pre class="western">+------------+---------+-----------+---------------+ <br/>
| kontakt_id | fornavn | etternavn | epost         | <br/>
+------------+---------+-----------+---------------+ <br/>
| &nbsp;    1     | Jo &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Li &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| jo@li.no      | <br/>
| &nbsp;    2     | Lykke &nbsp;&nbsp;| Li &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| lykke@li.no   | <br/>
| &nbsp;    3     | Hans &nbsp;&nbsp;&nbsp;| Jensen &nbsp;&nbsp;&nbsp;| hans@jensen.no | <br/>
+------------+---------+-----------+---------------+</pre><h3 class="western">
<a name="__RefHeading___Toc24598_3325804077"></a>1 til mange</h3>
<p class="western">&laquo;1 til mange&raquo; - relasjoner har vi n&aring;r
en rad i tabell A kan lenkes til mange rader i tabell B, men en rad i
tabell B kun er lenket til &eacute;n rad i tabell A.</p>
<p class="western">Denne kategorien omfatter for eksempel forhold der
en medarbeider kun kan v&aelig;re ansatt i &eacute;n avdeling, mens
en avdeling kan ha mange ansatte, eller n&aring;r en bok kan ha mange
sider, men en side kan bare tilh&oslash;re &eacute;n bok, en
epostadresse kan bare tilh&oslash;re &eacute;n person, men en person
kan ha mange epostadresser osv. N&aring;r dette er tilfelle, vil vi
skille ut de det er mange av i en egen tabell &ndash; f.eks. en
tabell som heter ansatte, boksider, epostadresser etc.  
</p>
<p class="western">N&aring;r vi begynner &aring; legge inn data i
tabellen v&aring;r over kontakter, oppdager vi at vi har opp til fire
eller fem epostadresser for noen kontakter og kun en eller to for
andre. S&aring; vi lager en tabell til: &laquo;epost&raquo; med to
felt: &laquo;kontakt_id&raquo; og &laquo;epost&raquo;. Kombinasjonen
av disse to feltene vil v&aelig;re unik (vi trenger bare &aring;
registrere en epostadresse til en kontakt &eacute;n gang) og kan
brukes som prim&aelig;rn&oslash;kkel. Feltet &laquo;kontakt_id&raquo;
i epost-tabellen kan vi bruke til &aring; sl&aring; opp navnet p&aring;
kontakten epostadressen h&oslash;rer til. For &aring; sikre
integriteten mellom de to tabellene kan vi definere dette feltet som
en fremmedn&oslash;kkel som refererer til prim&aelig;rn&oslash;kkelen
&laquo;kontakt_id&raquo; i tabellen &laquo;kontakter&raquo;. Slik kan
vi regulere et &laquo;1 til mange&raquo;-forhold mellom kontakter og
epostadresser. 
</p>
<p class="western"><i>Eksempel som regulerer &laquo;1 til
mange&raquo;-forhold  mellom kontakter og epost ved &aring; bruke to
tabeller, en med kontakter (id, fornavn, etternavn) og en med eposter
(kontakt_id, epost), hvor eposter er knyttet til kontakter via
kontaktens id</i></p>
<pre class="western"><i><b>Tabell 1: kontakter</b></i>
<i>+----+---------+-----------+</i>
<i>| id | fornavn | etternavn |</i>
<i>+----+---------+-----------+</i>
<i>|  1 | Jo      | Li        |</i>
<i>|  2 | Lykke   | Li        |</i>
<i>|  3 | Hans    | Jensen    |</i>
<i>+----+---------+-----------+</i>
<i><b><br/>
Tabell 2: epost</b></i>
<i>+------+-----------------------+</i>
<i>| id   | epost                 |</i>
<i>+------+-----------------------+</i>
<i>|    1 | jo.li@gmail.com       |</i>
<i>|    1 | jo.li@hotmail.com     |</i>
<i>|    2 | lykke.li@hotmail.com  |</i>
<i>|    2 | lykke.li@online.no    |</i>
<i>|    3 | hans.jensen@gmail.com |</i>
<i>+------+-----------------------+</i></pre><p class="western">
Vi ser at vi n&aring; kan legge inn s&aring; mange epost-adresser vi
har behov for per kontakt. Feltet<i> id</i><span style="font-style: normal">
i tabellen</span><i> epost</i><span style="font-style: normal">
refererer til feltet</span><i> id</i><span style="font-style: normal">
i tabellen</span><i> kontakter</i><span style="font-style: normal">.
Vi kan formalisere denne referansen ved &aring; definere id-feltet i
epost-tabellen som en</span><i> fremmedn&oslash;kkel</i><i> </i><span style="font-style: normal">som
ref</span><span style="font-style: normal">e</span><span style="font-style: normal">rerer
til id-feltet i kontakter-tabellen, som vi kan definere som
</span><i>prim&aelig;rn&oslash;kkel</i><span style="font-style: normal">
for kontakter-tabellen. </span><span style="font-style: normal">Gj&oslash;r
vi dette, kan vi sette opp databasen slik at vi ikke f&aring;r lov
til &aring; legge inn en epost knyttet til en id som ikke finnes i
kontakter-tabellen. Tilsvarende f&aring;r vi heller ikke lov til &aring;
slette en kontakt hvis det er epost(er) knyttet til kontaktens id i
epost-tabellen </span><span style="font-style: normal">(</span><i>restrict</i><span style="font-style: normal">)</span><span style="font-style: normal">.
</span><span style="font-style: normal">Alternativt kan vi sette opp
databasen slik at hvis vi sletter en kontakt, vil alle eposter
knyttet til kontaktens id ogs&aring; bli slettet (</span><i>cascade).
</i><span style="font-style: normal">Det siste kan v&aelig;re en
praktisk m&aring;te &aring; rydde opp p&aring;, men det kan ogs&aring;
f&oslash;re til at vi sletter ting som ikke skulle v&aelig;rt
slettet. Derfor er </span><i>restrict </i><span style="font-style: normal">standard</span><span style="font-style: normal">-ins</span><span style="font-style: normal">t</span><span style="font-style: normal">illingen
for de fleste RDBMSer n&aring;r vi definerer fremmedn&oslash;kler.  </span>
</p>
<h3 class="western"><a name="__RefHeading___Toc24600_3325804077"></a>Mange
til mange</h3>
<p class="western">&laquo;Mange-til-mange&raquo;-forhold har vi n&aring;r
for eksempel en forfatter kan ha skrevet mange b&oslash;ker og en bok
kan ha mange forfattere. Hvis vi har en tabell med b&oslash;ker og en
tabell med forfattere, s&aring; vil vi da lage en tredje tabell som
regulerer forholdet mellom dem. Denne kan vi for eksempel kalle
&laquo;bok_forfatter&raquo; eller lignende, slik at vi allerede av
navnet skj&oslash;nner hva tabellen inneholder. Tabellen trenger kun
2 felt: &laquo;bok_id&raquo; og &laquo;forfatter_id&raquo;.
Kombinasjonen av disse vil v&aelig;re unik og kan defineres som
prim&aelig;rn&oslash;kkel for tabellen. Feltet &laquo;bok_id&raquo;
definerer vi som en fremmedn&oslash;kkel som refererer til
tilsvarende felt i bok-tabellen, og feltet &laquo;forfatter_id&raquo;
definerer vi som en fremmedn&oslash;kkel som refererer til
tilsvarende felt i forfatter-tabellen. <br/>
<br/>
La oss ta
utgangspunkt i eksempel-databasen ovenfor. Hvis vi oppdager at vi har
en epost-adresse som skal brukes av mer enn en kontakt, har vi et
&laquo;mange-til-mange&raquo;-forhold mellom kontakter og eposter. En
kontakt kan ha mange eposter og en epost kan brukes av mange
kontakter. Epost-adresser av typen  admin@domene.no, 
support@domene.no o.l.  kan illustrer dette. Slik kan vi modellere
databasen v&aring;r til &aring; ta hensyn til dette: 
</p>
<p class="western"><i>Eksempel p&aring; regulering av &laquo;mange
til mange&raquo;-forhold ved &aring; bruke tre tabeller, en for
kontakter, en for epost, og en som knytter kontakter til epost.</i></p>
<pre class="western"><i><b>Tabell 1: kontakter</b></i>
<i>+------------+---------+-----------+</i>
<i>| kontakt_id | fornavn | etternavn |</i>
<i>+------------+---------+-----------+</i>
<i>|  1         | Jo      | Li        |</i>
<i>|  2         | Lykke   | Li        |</i>
<i>|  3         | Hans    | Jensen    |</i>
<i>+------------+---------+-----------+</i>
<i><b><br/>
Tabell 2: epost</b></i>
<i>+------------+-----------------------+</i>
<i>| epost_id   | epost                 |</i>
<i>+------------+-----------------------+</i>
<i>|    1       | jo.li@gmail.com       |</i>
<i>|    2       | jo.li@hotmail.com     |</i>
<i>|    3       | lykke.li@hotmail.com  |</i>
<i>|    4       | lykke.li@online.no    |</i>
<i>|    5       | hans.jensen@gmail.com |</i>
<i>|    </i><i>6      </i><i> | </i><i>admin</i><i>@</i><font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt"><i>eksempel</i></font></font><i>.</i><i>no    </i><i> |</i>
<i>|    7       | support@<font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt">eksempel</font></font>.no   |</i>
<i>+------------+-----------------------+<br/>
<br/>
<b>Tabell 3: kontakt_epost</b> <br/>
+------------+----------+</i>
<i>| kontakt_id | epost_id |</i>
<i>+------------+----------+</i>
<i>|          1 |        1 |</i>
<i>|          1 |        2 |</i>
<i>|          2 |        3 |</i>
<i>|          2 |        4 |</i>
<i>|          3 |        5 |</i>
<i>|          1 |        6 |</i>
<i>|          3 |        6 |</i>
<i>|          2 |        7 |</i>
<i>+------------+----------+</i></pre><p class="western" style="font-style: normal">
Vi ser av tabell 3: kontakt_epost at kontakten med id 1 - Jo Li &ndash;
i tillegg til &aring; v&aelig;re knyttet til epost 1 og 2 ogs&aring;
er knyttet til epost 6 &ndash; admin@eksempel.no &ndash; og denne
eposten er ogs&aring; knyttet til kontakt 3  - Hans Jensen. 
</p>
<p class="western" style="font-style: normal"><br/>
Vi kan definere
feltet <i>kontakt_id</i> som en fremmedn&oslash;kkel som referer til
feltet <i>id</i> i tabellen <i>kontakter</i>, og feltet <i>epost_id</i>
som en fremmedn&oslash;kkel som refererer til feltet <i>id</i> i
tabellen <i>epost. </i>Det hjelper oss &aring; bevare integriteten
mellom de tre tabellene.</p>
<h3 class="western"><a name="__RefHeading___Toc24602_3325804077"></a>Eksempel
p&aring; modellering av en enkel database</h3>
<p class="western">Som et enkelt eksempel skal vi modellere en enkel
database for lagring av data for et konsulentfirma. Databasen skal
vise hvilken konsulent som jobber for hvilken kunde til ulike tider.
Enhetene vi skal modellere databasen for er m.a.o. personer
(konsulenter), organisasjoner (kunder) og tidsrom (oppdrag).
Attributtene til personene er bl.a. navn, timel&oslash;nn og
personaldata. Attributtene til organisasjonene er bl.a. firmanavn,
kontaktperson, adressedata o.l. Attributtene til tidsrom er bla.
fra_dato og til_dato. Personer kan identifiseres via personnummer og
organisasjoner gjennom organisasjonsnummer, og tidsrom kan
identifiseres ved &aring; kombinere identifikatorene for konsulent og
kunde med en fra-dato og en til-dato, men vi kan ogs&aring; lage
pseudo-identifikatorer som er unike for databasen og ikke knyttet til
reelle data, som f.eks. automatisk genererte l&oslash;penumre, noe
som ofte anbefales da det gir st&oslash;rre stabilitet i forhold til
endringer som ligger utenfor databasen, samtidig som man kanskje ikke
har anledning til &aring; lagre f.eks. personnummer. 
</p>
<p class="western">Vi starter med &aring; designe en tabell for
kunder (organisasjoner), en tabell for konsulenter (personer) og en
tabell for oppdrag (tidsrom). Her er et f&oslash;rste utkast til
hvordan disse tabellene kan se ut:</p>
<p class="western"><b>Tabellnavn:</b> konsulent<br/>
<b>Feltnavn:</b>
konsulent_id, fornavn, etternavn, telefon, epost, gate, postnummer,
poststed, notater, registrert, oppdatert, endret_av</p>
<p class="western"><b>Tabellnavn:</b> kunde<br/>
<b>Feltnavn:</b>
kunde_id, firmanavn,  telefon, epost, gate, postnummer, poststed,
notater, registrert, oppdatert, endret_av</p>
<p class="western"><b>Tabellnavn:</b> oppdrag<br/>
<b>Feltnavn:</b>
oppdrags_id, konsulent_id, kunde_id, fra_dato, til_dato, notater,
registrert, oppdatert, endret_av</p>
<p class="merk"><b>MERK:</b> De siste tre feltene i hver tabell, dvs
feltene: <i>registrert</i>, <i>oppdatert</i> og <i>endret_av</i> er
lagt til slik at vi kan logge bruken av databasen direkte i hver
tabell. Id&eacute;en er at feltet <i>registrert</i> automatisk lagrer
et tidsstempel hver gang vi setter inn en ny rad, mens vi legger inn
et tilsvarende tidsstempel manuelt i feltet <i>oppdatert</i> hver
gang vi gj&oslash;r en endring i tabellen. I feltet <i>endret_av</i>
kan vi sette inn brukernavnet p&aring; den personen som gj&oslash;r
endringene. (De ulike databaseh&aring;ndteringssystemene har
funksjoner som henter frem brukernavnet p&aring; den som er innlogget
i databasen). Slik for vi en enkel oversikt over hvem som har gjort
hva til hvilken tid.</p>
<p class="western">N&aring;r vi lager disse tre tabellene m&aring; vi
samtidig bestemme hvilken datatype hvert felt kan inneholde. For
eksempel m&aring; vi bestemme om feltet <i>telefon </i><span style="font-style: normal">skal
v&aelig;re av typen tall eller tekst. Siden vi ikke kommer til &aring;
 utf&oslash;re noen regneoperasjonen med dette feltet, kan det v&aelig;re
smart &aring; sette det til &aring; v&aelig;re et tekstfelt, f.eks.
av datatypen varchar (variable characters). Da kan vi ogs&aring;
legge inn retningsnummer med et plusstegn foran, f.eks. +47 for
Norge.</span></p>
<p class="western"><span style="font-style: normal">Hvordan vi
konkret oppretter databaser, tabeller</span><span style="font-style: normal">
</span><span style="font-style: normal">og felt forklares senere i
dette kapitlet. </span><font size="2" style="font-size: 10pt"><span style="font-style: normal">Det
er enkelt &aring;</span></font><span style="font-style: normal">
gj&oslash;re det med SQL, og det er ogs&aring; mulig &aring; gj&oslash;re
det via grafiske brukergrensesnitt, eller gjennom &aring; designe et
s&aring;kalt </span><span style="font-style: normal">ER-diagram eller
</span><span style="font-style: normal">EER-diagram.</span></p>
<p class="western" style="font-style: normal">ER diagram st&aring;r
for Entity Relationship Diagram, og EER st&aring;r for Enhanced
Entity Relationship Diagram. Den siste er en utvidet, mer detaljert
versjon av den f&oslash;rste. Begge diagrammene gir en grafisk
oversikt over tabellenes struktur samt over forholdet mellom dem &ndash;
f.eks. hvilke felt som er definert som n&oslash;kler i tabellene.
Avsnittet nedenfor viser et EER-diagram for kontakt-databasen i
eksemplet over.</p>
<h3 class="western"><a name="__RefHeading___Toc20020_3710899157"></a>EER</h3>
<p class="western">To do ...</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc20022_3710899157"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Opprette og endre databaser</h2>
<p class="western"><a name="yui_3_17_2_1_1474496781034_73"></a>Det er
enkelt &aring; opprette, endre og slette databaser med SQL, men det
krever (heldigvis) at man har tilgangsrettigheter til &aring; gj&oslash;re
dette.</p>
<p class="western">Syntaksen for &aring; opprette og slette databaser
er ganske lik for de ulike DBMSene, men de varierer n&aring;r det
kommer til &aring; angi tegnsett, sorteringsspr&aring;k og ikke minst
lagringsformat.</p>
<h3 class="western"><a name="__RefHeading___Toc295_487959650"></a>MySQL
/ MariaDB</h3>
<p class="western">Har du tilgangsrettigheter som gir deg adgang til
&aring; lage nye databaser, er det enkelt &aring; opprette dem med
SQL. Syntaksen for &aring; opprette en database med
default-instillinger er enkel:</p>
<pre class="western"><strong>CREATE DATABASE </strong><strong><span style="font-weight: normal">&lt;navn&gt;;</span></strong></pre><p class="western">
Eller slik:</p>
<pre class="western"><strong>CREATE SCHEMA </strong><strong><span style="font-weight: normal">&lt;navn&gt;;</span></strong></pre><p class="western">
Som vi ser er SCHEMA og DATABASE synonyme i MySQL og MariaDB.
Databasen vil f&aring; default tegnsett og spr&aring;k, men vi kan
spesifisere disse verdiene ved &aring; legge til noen parametre:</p>
<p class="western"><strong>CREATE DATABASE &lt;navn&gt; ENCODING
&lt;tegnsett&gt; COLLATE &quot;&lt;spr&aring;k&gt;&quot; </strong>
</p>
<p class="western">For eksempel kan vi lage en ny database, <b>konsul</b><strong>
</strong>med<strong> </strong>tegnsett <strong>utf8</strong> og
dansk-norsk sorterings-spr&aring;k, <strong>utf8_danish_ci, </strong>slik:</p>
<pre class="western"><strong><span style="font-weight: normal">CREATE DATABASE </span></strong><strong><span style="font-weight: normal">konsul</span></strong><strong><span style="font-weight: normal"> CHARACTER SET utf8 COLLATE utf8_danish_ci;</span></strong></pre><p class="western">
Vi kan sjekke at databasen ble riktig laget med kommandoen <strong>show
create database</strong>, slik:</p>
<pre class="western">show create database konsul;<br/>

<font size="1" style="font-size: 6pt">+----------+----------------------------------------------------------------------------------------+</font>
<font size="1" style="font-size: 6pt">| Database | Create Database                                                                        |</font>
<font size="1" style="font-size: 6pt">+----------+----------------------------------------------------------------------------------------+</font>
<font size="1" style="font-size: 6pt">| konsul   | CREATE DATABASE `konsul` /*!40100 DEFAULT CHARACTER SET utf8 COLLATE utf8_danish_ci */ |</font>
<font size="1" style="font-size: 6pt">+----------+----------------------------------------------------------------------------------------+</font>
<font size="1" style="font-size: 7pt">1 row in set (0.00 sec)</font></pre><p class="western">
For &aring; opprette en bruker kurs, med passord kurs123 ,som har
full tilgang til databasen, kan vi bruke f&oslash;lgende setning:</p>
<pre class="western"><strong><span style="font-weight: normal">GRANT ALL ON </span></strong><strong><span style="font-weight: normal">konsul</span></strong><strong><span style="font-weight: normal">.* TO 'kurs</span></strong><strong><b>'@'%'</b></strong><strong><span style="font-weight: normal"> identified by 'kurs123';</span></strong></pre><p class="merk">
<strong>MERK:</strong> Setningen over oppretter samtidig brukeren
<strong>kurs</strong><em> </em>og tildeler brukeren passordet
<strong>kurs123. </strong>Hvis brukeren finnes fra f&oslash;r,
sl&oslash;yfer vi bare <em>identified by 'kurs123'</em> i setningen.</p>
<p class="western">Vil vi begrense tilgangen slik at brukeren kurs
kun kan logge seg p&aring; fra maskinen MySQL/MariaDB er installert
p&aring;, kan vi erstatte %-tegnet (som angis innlogging fra alle
domener), til <strong>localhost, slik:</strong></p>
<pre class="western"><strong><span style="font-weight: normal">GRANT ALL ON </span></strong><strong><span style="font-weight: normal">konsul</span></strong><strong><span style="font-weight: normal">.* TO 'kurs'</span></strong><strong><b>@'localhost'</b></strong><strong><span style="font-weight: normal"> identified by 'kurs123';</span></strong></pre><p class="western">
Sjekk gjerne dokumentasjonen for MySQL/MariaDB for hvordan man
tildeler mer detaljerte tilgangsrettigheter til databaser og
tabeller.</p>
<h3 class="western"><a name="__RefHeading___Toc297_487959650"></a>PostgreSQL</h3>
<p class="western">For &aring; kunne opprette en ny database i
PostgreSQL m&aring; man v&aelig;re <strong>superbruker</strong> eller
ha tilgangs-rettigheten <strong>CREATEDB</strong>. Syntaksen for &aring;
opprette en database med default-instillinger er enkel:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong>CREATE DATABASE </strong><strong><span style="font-weight: normal">&lt;navn&gt;</span></strong><strong>;</strong></pre><p class="western">
Databasen vil f&aring; default tegnsett (mest sannsynlig <em>utf8</em>),&nbsp;og
spr&aring;k og eier av databasen vil v&aelig;re den brukeren som
oppretter den. Vil man opprette en database for en bruker som ikke
finnes, m&aring; brukeren opprettes f&oslash;rst. Det kan man gj&oslash;re
med denne setningen:</p>
<pre class="western"><b>CREATE USER</b> &lt;brukernavn&gt; <b>WITH PASSWORD</b> '&lt;passord&gt;'; </pre><p class="western">
Vi kan spesifisere disse verdiene ved &aring; legge til noen
parametre:</p>
<p class="western"><strong>CREATE DATABASE &lt;navn&gt; WITH OWNER
&lt;brukernavn&gt; ENCODING &lt;tegnsett&gt; COLLATE &quot;&lt;spr&aring;k&gt;&quot;
TEMPLATE &lt;databasemal&gt;</strong></p>
<p class="western">For eksempel kan vi lage en ny database, <b>konsul</b><strong>,
</strong>med eier <strong>kurs, </strong>tegnsett <strong>utf8</strong>
og norsk sorterings-spr&aring;k, <strong>nb_NO.utf8, </strong>slik:</p>
<pre class="western"><strong><b>CREATE DATABASE</b></strong><strong><span style="font-weight: normal"> </span></strong><strong><span style="font-weight: normal">konsul</span></strong><strong><span style="font-weight: normal"> </span></strong><strong><b>WITH OWNER</b></strong><strong><span style="font-weight: normal"> kurs ENCODING utf8 LC_COLLATE &quot;nb_NO.utf8&quot; TEMPLATE template0;</span></strong></pre><p class="merk">
<strong>MERK: </strong>Siden<strong> nb_NO.utf8 </strong>ikke er
default for standard-malen for nye databaser: <strong>template1</strong>,
m&aring; vi enten lage en nye mal, eller bruke <strong>template0.
</strong>Bruken av maler for databaser ligger utenfor dette kurset,
men hvis du skal bruke PostgreSQL mye, kan det v&aelig;re lurt &aring;
sjekke dokumentasjonen for hvordan maler brukes og lages. Sjekk ogs&aring;
gjerne dokumentasjonen for hvordan man tildeler mer detaljerte
tilgangsrettigheter til databaser og tabeller i PostgreSQL.</p>
<p class="western"><strong>NB!</strong> PostgreSQL skiller mellom
begrepene <strong>database</strong> og <strong>schema</strong>. I
PostgreSQL kan en database inneholde ett eller flere schema. Ved
opprettelsen av databasen lages det et schema ved navn <strong>public</strong>,
som brukes som default schema, men man kan opprette flere etter &oslash;nske
- f.eks. ett for utvikling, ett for test og ett for produksjon.
Schema opprettes med denne syntaksen:</p>
<pre class="western"><b>CREATE SCHEMA</b> &lt;navn&gt;</pre><p class="western">
Eksempler:</p>
<pre class="western"><strong>create schema prod;</strong>

<strong>create schema dev;</strong>

<strong>create schema test;</strong></pre><p class="western">
kan vise hvilke schema som finnes i databasen med kommandoen <strong>\dn&nbsp;
</strong><em>(describe namespace)</em>, slik:</p>
<pre class="western"><strong>\dn<br/>
</strong>
List of schemas
  Name&nbsp; |&nbsp; Owner&nbsp; &nbsp;
--------+----------
&nbsp;dev&nbsp;&nbsp;&nbsp; | kurs
&nbsp;prod&nbsp;&nbsp; | kurs
&nbsp;public | postgres
&nbsp;test&nbsp;&nbsp; | kurs
(4 rows)</pre><p class="western">
Bruk av schemas ligger utenfor dette kurset, men man refererer til en
tabell i et annet schema ved &aring; sette schema-navn og punktum f&oslash;r
tabellnavnet, f.eks. slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT * FROM dev.k</span></strong><strong><span style="font-weight: normal">onsul</span></strong><strong><span style="font-weight: normal">;</span></strong></pre><p class="merk">
<b>MERK:</b> Du kan bruke komandoen: <b>SHOW</b><b> search_path; </b><span style="font-weight: normal">
til &aring; se hvilket schema som er default for den sesjonen du er
inne i. Og du kan bruke kommandoen </span><b>SET</b><b> search_path
</b><b>TO</b><b> &lt;schema-navn&gt; </b><span style="font-weight: normal">til
&aring; sette et schema som </span><span style="font-weight: normal">default
(eller </span><span style="font-weight: normal">evt. </span><span style="font-weight: normal">flere
schemas ved &aring; sette dem etter hverandre med komma mellom). </span>
 
</p>
<h2 class="western"><a name="__RefHeading___Toc13963_140935937"></a><strong><font color="#1b75bc">&#61609;
</font></strong> Opprette Tabeller</h2>
<p class="western">SQL har syntaks for &aring; lage, endre og slette
tabeller. Setningen for &aring; lage en tabell er denne: 
</p>
<pre class="western"><strong><span style="font-weight: normal">CREATE TABLE &lt;navn&gt;  </span></strong><strong><span style="font-weight: normal">( </span></strong>
<strong><span style="font-weight: normal">&lt;kolonnenavn&gt; &lt;datatype&gt; [evt. andre tilleggskriterier </span></strong><strong><span style="font-weight: normal">for kolonnen</span></strong><strong><span style="font-weight: normal">],</span></strong>
<strong><span style="font-weight: normal">&lt;kolonnenavn&gt; &lt;datatype&gt; [evt. andre tilleggskriterier </span></strong><strong><span style="font-weight: normal">for kolonnen</span></strong><strong><span style="font-weight: normal">] ...</span></strong>
<strong><span style="font-weight: normal">) [evt. andre tilleggskriterier </span></strong><strong><span style="font-weight: normal">for tabellen</span></strong><strong><span style="font-weight: normal">]</span></strong><strong><span style="font-weight: normal">;  </span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Som vi ser inneholder
setningen en parentes hvor tabellens kolonner defineres. </span></strong><strong><span style="font-weight: normal">En
tabell m&aring; ha minst &eacute;n kolonne (felt). Har den flere
kolonner listes de etter hverandre med komma mellom (men ikke etter
den siste).</span></strong>Vi m&aring; spesifisere hver kolonne med
minimum to informasjoner: navn og data-type, og kan ogs&aring; legge
til andre parametre - som f.eks. en default-verdi, om feltet skal
akseptere NULL-verdier (tomme felt), om det skal v&aelig;re prim&aelig;r-
eller fremmed-n&oslash;kkel, begrensninger p&aring; hvilke verdier vi
kan legge inn i kolonnen, hvilket spr&aring;k kolonnens verdier skal
sorteres etter og evt. kommentarer vi vil legge inn om kolonnen. Hvis
vi ikke legger til valgfrie parametre, som f.eks. spr&aring;k, vil
kolonnen bli behandlet etter default-instillingene for disse
parametrene, som f.eks. default sorterings-spr&aring;k.</p>
<p class="western">Etter parentesen med kolonne-definisjonene kan vi
angi hvilket tegnsett og spr&aring;k tabellen skal h&aring;ndtere
data med, hvilket lagringsformat som skal brukes osv. 
</p>
<p class="western">La oss se noen eksempler p&aring; hvordan vi
oppretter tabeller med de ulike RDBMSene.   
</p>
<h3 class="western" style="line-height: 140%"><a name="__RefHeading___Toc301_487959650"></a>
MySQL / MariaDB</h3>
<p class="western" style="line-height: 140%">Her er setningen som
oppretter tabellen employees i v&aring;r test-database HR med MySQL /
MariaDB.</p>
<pre class="western"><strong> <span style="font-weight: normal">CREATE TABLE employees (</span></strong>
<strong>&nbsp; <span style="font-weight: normal">emp_no int(11) NOT NULL,</span></strong>
<strong>&nbsp; <span style="font-weight: normal">birth_date date NOT NULL,</span></strong>
<strong>&nbsp; <span style="font-weight: normal">first_name varchar(14) NOT NULL,</span></strong>
<strong>&nbsp; <span style="font-weight: normal">last_name varchar(16) NOT NULL,</span></strong>
<strong>&nbsp; <span style="font-weight: normal">gender enum('M','F') N</span></strong><strong><span style="font-weight: normal">OT</span></strong><strong><span style="font-weight: normal"> NULL,</span></strong>
<strong>&nbsp; <span style="font-weight: normal">hire_date date NOT NULL,</span></strong>
<strong>&nbsp; <span style="font-weight: normal">PRIMARY KEY (`emp_no`)</span></strong>
<strong><span style="font-weight: normal">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span></strong></pre><p class="western">
Vi kan se av setningen over at ansattnummeret (emp_no) er satt som
prim&aelig;rn&oslash;kkel, at lagringsformatet er <em>InnoDB</em> og
tegnsettet er <em>utf8</em>. Det st&aring;r NOT NULL etter alle
feltene,  det er med andre ord ingen valgfrie felt i denne tabellen -
alle feltene m&aring; gis en verdi.</p>
<p class="western">Legg merke til datatypen for kj&oslash;nn (gender)
som er <em>enum('M','F') &ndash;</em> datatypen <i><b>enum</b></i>
angir at det kun er mulig &aring; legge inn en av de verdiene som
st&aring;r inne i parentesen, i dette tilfelle bokstaven M eller
bokstaven F (Male eller Female). 
</p>
<h3 class="western"><a name="__RefHeading___Toc303_487959650"></a>PostgreSQL</h3>
<p class="western">Slik ser den samme setningen ut med <font size="2" style="font-size: 10pt">PostgreSQL.
</font><font size="2" style="font-size: 10pt">Vi oppretter f&oslash;rst
en egen datatype som vi f.eks. kan kalle </font><font size="2" style="font-size: 10pt"><i><b>gendertype</b></i></font><font size="2" style="font-size: 10pt">
, og s&aring; setter vi feltet gender til &aring; ha denne datatypen,
slik</font></p>
<pre class="western"><strong><span style="font-weight: normal">CREATE TYPE </span></strong><strong><span style="font-weight: normal">gendertype</span></strong><strong><span style="font-weight: normal"> AS ENUM ('</span></strong><strong><span style="font-weight: normal">M</span></strong><strong><span style="font-weight: normal">', '</span></strong><strong><span style="font-weight: normal">F</span></strong><strong><span style="font-weight: normal">');</span></strong>

<strong><span style="font-weight: normal">CREATE TABLE employees (</span></strong>
<strong><span style="font-weight: normal">	emp_no integer NOT NULL </span></strong><strong><span style="font-weight: normal">PRIMARY KEY</span></strong><strong><span style="font-weight: normal">,</span></strong>
<strong><span style="font-weight: normal">	birth_date </span></strong><strong><span style="font-weight: normal">timestamp</span></strong><strong><span style="font-weight: normal"> NOT NULL,</span></strong>
<strong><span style="font-weight: normal">	first_name </span></strong><strong><span style="font-weight: normal">varchar</span></strong><strong><span style="font-weight: normal">(14) NOT NULL,</span></strong>
<strong><span style="font-weight: normal">	last_name </span></strong><strong><span style="font-weight: normal">varchar</span></strong><strong><span style="font-weight: normal">(16) NOT NULL,</span></strong>
<strong><span style="font-weight: normal">	gender </span></strong><strong><span style="font-weight: normal">gendertype </span></strong><strong><span style="font-weight: normal">NOT NULL</span></strong><strong><span style="font-weight: normal">,     	</span></strong>
<strong><span style="font-weight: normal">	hire_date timestamp NOT NULL</span></strong>
<strong><span style="font-weight: normal">) TABLESPACE pg_default;</span></strong></pre><p class="western">
Vi ser at datatypene er forskjellige fra MySQL og at prim&aelig;rn&oslash;kkel
er satt til ansattnummeret (emp_no). TABLESPACE angir i hvilken mappe
/ disk datafilene skal lagres fysisk, og er satt til default for
databasen.</p>
<h3 class="western"><a name="__RefHeading___Toc23560_2548419322"></a>Oracle
og MS SQL Server</h3>
<p class="western">Slik opprettes tabellen <b>employees </b><span style="font-weight: normal">med
Oracle </span><span style="font-weight: normal">og MS SQL Server</span><span style="font-weight: normal">:</span></p>
<pre class="western"><a name="__DdeLink__23591_2548419322"></a><a name="__DdeLink__24020_2548419322"></a><a name="__DdeLink__24080_2548419322"></a><a name="__DdeLink__23621_2548419322"></a>  CREATE TABLE EMPLOYEES 
   (EMP_NO INT PRIMARY KEY, 
	BIRTH_DATE DATE NOT NULL, 
	FIRST_NAME VARCHAR(255) NOT NULL, 
	LAST_NAME VARCHAR(255) NOT NULL, 
	GENDER CHAR(2) NOT NULL check(GENDER in ('M','F')),
	HIRE_DATE DATE NOT NULL
   );</pre><p class="merk">
<b>MERK:</b> Hverken Oracle eller MS SQL Server har datatypen ENUM,
men vi kan legge inn en <span style="font-style: normal"><b>CHECK
CONSTRAINT</b></span><i> </i><span style="font-style: normal">som
sjekker at feltet GENDER inneholder enten en M eller en F. </span><span style="font-style: normal">Gender
har en feltlengde p&aring; 2 bytes for &aring; ta h&oslash;yde for
utf8-tegn, som best&aring;r av 2 bytes hver. </span><span style="font-style: normal">Merk
ogs&aring; at selv med denne sjekken kan feltet fremdeles inneholde
NULL, dvs. sjekken aksepterer tomme felt. Vil vi at et felt skal v&aelig;re
obligatorisk, m&aring; vi ogs&aring; legge til NOT NULL selv om vi
har en check constraint.</span><span style="font-style: normal">  </span>
</p>
<h2 class="western"><a name="__RefHeading___Toc305_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Selv-&oslash;kende prim&aelig;rn&oslash;kler</h2>
<p class="western">En vanlig praksis er &aring; la kolonnen som skal
v&aelig;re prim&aelig;r-n&oslash;kkel v&aelig;re selv-&oslash;kende,
slik at den automatisk &oslash;ker med en verdi for hver ny rad som
settes inn. N&aring;r vi setter inn nye rader, angir vi ikke noen
verdi for prim&aelig;rn&oslash;kkelen, siden den lages automatisk av
systemet. En av fordelene med dette er at l&oslash;penummerne ikke
gjenbrukes av systemet. Slettes raden som har prim&aelig;rn&oslash;kkel
med verdi 5, vil ikke noen ny rad senere kunne f&aring; prim&aelig;rn&oslash;kkel
med verdi 5. S&aring; hvis f.eks. en ansatt med en id generert av
systemet slutter og slettes fra databasen, s&aring; vil ikke en ny
ansatt kunne f&aring; vedkommendes id, siden l&oslash;penummere ikke
gjenbrukes. Dermed unng&aring;r man mulige feil som kan oppst&aring;
ved at en ansatt f&aring;r tilgang til dokumenter, adgangskort e.l.
som er knyttet til en tidligere ansatts id.</p>
<p class="western">Det er litt ulike m&aring;ter &aring; lage
selv&oslash;kende prim&aelig;rn&oslash;kler p&aring; med de ulike
RDBMSene:</p>
<h3 class="western"><a name="__RefHeading___Toc13965_140935937"></a><strong><span style="font-weight: normal">MySQL
/ MariaDB</span></strong></h3>
<p class="western">Med MySQL og MariaDB lager vi en selv-&oslash;kende
prim&aelig;rn&oslash;kkel ved &aring; f&oslash;ye til: <strong>AUTO_INCREMENT</strong>
f&oslash;r eller etter PRIMARY KEY, f.eks. slik:</p>
<pre class="western">CREATE TABLE test (id int primary key <b>auto_increment</b>, notat text); </pre><p class="western">
Vi kan angi en startverdi for id-feltet ved &aring; sette
auto_increment=&lt;tall&gt; etter parentesen, f.eks. slik:</p>
<pre class="western">CREATE TABLE test (id int primary key <span style="font-weight: normal">auto_increment</span>, notat text) <b>auto_increment=1000</b>; </pre><p class="western">
Den f&oslash;rste raden vi setter inn i tabellen vil da f&aring; en
id med verdi 1000, neste rad en id med verdi 1001 osv.</p>
<h3 class="western"><a name="__RefHeading___Toc23946_604322462"></a>MS
SQL Server. 
</h3>
<p class="western">Med MS SQL Server lager vi en selv-&oslash;kende
prim&aelig;rn&oslash;kkel ved &aring; f&oslash;ye til: <strong>IDENTITY</strong>
f&oslash;r eller etter PRIMARY KEY, f.eks. slik:</p>
<pre class="western">CREATE TABLE test (id int primary key <b>IDENTITY</b>, notat text); </pre><p class="western">
Vi kan angi en startverdi for id-feltet ved &aring; sette <b>start
&lt;tall&gt;</b> etter IDENTITY, f.eks. slik:</p>
<pre class="western">CREATE TABLE test (id int primary key <b>IDENTITY </b><b>start 1000</b>, notat text); </pre><p class="western">
Den f&oslash;rste raden vi setter inn i tabellen vil da f&aring; en
id med verdi 1000, neste rad en id med verdi 1001 osv.</p>
<h3 class="western"><a name="__RefHeading___Toc13967_140935937"></a><strong><span style="font-weight: normal">PostgreSQL
</span></strong><strong><span style="font-weight: normal">og Oracle</span></strong></h3>
<p class="western">Med PostgreSQL angir vi at et felt skal v&aelig;re
selv-&oslash;kende ved &aring; legge til en av disse setningene f&oslash;r
eller etter PRIMARY KEY: 
</p>
<ul>
	<li><p class="western"><span style="font-weight: normal">GENERATED</span><b>
	</b><b>ALWAYS</b><b> </b><span style="font-weight: normal">AS
	IDENTITY</span></p>
	<li><p class="western"><strong><span style="font-weight: normal">GENERATED</span></strong><strong><b>
	BY DEFAULT </b></strong><strong><span style="font-weight: normal">AS
	IDENTITY</span></strong></p>
</ul>
<p class="western">Dette gir PostgreSQL eller Oracle beskjed om &aring;
lage en sekvens og bruke denne til &aring; &oslash;ke verdien med 1
for hver nye rad som settes inn.  Forskjellen p&aring; de to &ndash;
<i><b>always</b></i> eller <i><b>by default </b></i><span style="font-style: normal"><span style="font-weight: normal">-
ligger</span></span><i><span style="font-weight: normal"> </span></i><span style="font-style: normal"><span style="font-weight: normal">i
at den f&oslash;rste ikke tillater at du setter inn en verdi for
feltet </span></span><span style="font-style: normal"><span style="font-weight: normal">manuelt</span></span><span style="font-style: normal"><span style="font-weight: normal">,
mens den siste tillater at du overstyrer den automatiske
nummereringen og legger inn et egendefinert nummer. Her er et par
eksempler. </span></span><span style="font-style: normal"><span style="font-weight: normal">F&oslash;rst
ved &aring; bruke GENERATED </span></span><span style="font-style: normal"><b>BY
DEFAULT</b></span><span style="font-style: normal"><span style="font-weight: normal">
AS IDENTITY til prim&aelig;rn&oslash;kkel-feltet </span></span><span style="font-style: normal"><b>id</b></span><span style="font-style: normal"><span style="font-weight: normal">,
og s&aring; legge inn et par rader hvor vi ikke spesifiserer en verdi
for feltet id &ndash; og lar systemet lage l&oslash;penummere for
oss. Og s&aring; legger vi til en rad hvor vi manuelt gir raden en id
p&aring; 500:</span></span></p>
<pre class="western">CREATE TABLE test (id int <b>GENERATED BY DEFAULT AS </b><b>IDENTITY </b><span style="font-weight: normal">primary key</span>, notat varchar(255) ); 

INSERT INTO test (notat) VALUES ('Dette er notat 1');
INSERT INTO test (notat) VALUES ('Dette er notat 2');
INSERT INTO test (id, notat) VALUES (500,'Dette er notat 500');

SELECT * FROM test;

id &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notat &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
-----+-------------------- <br/>
&nbsp;&nbsp;1 | Dette er notat 1 <br/>
&nbsp;&nbsp;2 | Dette er notat 2 <br/>
500 | Dette er notat 500
</pre><p class="western">
Bruker vi GENERATED <b>ALWAYS</b> AS IDENTITY f&aring;r vi en
feilmelding n&aring;r vi fors&oslash;ker &aring; sette inn et notat
med en egendefinert id, slik vi ser i eksemplet under:</p>
<pre class="western">CREATE TABLE test (id int <b>GENERATED </b><b>ALWAYS</b><b> AS </b><b>IDENTITY </b><span style="font-weight: normal">primary key</span>, notat varchar(255)); 

INSERT INTO test (notat) VALUES ('Dette er notat 1');
INSERT INTO test (notat) VALUES ('Dette er notat 2');
INSERT INTO test (id, notat) VALUES (500,'Dette er notat 500');

<i>PostgreSQL:</i>
ERROR: &nbsp;cannot insert into column &quot;id&quot; <br/>
DETAIL: &nbsp;Column &quot;id&quot; is an identity column defined as GENERATED ALWAYS. <br/>
HINT: &nbsp;Use OVERRIDING SYSTEM VALUE to override. <br/>
Time: 0,360 ms <br/>

<i>Oracle:</i>
ERROR at line 1: <br/>
ORA-32795: cannot insert into a generated always identity column<br/>


SELECT * FROM test; <br/>

id | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notat &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
----+------------------ <br/>
&nbsp;1 | Dette er notat 1 <br/>
&nbsp;2 | Dette er notat 2 </pre><p class="merk">
<b>M</b><b>ERK:</b> Med tidligere versjoner av PostgreSQL (f&oslash;r
versjon 9.6) angir vi i stedet at datatypen til prim&aelig;rn&oslash;kkelen
skal v&aelig;re av typen <b>SERIAL</b><span style="font-weight: normal">
</span><span style="font-weight: normal">eller </span><b>BIGSERIAL</b><b>.
</b><span style="font-weight: normal">Dette er en mindre anvendelig
m&aring;te &aring; lage en selv-&oslash;kende prim&aelig;rn&oslash;kkel
p&aring; (bl.a. k</span><span style="font-weight: normal">an</span><span style="font-weight: normal">
det skape problemer ved end</span><span style="font-weight: normal">r</span><span style="font-weight: normal">ing
av eierskapet til en tabell) </span>
</p>
<p class="western"><strong><span style="font-weight: normal">Vi kan
angi en startverdi for id-feltet ved &aring; </span></strong><strong><span style="font-weight: normal">sette
inn START WITH &lt;tall&gt; i en parentes etter identity, f.eks slik:
</span></strong>
</p>
<pre class="western"><a name="__DdeLink__26495_4209060388"></a><strong><span style="font-weight: normal">CREATE TABLE test (id int GENERATED </span></strong><strong><span style="font-weight: normal">ALWAYS</span></strong><strong><span style="font-weight: normal"> AS </span></strong><strong><span style="font-weight: normal">IDENTITY </span></strong><strong><b>(START WITH 1000) </b></strong><strong><span style="font-weight: normal">primary key, notat varchar(255));</span></strong><strong><span style="font-weight: normal"> </span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Den f&oslash;rste raden vi
setter inn i tabellen vil da f&aring; en id med verdi 1000, neste rad
en id med verdi 1001 osv.</span></strong></p>
<h3 class="western"><a name="__RefHeading___Toc13969_140935937"></a><strong><span style="font-weight: normal">Oracle
</span></strong><strong><span style="font-weight: normal">f&oslash;r
versjon 12c</span></strong></h3>
<p class="western">Med Oracle <b>f&oslash;r versjon 12c</b> lager vi
f&oslash;rst en sekvens, og s&aring; bruker vi denne n&aring;r vi
setter inn nye rader.</p>
<pre class="western"><strong><span style="font-weight: normal">CREATE SEQUENCE &lt;name_of_sequence&gt;</span></strong>
<strong><span style="font-weight: normal">START WITH 1</span></strong>
<strong><span style="font-weight: normal">INCREMENT BY 1</span></strong>
<strong><span style="font-weight: normal">CACHE 100;</span></strong></pre><p class="western">
Setningen over lager en sekvens som starter med tallet 1 og &oslash;ker
med ett tall for hver innsetting. 100 tall lagres i minne (dette &oslash;ker
hastigheten ved innsetting av mange nye rader).</p>
<p class="western">Slik setter vi inn en ny rad med bruk av denne
sekvensen:</p>
<pre class="western"><strong><span style="font-weight: normal">INSERT INTO &lt;tabellnavn&gt; ( &lt;primary_key_column&gt;, &lt;&lt;other columns&gt;&gt; )</span></strong>
<strong><span style="font-weight: normal">VALUES ( &lt;name_of_sequence&gt;.nextval, &lt;&lt;other values&gt;&gt; );</span></strong></pre><h2 class="western">
<a name="__RefHeading___Toc23948_604322462"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Default-verdier</h2>
<p class="western">Vi kan ogs&aring; angi default-verdier for enkelte
kolonner n&aring;r vi oppretter en tabell. Dette gj&oslash;r vi ved &aring;
skrive  n&oslash;kkelordet DEFAULT etterfulgt av en verdi eller en
funksjon som returnerer en verdi, f.eks. slik:</p>
<pre class="western">CREATE TABLE test (<br/>
id int PRIMARY KEY,<br/>
antall int DEFAULT 1,<br/>
pris int DEFAULT 100,<br/>
registrert date DEFAULT now()<br/>
);</pre><p class="merk">
<b>MERK:</b> Funksjonen <b>now()</b> fungerer med MySQL/MariaDB og
PostgreSQL. Med Oracle kan vi bruke SYSDDATE istedenfor now() og med
MS SQL Server kan vi bruke en av funksjonene GETDATE() eller
SYSDATETIME() for &aring; hente frem dato og tid akkurat n&aring;.</p>
<h2 class="western"><a name="__RefHeading___Toc23950_604322462"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Tegnsett, spr&aring;k og lagringsformat</h2>
<p class="western">Etter parentesen, men f&oslash;r det avsluttende
semikolon, kan vi ogs&aring; angi egenskaper som gjelder for hele
tabellen, slik som tegnsett og default sorteringsspr&aring;k,
informasjon om partisjonering,  lagringsformat og lagringssted for
tabellen. <font size="2" style="font-size: 10pt">H</font><font size="2" style="font-size: 10pt">er
er noen eksempler</font> fra de ulike RDBMSene:</p>
<h3 class="western"><a name="__RefHeading___Toc26779_3154182490"></a>MySQL
/ MariaDB</h3>
<pre class="western">CREATE TABLE test (<br/>
id int PRIMARY KEY AUTO_INCREMENT,<br/>
notat text <br/>
) <b>ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_danish_ci</b>;</pre><h3 class="western">
<a name="__RefHeading___Toc26781_3154182490"></a>PostgreSQL</h3>
<pre class="western">CREATE TABLE test (<br/>
id int PRIMARY KEY <font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt">GENERATED BY DEFAULT AS IDENTITY</font></font>,<br/>
notat text COLLATE &quot;nb_NO&quot;)<br/>
) <b>WITH (fillfactor=70) TABLESPACE disk1;</b>  </pre><h3 class="western">
<a name="__RefHeading___Toc26783_3154182490"></a> MS SQL Server 
</h3>
<pre class="western">CREATE TABLE test (<br/>
id int PRIMARY KEY <font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt">IDENTITY</font></font>,<br/>
notat text)<br/>
) <code class="western"><b>WITH (DATA_COMPRESSION = ROW )</b></code><b>;</b>
  </pre><h3 class="western">
<a name="__RefHeading___Toc26785_3154182490"></a>Oracle 
</h3>
<pre class="western">CREATE TABLE test (<br/>
id int PRIMARY KEY GENERATED BY DEFAULT AS <font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt">IDENTITY</font></font>,<br/>
notat text)<br/>
) <code class="western"><b>TABLESPACE admin_tbs </b></code><b>STORAGE (INITIAL 50K)</b>;  </pre><h2 class="western">
<a name="__RefHeading___Toc307_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Endre eksisterende tabeller</h2>
<p class="western">Vi kan endre eksisterende tabeller med <strong>ALTER
TABLE. </strong>Det er som regel begrenset hva man f&aring;r lov til
&aring; endre,og alle endringer krever at du har tilgangsrettigheter
som inkluderer skriving til databasen.</p>
<p class="merk"><strong>MERK:</strong> Data kan bli slettet hvis man
f.eks. endrer data-typen for en kolonne til en datatype som ikke
klarer &aring; ta imot eksisterende innhold - f.eks. endrer en
kolonne med tekstinnhold til datatypen INT. Derfor anbefales det p&aring;
det sterkeste &aring; lage en kopi av tabellen (evt. bare med noen f&aring;
rader) og f&oslash;rst gj&oslash;re endringene p&aring; denne. Hvis
endringene g&aring;r bra p&aring; kopien, kan man kj&oslash;re samme
SQL-setning p&aring; den originale databasen.&nbsp; Slik kan du
enkelt lage en kopi av en tabell med 100 rader data:</p>
<pre class="western"><strong><span style="font-weight: normal">CREATE TABLE employees_copy AS </span></strong>
<strong><span style="font-weight: normal">SELECT * from employees limit 100;</span></strong></pre><h2 class="western">
<a name="__RefHeading___Toc309_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Legge til en kolonne</h2>
<p class="western">&Aring; legge til en kolonne er det minst farlige
vi kan gj&oslash;re n&aring;r vi skal endre en tabell. Du kan f.eks.
legge til et felt med epostaddresse slik:</p>
<pre class="western"><strong><span style="font-weight: normal">ALTER TABLE employees</span></strong>
<strong><span style="font-weight: normal">ADD email VARCHAR(255);</span></strong></pre><h3 class="western">
<a name="__RefHeading___Toc311_487959650"></a><strong><span style="font-weight: normal">MySQL
/ MariaDB</span></strong></h3>
<p class="western">Med MySQL / MariaDB kan du i tillegg spesifisere
om en nye kolonnen skal plasseres sist (default), f&oslash;rst eller
etter en annen kolonne, f.eks. slik:</p>
<pre class="western"><strong><span style="font-weight: normal">ALTER TABLE employees</span></strong>
<strong><span style="font-weight: normal">ADD email VARCHAR(255) after gender;</span></strong></pre><p class="western">
eller slik:</p>
<pre class="western"><strong><span style="font-weight: normal">ALTER TABLE employees</span></strong>
<strong><span style="font-weight: normal">ADD email VARCHAR(255) first;</span></strong></pre><h3 class="western">
<a name="__RefHeading___Toc313_487959650"></a><strong><span style="font-weight: normal">PostgreSQL</span></strong></h3>
<p class="western">PostgreSQL lagrer feltene i den rekkef&oslash;lgen
du spesifiserer n&aring;r du oppretter tabellen, og den kan ikke
endres i etterkant (i n&aring;v&aelig;rende versjon: 9.6). Men du kan
f.eks. lage et <strong>view</strong> basert p&aring; en
select-setning som setter feltene i den rekkef&oslash;lgen du &oslash;nsker.</p>
<p class="western">Er det viktig &aring; endre rekkef&oslash;lgen i
selve tabellen, m&aring; du ta en backup av data, slette tabellen,
opprette den p&aring; nytt med riktig kollonne-rekkef&oslash;lge og
s&aring; sette inn data igjen.</p>
<h3 class="western"><a name="__RefHeading___Toc26109_1526864018"></a>MS
SQL Server</h3>
<p class="western">Med SQL Server legger man til en kolonne med denne
syntaksen:</p>
<pre class="western">ALTER TABLE &lt;tabellnavn&gt; 
ADD &lt;kolonnenavn&gt; &lt;datatype&gt; [default-verdi, check constraint etc]</pre><p class="western">
Her er et enkelt eksempel:</p>
<pre class="western">ALTER TABLE employees ADD email NVARCHAR(50) check(email like <strong><span style="font-weight: normal">'%@%.%'</span></strong>);</pre><h2 class="western">
<a name="__RefHeading___Toc315_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Endre en kolonne</h2>
<h3 class="western"><a name="__RefHeading___Toc317_487959650"></a>MySQL
/ MariaDB</h3>
<p class="western">Vi kan endre kolonner p&aring; to m&aring;ter med
MySQL og MariaDB: enten med syntaksen:</p>
<pre class="western"><strong><span style="font-weight: normal">ALTER TABLE &lt;tabellnavn&gt; MODIFY COLUMN &lt;kolonnenavn&gt; &lt;komplett kolonne-spesifikasjon&gt;. </span></strong></pre><p class="western">
eller med syntaksen:</p>
<pre class="western"><strong><span style="font-weight: normal">ALTER TABLE &lt;tabellnavn&gt; CHANGE COLUMN &lt;kolonnenavn&gt; &lt;nytt kolonnenavn&gt; &lt;komplett kolonne-spesifikasjon&gt;. </span></strong></pre><p class="western">
De fleste endringer kan gj&oslash;res med MODIFY COLUMN, men CHANGE
COLUMN m&aring; brukes n&aring;r vi f.eks. skal endre navn p&aring;
kolonnen. Husk &aring; angi alle egenskapene til kolonnen, selv om du
bare vil endre noen av dem. Her er noen eksempler:</p>
<pre class="western"><strong>show create table employees;</strong>
<br/>
Create Table: CREATE TABLE `employees` (
&nbsp; `emp_no` int(11) NOT NULL,
&nbsp; `birth_date` date NOT NULL,
&nbsp; `first_name` varchar(14) NOT NULL,
&nbsp; `last_name` varchar(16) NOT NULL,
&nbsp; `gender` enum('M','F') NOT NULL,
&nbsp; `hire_date` date NOT NULL,
&nbsp; PRIMARY KEY (`emp_no`),
&nbsp; KEY `idx_lastname` (`last_name`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0,00 sec)<br/>
</pre><p class="western">
<strong>SHOW CREATE TABLE &lt;tabellnavn&gt;</strong> gir oss
kolonne-strukturen til tabellen. Som vi ser har feltene <strong>first_name</strong>
og <strong>last_name</strong> en &oslash;vre begrensning p&aring;
henholdsvis 14 og 16 tegn, noe som ikke er spesielt gunstig hvis vi
vil legge inn flere ansatte i tabellen. Vi kan endre datatypen for
disse to feltene med denne SQL-setningen:</p>
<pre class="western"><strong><span style="font-weight: normal">ALTER TABLE</span></strong><strong><span style="font-weight: normal"> employees </span></strong>
<strong><span style="font-weight: normal">MODIFY</span></strong><strong><span style="font-weight: normal"> first_name varchar(255) NOT NULL, </span></strong>
<strong><span style="font-weight: normal">MODIFY</span></strong><strong><span style="font-weight: normal"> last_name varchar(255) NOT NULL;</span></strong><strong><br/>
</strong>
Query OK, 0 rows affected (5,44 sec)
Records: 0&nbsp; Duplicates: 0&nbsp; Warnings: 0</pre><p class="western">
Vi ser at vi kan endre flere kolonner med samme SQL-setning, ved &aring;
sette komma mellom hver endring, og at vi m&aring; gjenta n&oslash;kkelordet
<em>modify</em> for hver kolonne. <br/>
Kj&oslash;rer vi en ny <em>show
create table, </em>ser vi at datatypen er endret.</p>
<pre class="western"><strong>show create table employees;</strong>
<br/>
Create Table: CREATE TABLE `employees` (
&nbsp; `emp_no` int(11) NOT NULL,
&nbsp; `birth_date` date NOT NULL,
&nbsp; `first_name` varchar(255) NOT NULL,
&nbsp; `last_name` varchar(255) NOT NULL,
&nbsp; `gender` enum('M','F') NOT NULL,
&nbsp; `hire_date` date NOT NULL,
&nbsp; PRIMARY KEY (`emp_no`),
&nbsp; KEY `idx_lastname` (`last_name`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1</pre><p class="merk">
<strong>MERK: </strong>Hadde vi ikke tatt med NOT  NULL i setningen
over, ville denne restriksjonen ha falt bort for disse to kolonnene.</p>
<h4 class="western"><a name="__RefHeading___Toc319_487959650"></a>Endre
navn p&aring; en kolonne</h4>
<p class="western">Vil du endre en kolonnes navn m&aring; du bruke
ALTER TABLE + CHANGE COLUMN, f.eks. slik:</p>
<pre class="western"><strong>alter table employees change column hire_date ansattdato date NOT NULL;</strong>
Query OK, 0 rows affected (0,02 sec)
Records: 0&nbsp; Duplicates: 0&nbsp; Warnings: 0</pre><p class="western">
Setningen over endre navnet fra <strong>hire_date</strong> til
<strong>ansattdato,</strong> uten &aring; endre noen andre egenskaper
ved kolonnen.&nbsp; Husk &aring; ta med nytt navn, data-type og andre
egenskaper ved kolonnen. Egenskaper du ikke spesifiserer (f.eks. NOT
NULL) blir fjernet .</p>
<h3 class="western"><a name="__RefHeading___Toc321_487959650"></a><strong><span style="font-weight: normal">PostgreSQL</span></strong></h3>
<p class="western">Vi kan endre datatype, navn osv. p&aring;
kolonnene i en PostgreSQL-tabell. For &aring; se strukturen p&aring;
f.eks. employees-tabellen i HR-databasen, kan vi bruke
terminalklienten (psql) og taste inn \d employees, slik:</p>
<pre class="western"><strong>hr=# \d employees;</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table &quot;public.employees&quot;
&nbsp;&nbsp; Column&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Modifiers 
------------+--------------------------------+-----------
&nbsp;emp_no&nbsp;&nbsp;&nbsp;&nbsp; | integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | not null
&nbsp;birth_date | timestamp(6) without time zone | not null
&nbsp;first_name | character varying(14)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | not null
&nbsp;last_name&nbsp; | character varying(16)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | not null
&nbsp;gender&nbsp;&nbsp;&nbsp;&nbsp; | character varying(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | not null
&nbsp;hire_date&nbsp; | timestamp(6) without time zone | not null</pre><p class="western">
Som vi ser har kolonnene <strong>first_name</strong> og <strong>last_name</strong><em>
</em>&oslash;vre<em> </em>begrensninger p&aring; 14 og 16 tegn. For &aring;
&oslash;ke antall mulige tegn i kolonnen, slik at vi kan legge inn
nye ansatte, kan vi bruke denne SQL-setningen:</p>
<pre class="western"><strong>hr=# ALTER TABLE employees ALTER COLUMN first_name TYPE varchar(255), ALTER COLUMN last_name TYPE varchar(255);</strong>
ALTER TABLE</pre><p class="merk">
<strong>MERK: </strong>I motsetning til MySQLs <strong>modify,</strong>
fjerner ikke ALTER COLUMN de egenskaper ved kolonnene vi ikke nevner,
men endrer bare de vi spesifiserer. (NOT NULL blir st&aring;ende).</p>
<p class="western">En ny <strong>\d</strong> <strong>employees</strong>
(d st&aring;r for describe) viser at endringene er utf&oslash;rt:</p>
<pre class="western"><strong>hr=# \d employees</strong> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table &quot;public.employees&quot;
&nbsp;&nbsp; Column&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Modifiers 
------------+--------------------------------+-----------
&nbsp;emp_no&nbsp;&nbsp;&nbsp;&nbsp; | integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | not null
&nbsp;birth_date | timestamp(6) without time zone | not null
&nbsp;first_name | character varying(255)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | not null
&nbsp;last_name&nbsp; | character varying(255)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | not null
&nbsp;gender&nbsp;&nbsp;&nbsp;&nbsp; | character varying(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | not null
&nbsp;hire_date&nbsp; | timestamp(6) without time zone | not null</pre><h4 class="western">
<a name="__RefHeading___Toc323_487959650"></a>Endre navn p&aring; en
kolonne</h4>
<p class="western">Vi kan endre navn p&aring; kolonnene i en tabell
ved &aring; bruke ALTER TABLE med RENAME COLUMN, f.eks. slik:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">ALTER TABLE employees </span></strong><strong><b>RENAME COLUMN</b></strong><strong><span style="font-weight: normal"> last_name TO etternavn;</span></strong></pre><h4 class="western">
<a name="__RefHeading___Toc325_487959650"></a>Endre begrensninger ved
en kolonne</h4>
<p class="western">Vi kan legge til en NOT NULL - begrensning slik:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">ALTER TABLE employees </span></strong><strong><b>ALTER COLUMN</b></strong><strong><span style="font-weight: normal"> first_name SET NOT NULL;</span></strong></pre><p class="western">
Og vi kan fjerne en NOT NULL - begrensning slik:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">ALTER TABLE employees ALTER COLUMN first_name </span></strong><strong><b>DROP NOT NULL</b></strong><strong><span style="font-weight: normal">;</span></strong></pre><h2 class="western">
<a name="__RefHeading___Toc327_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Slette en kolonne</h2>
<p class="western">&Aring; slette en kolonne er enkelt, men v&aelig;r
klar over at koonnen og alle dens data blir slettet umiddlebart n&aring;r
du kj&oslash;rer SQL-setningen, som f.eks.</p>
<pre class="western"><strong><span style="font-weight: normal">ALTER TABLE employees</span></strong>
<strong><span style="font-weight: normal">DROP COLUMN email; &nbsp;</span></strong></pre><h2 class="western">
<a name="__RefHeading___Toc329_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Slette hele tabeller</h2>
<p class="western">For &aring; slette en hel tabell, bruk <strong>drop
table &lt;tabellnavn&gt;</strong>, f.eks. slik:</p>
<pre class="western"><strong><span style="font-weight: normal">DROP TABLE employees_copy;</span></strong></pre><p class="merk">
<strong>MERK:</strong><strong> </strong>Vi kan t&oslash;mme en tabell
for innhold med TRUNCATE TABLE, men det sletter ikke selve tabellen,
eller endrer tabellstrukturen. DROP TABLE fjerner tabellen helt fra
databasen.</p>
<h2 class="western"><a name="__RefHeading___Toc331_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Opprette og fjerne begrensninger p&aring; tabell-kolonner</h2>
<p class="western"><a name="yui_3_17_2_1_1474497288539_73"></a>Vi kan
la DBMSen sjekke data som settes inn i en kolonne med ulike former
for begrensninger (CONSTRAINTS). Begrensninger brukes ogs&aring; til
&aring; angi at en kolonne skal v&aelig;re en prim&aelig;r-n&oslash;kkel
eller fremmed-n&oslash;kkel. Begrensninger kan legges til en kolonne
n&aring;r tabellen opprettes eller etter at tabellen er laget ved &aring;
endre tabellen med <strong>ALTER TABLE</strong>.</p>
<h2 class="western"><a name="__RefHeading___Toc333_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Legge til begrensninger n&aring;r en tabell lages</h2>
<h3 class="western"><a name="__RefHeading___Toc335_487959650"></a>Oracle
/ MySQL/ MariaDB / Microsoft SQL Server /  PostgreSQL :</h3>
<pre class="western"><strong><span style="font-weight: normal">CREATE TABLE firma (</span></strong>
<strong><span style="font-weight: normal">firma_id int </span></strong><strong><b>primary key</b></strong><strong><span style="font-weight: normal">, </span></strong>
<strong><span style="font-weight: normal">firmanavn varchar(255)</span></strong>
<strong><span style="font-weight: normal">);</span></strong></pre><p class="western">
Setningen over oppretter en enkel tabell med en prim&aelig;rn&oslash;kkel
og et tekstfelt for firmanavn. Prim&aelig;rn&oslash;kkel er en
begrensning p&aring; feltet <strong>firma_id</strong>, som bl.a.
inneb&aelig;rer at feltet m&aring; inneholde unike verdier (to
firmaer kan ikke ha samme firma_id).</p>
<pre class="western"><strong><span style="font-weight: normal">CREATE TABLE personer (</span></strong>
<strong><span style="font-weight: normal">person_id int NOT NULL PRIMARY KEY </span></strong><strong><b>CHECK (person_id &gt; 0)</b></strong><strong><span style="font-weight: normal">,</span></strong>
<strong><span style="font-weight: normal">etternavn varchar(255) NOT NULL,</span></strong>
<strong><span style="font-weight: normal">fornavn varchar(255),</span></strong>
<strong><span style="font-weight: normal">epost varchar(255),</span></strong>
<strong><span style="font-weight: normal">firma_id int </span></strong><strong><b>REFERENCES firma (firma_id)</b></strong>
<strong><span style="font-weight: normal">);</span></strong></pre><p class="western">
Setningen over setter inn tre begrensninger: En
<strong>prim&aelig;rn&oslash;kkel-begrensning,</strong> en
<strong>check-begrensning</strong> - begge p&aring; feltet <strong>person_id</strong>,
og en <strong>fremmedn&oslash;kkel-begrensning</strong> p&aring;
feltet <strong>firma_id</strong> som peker til feltet firma_id i
tabellen firma. Den siste begrensningen inneb&aelig;rer at alle
firma_id som legges inn i personer-tabellen ogs&aring; m&aring; v&aelig;re
registrert i firma-tabellen. Man kan mao ikke legge inn en referanse
til et firma som ikke finnes i firma-tabellen. Man kan heller ikke
slette et firma som har personer knyttet til seg f&oslash;r man har
slettet personene, eller endret deres firma_id til et annet firma
eller til NULL. Check-begrensningen gj&oslash;r at man ikke kan legge
inn et negativt tall som person_id.&nbsp;</p>
<p class="merk"><strong>MERK: </strong>MySQL og MariaDB <b>st&oslash;tte</b><b>t</b><b>
</b><b>opprinnelig</b> <strong>ikke </strong><em>check constraints.
</em><em><span style="font-style: normal"><span style="font-weight: normal">MariaDB
gj&oslash;r det fra vcersjon </span></span></em><em><a href="https://mariadb.com/kb/en/mariadb-1021-release-notes/"><span style="font-style: normal"><span style="font-weight: normal">10.2.1</span></span></a></em><em>
, </em><em><span style="font-style: normal"><span style="font-weight: normal">og
MySQL har forel&oslash;pig laget en &laquo;workaround&raquo; ved bruk
av &laquo;triggere&raquo; - </span></span></em><em><b> </b></em><em><span style="font-style: normal">s&aring;
sjekk gjerne dokumentasjonen for den versjonen du bruker </span></em><em><span style="font-style: normal">for
&aring; v&aelig;re sikker</span></em><em><span style="font-style: normal">.
</span></em>
</p>
<p class="merk"><em><span style="font-style: normal">V&aelig;r obs p&aring;
at n&aring;r check constraints ikke st&oslash;ttes f&aring;r du ingen
feilmelding hvis du legger dem inn, men de blir ignorert </span></em><em><span style="font-style: normal">av
RDBMSen n&aring;r SQL-setningene kj&oslash;res</span></em><em><span style="font-style: normal">.</span></em></p>
<h2 class="western"><a name="__RefHeading___Toc337_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Legge til begrensninger etter at en tabell er laget</h2>
<p class="western">Vi kan angi at en kolonne skal v&aelig;re
prim&aelig;rn&oslash;kkel, ogs&aring; etter at tabellen er laget. Det
gj&oslash;res slik:</p>
<h3 class="western"><a name="__RefHeading___Toc339_487959650"></a><strong><span style="font-weight: normal">PostgreSQL
/ MySQL / MariaDB / Oracle / </span></strong><strong><span style="font-weight: normal">MS
</span></strong><strong><span style="font-weight: normal">SQL Server</span></strong></h3>
<pre class="western"><strong><span style="font-weight: normal">ALTER TABLE personer</span></strong>
<strong><b>ADD CONSTRAINT PRIMARY KEY (person_id</b></strong><b>);&nbsp;</b></pre><p class="western">
Vi kan ogs&aring; angi at en kolonne skal v&aelig;re sekund&aelig;r-n&oslash;kkel
som henviser til en prim&aelig;rn&oslash;kkel i en annen tabell. Det
gj&oslash;res slik:</p>
<pre class="western"><strong><span style="font-weight: normal">ALTER TABLE personer</span></strong>
<strong><b>ADD CONSTRAINT </b></strong>
<strong><b>FOREIGN KEY (firma_id) REFERENCES firma (firma_id);</b></strong></pre><p class="western">
Vi kan i tillegg legge til sjekker for hvilke data som tillates &aring;
legge inn:</p>
<h3 class="western"><a name="__RefHeading___Toc341_487959650"></a>MS
SQL Server / Oracle / MariaDB / PostgreSQL</h3>
<pre class="western"><strong><span style="font-weight: normal">ALTER TABLE Personer</span></strong>
<strong><b>ADD CHECK (person_id &gt; 0)</b></strong></pre><p class="western">
For &aring; kunne gi et eget navn til en CHECK-constraint, eller for
&aring; definere en CHECK-constraint for mer enn &eacute;n kolonne,
brukes denne syntaksen:</p>
<h3 class="western"><a name="__RefHeading___Toc343_487959650"></a>SQL
Server / Oracle / MariaDB / PostgreSQL</h3>
<pre class="western"><strong><span style="font-weight: normal">ALTER TABLE Personer</span></strong>
<strong><b>ADD CONSTRAINT chk_person CHECK (person_id &gt; 0 AND epost like '%@%.%')</b></strong></pre><p class="western">
Setningen over setter inn en begrensning som sier at person_id m&aring;
v&aelig;re et positivt tall og at epost-feltet m&aring; inneholde en
kr&oslash;llalfa (@) etterfulgt av noe, et punktum og noe mer. Vi kan
teste dette, f.eks. i PostgreSQL, slik:</p>
<pre class="western"><strong><span style="font-weight: normal">insert into personer (person_id,etternavn,epost) values (2,'Pettersen','</span></strong><strong><b>ola.pettersen.com</b></strong><strong><span style="font-weight: normal">');</span></strong>

<b>ERROR:new row for relation &quot;personer&quot; violates check constraint &quot;chk_person&quot;</b>
DETAIL:Failing row contains (2, Pettersen, null, ola.pettersen.com, null). </pre><p class="western">
Innsettingen over feilet fordi det manglet en @ i epost-feltet.</p>
<h2 class="western"><a name="__RefHeading___Toc345_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Fjerne begrensninger</h2>
<h3 class="western"><a name="__RefHeading___Toc347_487959650"></a>SQL
Server / Oracle / PostgreSQL:</h3>
<p class="western">For &aring; slette en CHECK-constraint,
prim&aelig;rn&oslash;kkel eller fremmedn&oslash;kkel, bruk syntaksen:
</p>
<pre class="western">ALTER TABLE &lt;navn&gt; DROP CONSTRAINT &lt;navn&gt;;</pre><p class="western">
f.eks. slik:</p>
<pre class="western"><strong><span style="font-weight: normal">ALTER TABLE personer</span></strong>
<strong><span style="font-weight: normal">DROP CONSTRAINT personer_person_id_check;</span></strong></pre><p class="western">
Med PostgreSQL kan du finne ut hva begrensningene heter ved &aring;
kj&oslash;re kommandoen: <strong>\d &lt;tabellnavn&gt; </strong><strong><span style="font-weight: normal">i
terminalklienten</span></strong>, slik:</p>
<pre class="western"><strong><span style="font-weight: normal">\d personer<br/>
</span></strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table &quot;public.personer&quot;
&nbsp; Column&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Modifiers 
-----------+------------------------+-----------
&nbsp;person_id | integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | not null
&nbsp;etternavn | character varying(255) | not null
&nbsp;fornavn&nbsp;&nbsp; | character varying(255) | 
&nbsp;epost&nbsp;&nbsp;&nbsp;&nbsp; | character varying(255) | 
&nbsp;firma_id&nbsp; | integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 
Indexes:
&nbsp;&nbsp;&nbsp; &quot;personer_pkey&quot; PRIMARY KEY, btree (person_id)
<b>Check constraints:</b>
&nbsp;&nbsp;&nbsp; &quot;personer_person_id_check&quot; CHECK (person_id &gt; 0)
<b>Foreign-key constraints:</b>
&nbsp;&nbsp;&nbsp; &quot;personer_firma_id_fkey&quot; FOREIGN KEY (firma_id) REFERENCES firma(firma_id)</pre><h3 class="western">
<a name="__RefHeading___Toc349_487959650"></a>MySQL / MariaDB</h3>
<h4 class="western"><a name="__RefHeading___Toc351_487959650"></a>Fjerne
prim&aelig;r- og fremmedn&oslash;kler</h4>
<p class="western">Prim&aelig;rn&oslash;kler kan fjernes med denne
setningen:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">ALTER TABLE &lt;tabellnavn&gt; DROP PRIMARY KEY;</span></strong></pre><p class="merk">
<b>MERK:</b> Du f&aring;r ikke lov til &aring; slette en prim&aelig;rn&oslash;kkel
som er selv-&oslash;kende (AUTO_INCREMENT).</p>
<p class="western">Fremmedn&oslash;kler kan fjernes med denne
setningen:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">ALTER TABLE &lt;tabellnavn&gt; DROP FOREIGN KEY &lt;n&oslash;kkelnavn&gt;;</span></strong></pre><p class="western">
Navnet p&aring; fremmedn&oslash;klene kan vises med:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">SHOW CREATE TABLE &lt;tabellnavn&gt;</span></strong></pre><p class="western">
For eksempel slik:</p>
<pre class="western">show create table salaries \G

*************************** 1. row ***************************
       Table: salaries
Create Table: CREATE TABLE `salaries` (
  `emp_no` int(11) NOT NULL,
  `salary` int(11) NOT NULL,
  `from_date` date NOT NULL,
  `to_date` date NOT NULL,
  PRIMARY KEY (`emp_no`,`from_date`),
  KEY `emp_no` (`emp_no`),
  CONSTRAINT `salaries_ibfk_1` FOREIGN KEY (`emp_no`) REFERENCES `employees` (`emp_no`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1</pre><p class="western">
<br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<h2 class="western" style="page-break-before: always"><a name="__RefHeading___Toc10035_122421868"></a>
<strong><font color="#1b75bc">&#61609;</font></strong> Datasettet HR</h2>
<p class="western">Dette datasettet ble opprinnelig laget av  .....
og er en konstruert database med personaldata for en stor bedrift. Vi
har valgt dette datasettet som en test-database for de fleste
eksemplene i denne boken, bl.a. p&aring; grunn av st&oslash;rrelsen -
 det ligger f.eks. mer enn 2,8 millioner rader med l&oslash;nnsdata i
tabellen &laquo;salaries&raquo; for ca. 240 000 ansatte. Databasen er
ogs&aring; konstruert slik at den inneholder historiske data og b&aring;de
&eacute;n-til-mange-relasjoner  (1:n) og mange-til-mange-relasjoner 
(n:m).  
</p>
<p class="western"><img src="Introduksjon_til_SQL_html_2426a7c7834236f0.png" name="Bilde7" align="left" width="470" height="363" border="0"/>
<br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc18228_1557834486"></a>
<font size="6" style="font-size: 24pt">Kapittel 3</font><br/>
DML
<font size="6" style="font-size: 23pt">(Data Manipulation
Language)</font><br/>
<font size="5" style="font-size: 20pt">SELECT,
INSERT, UPDATE og DELETE</font></h1>
<h2 class="western"><a name="__RefHeading___Toc18230_1557834486"></a><strong><font color="#1b75bc">&#61609;</font></strong><strong>
</strong><strong><span style="font-weight: normal">Hente data med
SELECT</span></strong></h2>
<p class="western"><strong><span style="font-weight: normal">Alle
SQL-s&oslash;k starter med n&oslash;kkelordet </span></strong><strong>SELECT.
</strong> SQL har en rekke n&oslash;kkelord - og det er viktig at man
ikke bruker disse til f.eks. feltnavn i tabeller. En SQL-setning som
starter med <b>SELECT</b> gir alltid tilbake en <b>tabell</b><span style="font-weight: normal">,
med rader og kolonner (ogs&aring; kalt felt). Tabellen kan inneholde
kun &eacute;n rute, dvs, en rad og en kolonne, eller millioner av
rader og tusenvis av kolonner. Men det er alltid en tabell </span><span style="font-weight: normal">hvis
setningen starter med SELECT.</span><span style="font-weight: normal">
  </span>
</p>
<p class="western" style="line-height: 140%"><strong>SELECT</strong>
trenger minimum to tilleggsinformasjoner for &aring; kunne hente
data: 
</p>
<ul>
	<li><p class="western" style="margin-bottom: 0cm; line-height: 140%">
	Hva vil du hente, dvs. hvilke kolonner skal tabellen inneholde. 
	</p>
	<li><p class="western" style="line-height: 140%">Hvor vil du hente
	det fra, dvs. hvilke tabeller skal kolonnene hentes fra.</p>
</ul>
<p class="western">Som vi skal se kan vi i tillegg skrive inn flere
s&oslash;kekriterier i SELECT-setningen, som f.eks. filtrering av
data etter s&oslash;kem&oslash;nstre, gruppering og sortering av
data, antall rader vi vil hente osv. Rekkef&oslash;lgen p&aring;
elementene i en SELECT-setning m&aring; f&oslash;lge dette m&oslash;nsteret:</p>
<ul>
	<li><pre class="western"><code class="western"><b>SELECT</b></code><code class="western"> &lt;ett eller flere feltnavn og/eller uttrykk og funksjoner&gt;</code></pre>
	<li><pre class="western"><code class="western"><b>FROM</b></code><code class="western"> &lt;tabellnavn </code><code class="western">data skal hentes fra</code><code class="western">&gt;</code></pre>
	<li><pre class="western"><code class="western"><b>WHERE</b></code><code class="western"> &lt;en eller flere betingelser for filtrering av rader&gt;</code></pre>
	<li><pre class="western"><code class="western"><b>GROUP BY</b></code><code class="western"> &lt;ett eler flere felt &aring; gruppere p&aring;&gt; </code></pre>
	<li><pre class="western"><b>HAVING</b> &lt;en eller flere betingelser for &aring; filtrere ut grupper&gt;</pre>
	<li><pre class="western"><code class="western"><b>ORDER BY</b></code> &lt;et eller flere feltnavn resultatet skal sorteres etter&gt;</pre>
	<li><pre class="western"><b>LIMIT</b> &lt;antall rader som skal hentes&gt;  (gjelder for MySQL/MariaDB og PostgreSQL, men ikke for Oracle eller MS SQL Server)</pre>
</ul>
<p class="western">Vi skal starte med enkle s&oslash;k og bygge dem
opp til mer avanserte s&oslash;ke-setninger gjennom dette kapitlet.
Alle eksemplene er laget med test-databasen <b>employees</b><span style="font-weight: normal">,
</span><span style="font-weight: normal">en konstruert
personal-database </span><span style="font-weight: normal">som du kan
laste ned og installere hvis du vil f&oslash;lge eksemplene og
eksperimentere med egne s&oslash;k (se forrige kapittel for
informasjon om nedlasting, installasjon og kodeeksempler). 
Eksemplene er vist med terminalklienten til MySQL / MariaDB,
</span><span style="font-weight: normal">alternativt</span><span style="font-weight: normal">
med terminalklienten til PostgreSQL, Oracle Express eller </span><span style="font-weight: normal">Microsoft</span><span style="font-weight: normal">
SQL Server der hvor syntaksen for disse avviker fra MySQL/MariaDB.</span></p>
<h2 class="western"><a name="__RefHeading___Toc15455_3971551474"></a><strong><font color="#1b75bc">&#61609;</font></strong><strong>
</strong><strong><span style="font-weight: normal">Hente en enkelt
</span></strong><strong><span style="font-weight: normal">kolonne</span></strong><strong><span style="font-weight: normal">
fra en tabell</span></strong></h2>
<p class="western"><strong><span style="font-weight: normal">For &aring;
hente en enkelt kolonne fra en tabell, </span></strong><strong><span style="font-weight: normal">trenger
vi bare </span></strong><strong><span style="font-weight: normal">&aring;
skrive </span></strong><strong><b>SELECT </b></strong><strong><span style="font-weight: normal">etterfulgt
av</span></strong><strong><span style="font-weight: normal"> navnet
</span></strong><strong><span style="font-weight: normal">p&aring;
kolonnen</span></strong><strong><span style="font-weight: normal"> </span></strong><strong><span style="font-weight: normal">vi
vil hente </span></strong><strong><span style="font-weight: normal">etterfulgt
av n&oslash;kkelordet </span></strong><strong><b>FROM</b></strong><strong><span style="font-weight: normal">
og navnet p&aring; tabellen som inneholder kolonnen. Setningen
nedenfor henter alle radene i en enkelt kolonne ved navn </span></strong><em><b>dept</b></em><strong><i><b>_</b></i></strong><strong><i>name</i></strong><strong><span style="font-weight: normal">
fra tabellen </span></strong><em><b>departments</b></em><em><span style="font-weight: normal">.
</span></em><strong><span style="font-weight: normal">Dataene er
usorterte og ufiltrerte. </span></strong><strong><span style="font-weight: normal">Vi
skal se senere i kapitlet hvordan vi kan sortere og filtrere dem.</span></strong><strong><span style="font-weight: normal">
</span></strong>
</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT dept_name FROM departments;</span></strong>

<strong><span style="font-weight: normal">+--------------------+</span></strong>
<strong><span style="font-weight: normal">| dept_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">+--------------------+</span></strong>
<strong><span style="font-weight: normal">| Customer Service&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| Development&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| Finance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| Human Resources&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| Marketing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| Production&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| Quality Management |</span></strong>
<strong><span style="font-weight: normal">| Research&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| Sales&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">+--------------------+</span></strong></pre><p class="merk">
<strong>MERK: </strong><strong><span style="font-weight: normal">Tabellnavn
kan v&aelig;re &laquo;case sensitive&raquo;, dvs. at det skilles
mellom sm&aring; og store bokstaver i navnet. Om det er det eller
ikke kommer an p&aring; filsystemet til serveren data er lagret p&aring;.
En Linux-server skiller mellom sm&aring; og store bokstaver i
filnavn, mens en Windows-server ikke gj&oslash;r det. Og tabellnavnet
ender opp som en del av et filnavn </span></strong><strong><span style="font-weight: normal">der
DBMSen lagrer data </span></strong><strong><span style="font-weight: normal">p&aring;
serveren. </span></strong>
</p>
<h2 class="western"><a name="__RefHeading___Toc19082_961426616"></a><strong><font color="#1b75bc">&#61609;</font></strong><strong>
</strong>Hente flere kolonner / felt fra en tabell</h2>
<p class="western"><strong><span style="font-weight: normal">Skal du
hente flere kolonner, er det bare &aring; sette dem etter hverandre
med komma imellom, i den rekkef&oslash;lgen du vil ha dem i tabellen
du f&aring;r tilbake. Husk at du ikke skal ha komma etter den siste
kolonnen. S</span></strong><strong><span style="font-weight: normal">etningen
</span></strong><strong><span style="font-weight: normal">nedenfor
</span></strong><strong><span style="font-weight: normal">henter
</span></strong><strong><span style="font-weight: normal">f.eks. </span></strong><strong><span style="font-weight: normal">alle
radene i de tre kolonnene </span></strong><em><b>first_name</b></em><strong><span style="font-weight: normal">,
</span></strong><strong><i><b>last_name </b></i></strong><strong><span style="font-style: normal"><span style="font-weight: normal">og</span></span></strong><strong><span style="font-weight: normal">
</span></strong><strong><i><b>birth_date</b></i></strong><strong><span style="font-weight: normal">
fra tabellen </span></strong><em><b>employees</b></em><em><span style="font-weight: normal">.
</span></em><strong><span style="font-weight: normal">Dataene er
fremdeles usorterte, ufiltrerte og uformaterte. Vi skal se senere
hvordan vi f.eks. kan formatere en ny kolonne med fullt navn ved &aring;
sl&aring; sammen kolonnene first_name og last_name til &eacute;n
kolonne.</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT first_name, last_name, birth_date FROM employees;</span></strong>

<strong><span style="font-weight: normal">+------------+-----------+------------+</span></strong>
<strong><span style="font-weight: normal">| first_name | last_name | birth_date |</span></strong>
<strong><span style="font-weight: normal">+------------+-----------+------------+</span></strong>
<strong><span style="font-weight: normal">| Georgi&nbsp;&nbsp;&nbsp;&nbsp; | Facello&nbsp;&nbsp; | 1953-09-02 |</span></strong>
<strong><span style="font-weight: normal">| Bezalel&nbsp;&nbsp;&nbsp; | Simmel&nbsp;&nbsp;&nbsp; | 1964-06-02 |</span></strong>
<strong><span style="font-weight: normal">| Parto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Bamford&nbsp;&nbsp; | 1959-12-03 |</span></strong>
<strong><span style="font-weight: normal">| Chirstian&nbsp; | Koblick&nbsp;&nbsp; | 1954-05-01 |</span></strong>
<strong><span style="font-weight: normal">| Kyoichi&nbsp;&nbsp;&nbsp; | Maliniak&nbsp; | 1955-01-21 |</span></strong>
<strong><span style="font-weight: normal">| Anneke&nbsp;&nbsp;&nbsp;&nbsp; | Preusig&nbsp;&nbsp; | 1953-04-20 |</span></strong>
<strong><span style="font-weight: normal">| Tzvetan&nbsp;&nbsp;&nbsp; | Zielinski | 1957-05-23 |</span></strong>
<strong><span style="font-weight: normal">| Saniya&nbsp;&nbsp;&nbsp;&nbsp; | Kalloufi&nbsp; | 1958-02-19 |</span></strong>
<strong><span style="font-weight: normal">| Sumant&nbsp;&nbsp;&nbsp;&nbsp; | Peac&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1952-04-19 |</span></strong>
<strong><span style="font-weight: normal">| Duangkaew&nbsp; | Piveteau&nbsp; | 1963-06-01 |</span></strong>
<strong><span style="font-weight: normal">| ........ &nbsp; | ........&nbsp; |  ........  |</span></strong></pre><h2 class="western">
<a name="__RefHeading___Toc13937_140935937"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Hente alle kolonner fra en tabell</h2>
<p class="western">Du kan enkelt hente alle kolonnene fra en tabell
ved &aring; bruke jokertegnet <b>*</b><span style="font-weight: normal">.</span><b>
</b><span style="font-weight: normal">Setningen nedenfor henter alle
kolonnene og alle radene i tabellen </span><i><b>departments</b></i><span style="font-weight: normal">.</span><b>
</b><span style="font-weight: normal">Ved &aring; bruke</span><b> *
</b><span style="font-weight: normal">henter vi med andre ord </span><b>hele
tabellen</b><span style="font-weight: normal">. </span>
</p>
<p class="western"><span style="font-weight: normal">Du kan ogs&aring;
bruke </span><b>*</b><span style="font-weight: normal"> til &aring;
hente bare en eller noen f&aring; rader hvis du vil vite navnet p&aring;
de ulike kolonnene (se hvordan du begrenser antall rader senere i
kapittelet).</span></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT * FROM departments;</span></strong>

<strong><span style="font-weight: normal">+---------+--------------------+</span></strong>
<strong><span style="font-weight: normal">| dept_no | dept_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">+---------+--------------------+</span></strong>
<strong><span style="font-weight: normal">| d009&nbsp;&nbsp;&nbsp; | Customer Service&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| d005&nbsp;&nbsp;&nbsp; | Development&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| d002&nbsp;&nbsp;&nbsp; | Finance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| d003&nbsp;&nbsp;&nbsp; | Human Resources&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| d001&nbsp;&nbsp;&nbsp; | Marketing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| d004&nbsp;&nbsp;&nbsp; | Production&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| d006&nbsp;&nbsp;&nbsp; | Quality Management |</span></strong>
<strong><span style="font-weight: normal">| d008&nbsp;&nbsp;&nbsp; | Research&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| d007&nbsp;&nbsp;&nbsp; | Sales&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">+---------+--------------------+</span></strong></pre><p class="merk">
<strong>MERK: </strong><strong><span style="font-weight: normal">D</span></strong>et
er enkelt &aring; bruke * istedenfor &aring; spesifisere hver enkelt
kolonne du trenger, men s&oslash;ket vil g&aring; raskere hvis du
spesifiserer kun de kolonnene du trenger. Du b&oslash;r ogs&aring;
v&aelig;re forsiktig med bruk av * med store tabeller, siden hele
tabellen hentes, hvis det ikke ligger en standard &oslash;vre grense
i antall rader i det programmet du bruker for &aring; kj&oslash;re
SQL-setningen. Terminalklientene har typisk ikke noen slik
begrensning, mens f.eks. MySQL Workbench og pgAdmin har det.</p>
<h2 class="western"><a name="__RefHeading___Toc13939_140935937"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Hente alle unike rader fra en kolonne i en tabell</h2>
<p class="western"><strong><span style="font-weight: normal">N&oslash;kkelordet
</span></strong><strong><b>DISTINCT </b></strong><strong><span style="font-weight: normal">brukes
f&oslash;r en kolonne for &aring; angi at du vil ha tilbake unike
verdier, dvs. en rad for hver unike verdi kolonnen inneholder.</span></strong></p>
<p class="western"><strong><span style="font-weight: normal">Setningen
</span></strong><strong><span style="font-weight: normal">ned</span></strong><strong><span style="font-weight: normal">enfor
henter bare 1 rad for hver unike </span></strong><em><b>title </b></em><em><span style="font-style: normal"><span style="font-weight: normal">i
tabellen </span></span></em><em><b>titles</b></em><strong><span style="font-weight: normal">.
Dette er nyttig hvis du f.eks. vil ha en oversikt over hvilke
stillingskategorier bedriften har og bare vil ha dem listet opp &eacute;n
gang hver, siden de er registrert flere ganger i tabellen (en gang
for hver ansatt). Tabellen titles inneholder 443308 rader, </span></strong><strong><span style="font-weight: normal">men
som vi ser er det bare 7 ulike titler i hele bedriften, </span></strong><strong><span style="font-weight: normal">s&aring;
her er </span></strong><strong><b>DISTINCT</b></strong><strong><span style="font-weight: normal">
helt n&oslash;dvendig for &aring; f&aring; en brukbar oversikt.</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT DISTINCT title FROM titles;</span></strong>

<strong><span style="font-weight: normal">+--------------------+</span></strong>
<strong><span style="font-weight: normal">| title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">+--------------------+</span></strong>
<strong><span style="font-weight: normal">| Senior Engineer&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| Staff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| Engineer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| Senior Staff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| Assistant Engineer |</span></strong>
<strong><span style="font-weight: normal">| Technique Leader&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| Manager&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">+--------------------+</span></strong></pre><p class="merk">
<b>MERK:</b> D<span style="font-weight: normal">u</span> kan bare
bruke <b>DISTINCT</b> p&aring; <span style="font-weight: normal">&eacute;n
kolonne </span><span style="font-weight: normal">i </span><span style="font-weight: normal">hver</span><span style="font-weight: normal">
SQL-setning</span>. <span style="font-weight: normal">Det gir mening
siden databasen ikke vil kunne </span><span style="font-weight: normal">hente
</span><span style="font-weight: normal">mer enn </span><span style="font-weight: normal">&eacute;n</span><span style="font-weight: normal">
rad for hver unike verdi, s&aring; det </span><span style="font-weight: normal">vil
v&aelig;re </span><span style="font-weight: normal">meningsl&oslash;st
&aring; le</span><span style="font-weight: normal">g</span><span style="font-weight: normal">ge
til flere </span><span style="font-weight: normal">distinkte </span><span style="font-weight: normal">kolonner
</span><span style="font-weight: normal">i en rad</span><span style="font-weight: normal">.
</span><span style="font-weight: normal">Med de fleste DBMSer vil det
gi en feilmelding om du fors&oslash;ker.</span><span style="font-weight: normal">
  </span> 
</p>
<h2 class="western"><a name="__RefHeading___Toc13941_140935937"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Begrense antall rader i resultatet</h2>
<p class="western">SELECT henter alle rader som m&oslash;ter
s&oslash;kekriteriene. Dersom man kun &oslash;nsker &aring; hente et
bestemt antall rader, kan dette gj&oslash;res, men m&aring;ten &aring;
gj&oslash;re det p&aring; varierer mellom ulike databasesystemer. Her
er noen eksempler:</p>
<h3 class="western"><a name="__RefHeading___Toc16206_413252541"></a><strong><span style="font-weight: normal">Begrense
antall rader m</span></strong><strong><span style="font-weight: normal">ed
Microsoft SQL Server</span></strong></h3>
<p class="western"><strong><span style="font-weight: normal">SQL
Server har en syntaks som skiller seg fra de andre ved at
begrensningen legges til rett etter n&oslash;kkelordet SELECT. Man
bruker n&oslash;kkelordet </span></strong><strong><b>TOP </b></strong><strong><span style="font-weight: normal">etterfulgt
av et tall som angir antall rader du vil hente</span></strong><strong><b>.
</b></strong>
</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT </span></strong><strong><b>TOP 3 </b></strong><strong><span style="font-weight: normal">dept_name FROM departments;</span></strong></pre><p class="merk">
<strong>MERK: TOP </strong><strong><span style="font-weight: normal">henter
</span></strong><strong><span style="font-weight: normal">et antall</span></strong><strong><span style="font-weight: normal">
</span></strong><strong><b>tilfeldige rader</b></strong><strong><span style="font-weight: normal">
fra s&oslash;keresultatet, i praksis de f&oslash;rste databasen
finner, </span></strong><strong><span style="font-weight: normal">og
ikke f.eks. de nyeste radene eller de med h&oslash;yest verdi for en
kolonne e.l.. Vil du f.eks. ha en liste med de 10 nyeste m&aring; du
sortere p&aring; et datofelt f&oslash;rst, og s&aring; begrense med
TOP. Du kan lese om sortering senere i dette kapitlet.</span></strong></p>
<p class="western"><strong><span style="font-weight: normal">Med MS
SQL Server kan du ogs&aring; spesifisere TOP i prosent, istedenfor i
antall trader, f.eks. </span></strong><strong><span style="font-weight: normal">hente
2 promille av radene i tabellen</span></strong><strong><span style="font-weight: normal">:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT </span></strong><strong><b>TOP (0.2) PERCENT</b></strong><strong><span style="font-weight: normal"> * from employees; </span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Vi kan ogs&aring; sette et
tall for en </span></strong><strong><b>OFFSET</b></strong><strong><span style="font-weight: normal">
med MS SQL Server, dvs. et antall rader som det skal hoppes over f&oslash;r
radene hentes, hvis vi sorterer resultatet og bruker denne syntaksen:</span></strong></p>
<pre class="western"><strong><font color="#000000"><font face="Liberation Mono"><span style="font-weight: normal"><span style="background: transparent">SELECT * FROM employees </span></span></font></font></strong>
<strong><font color="#000000"><font face="Liberation Mono"><b><span style="background: transparent">OFFSET 50 ROWS FETCH NEXT 25 ROWS ONLY</span></b></font></font></strong><strong><font color="#000000"><font face="Liberation Mono"><span style="font-weight: normal"><span style="background: transparent">;</span></span></font></font></strong></pre><h3 class="western">
<a name="__RefHeading___Toc16208_413252541"></a><strong><span style="font-weight: normal">Begrense
antall rader m</span></strong><strong><span style="font-weight: normal">ed</span></strong><strong>
</strong><strong><span style="font-weight: normal">Oracle</span></strong></h3>
<pre class="western"><strong><span style="font-weight: normal">SELECT dept_name FROM departments </span></strong><strong><b>WHERE</b></strong><strong><span style="font-weight: normal"> </span></strong><strong><b>ROWNUM &lt;=3</b></strong><strong><span style="font-weight: normal">;&nbsp;</span></strong></pre><h3 class="western">
<a name="__RefHeading___Toc16210_413252541"></a><strong><span style="font-weight: normal">Begrense
antall rader m</span></strong><strong><span style="font-weight: normal">ed</span></strong><strong>
</strong><strong><span style="font-weight: normal">MySQL/MariaDB  </span></strong><strong><span style="font-weight: normal">og
PostgreSQL</span></strong></h3>
<p class="western"><strong><span style="font-weight: normal">MySQL,
MariaDB og PostgreSQL bruker alle n&oslash;kkelordet </span></strong><strong><b>LIMIT
</b></strong><strong><span style="font-weight: normal">etterfulgt av
et tall, til &aring; begrense antall rader i resultat-tabellen.
Setningen nedenfor henter tre vilk&aring;rlige rader i en tabell med
tre definerte kolonner: </span></strong>
</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, first_name, last_name FROM employees </span></strong>
<strong><b>LIMIT 3</b></strong><strong><span style="font-weight: normal">;</span></strong></pre><p class="western">
Med MySQL, MariaDB og PostgreSQL kan man sette verdi for en <b>OFFSET</b>,
dvs. et antall rader som systemet skal hoppe over f&oslash;r radene
hentes - f.eks. kan man hente 3 rader fra rad 100 og utover, slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, first_name, last_name FROM employees</span></strong>
<strong><b>LIMIT 3 OFFSET 100</b></strong><strong><span style="font-weight: normal">;</span></strong></pre><p class="western">
Med MySQL og MariaDB kan man ogs&aring; skrive dette p&aring; denne
m&aring;ten:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, first_name, last_name FROM employees</span></strong>
<strong><b>LIMIT 100,3</b></strong><strong><span style="font-weight: normal">;</span></strong></pre><p class="merk">
<strong>MERK: </strong><strong><span style="font-weight: normal">PostgreSQL
tillater ikke den siste kortversjonen av LIMIT med OFFSET &ndash; og
gir denne feilmeldingen hvis du fors&oslash;ker:</span></strong></p>
<p class="merk"><strong><span style="font-weight: normal">ERROR: 
LIMIT #,# syntax is not supported<br/>
LINE 1: select * from
employees limit 100,3<br/>
HINT:  Use separate LIMIT and OFFSET
clauses.</span></strong></p>
<h2 class="western" style="font-weight: normal"><a name="__RefHeading___Toc191_487959650"></a>
<strong><font color="#1b75bc">&#61609;</font></strong> Sortere data
med ORDER BY</h2>
<p class="western"><span style="font-weight: normal">N&aring;r vi
henter ut data med SELECT, vises de ikke i noen gitt rekkef&oslash;lge.
Som regel vises de i den rekkef&oslash;lge de ble lagt inn, men vi
har ingen garanti for dette. For &aring; sortere data, bruker vi
derfor betingelsen: </span><strong><b>ORDER BY </b></strong><strong><span style="font-weight: normal">etterfulgt
av feltet vi vil ha sortert</span></strong><strong><span style="font-weight: normal">,
</span></strong><strong><span style="font-weight: normal">f.eks.
</span></strong><span style="font-weight: normal">slik:</span></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT dept_no, dept_name FROM departments </span></strong><strong><b>ORDER BY</b></strong><strong><span style="font-weight: normal"> dept_name; </span></strong>

+---------+--------------------+
| dept_no | dept_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
+---------+--------------------+
| d009&nbsp;&nbsp;&nbsp; | Customer Service&nbsp;&nbsp; |
| d005&nbsp;&nbsp;&nbsp; | Development&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
| d002&nbsp;&nbsp;&nbsp; | Finance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
| d003&nbsp;&nbsp;&nbsp; | Human Resources&nbsp;&nbsp;&nbsp; |
| d001&nbsp;&nbsp;&nbsp; | Marketing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
| d004&nbsp;&nbsp;&nbsp; | Production&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
| d006&nbsp;&nbsp;&nbsp; | Quality Management |
| d008&nbsp;&nbsp;&nbsp; | Research&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
| d007&nbsp;&nbsp;&nbsp; | Sales&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
+---------+--------------------+</pre><p class="merk">
<strong>MERK: </strong><strong>ORDER BY</strong> m&aring; alltid
komme helt til slutt i en SELECT-setning. Hvis ikke genereres en
feilmelding. (Unntak for MySQL/MariaDB og PostgreSQL hvor LIMIT kan
komme etter ORDER BY)</p>
<h3 class="western"><a name="__RefHeading___Toc15763_604779659"></a>ORDER
BY med begrensning av resultatet i Oracle</h3>
<p class="western">Oracle skiller seg fra de andre RDBMSene ved at
det hentes <i><b>vilk&aring;rlige</b></i> rader med ROWNUM <i>selv om
resultatet er sortert</i>, s&aring; hvis du f.eks. vil hente navnet
til de 3 sist ansatte medarbeiderne m&aring; du f&oslash;rst lage en
SELECT-setning som er sortert p&aring; hire_date i synkende
rekkef&oslash;lge og s&aring; lage en &laquo;select *&raquo; fra
denne igjen, som p&aring; denne m&aring;ten:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT</span></strong><strong><span style="font-weight: normal"> * from (</span></strong><strong><span style="font-weight: normal">SELECT</span></strong><strong><span style="font-weight: normal"> </span></strong><strong><span style="font-weight: normal">first_name, last_name</span></strong><strong><span style="font-weight: normal"> </span></strong><strong><span style="font-weight: normal">FROM</span></strong><strong><span style="font-weight: normal"> employees </span></strong><strong><span style="font-weight: normal">ORDER BY</span></strong><strong><span style="font-weight: normal"> hire_date </span></strong><strong><span style="font-weight: normal">DESC</span></strong><strong><span style="font-weight: normal">) </span></strong><strong><b>WHERE</b></strong><strong><span style="font-weight: normal"> </span></strong><strong><b>ROWNUM</b></strong><strong><b> &lt;= 3</b></strong><strong><span style="font-weight: normal">;</span></strong>

<strong><span style="font-weight: normal">FIRST_NAME 	LAST_NAME<br/>
---------------  ------------------<br/>
Bikash 		Covnot <br/>
Yucai 		Gerlach <br/>
Hideyuki 		Delgrande</span></strong></pre><h2 class="western">
<a name="__RefHeading___Toc4484_762629072"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Sortering etter flere kolonner</h2>
<p class="western">Vi kan sortere data etter en eller flere kolonner.
List opp kolonnene etter hverandre, med et komma imellom, s&aring;
sorteres data i den rekkef&oslash;lge kolonnene er satt opp. F.eks.:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, first_name, last_name FROM employees</span></strong>
<strong><span style="font-weight: normal">ORDER BY last_name, first_name LIMIT 10;<br/>
</span></strong>
+--------+------------+-----------+
| emp_no | first_name | last_name |
+--------+------------+-----------+
| 258641 | Abdelkader | Aamodt&nbsp;&nbsp;&nbsp; |
| 258005 | Adhemar&nbsp;&nbsp;&nbsp; | Aamodt&nbsp;&nbsp;&nbsp; |
| 455773 | Aemilian&nbsp;&nbsp; | Aamodt&nbsp;&nbsp;&nbsp; |
| 436560 | Alagu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Aamodt&nbsp;&nbsp;&nbsp; |
| 266651 | Aleksander | Aamodt&nbsp;&nbsp;&nbsp; |
| 487598 | Alexius&nbsp;&nbsp;&nbsp; | Aamodt&nbsp;&nbsp;&nbsp; |
| 216963 | Alois&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Aamodt&nbsp;&nbsp;&nbsp; |
|&nbsp; 15427 | Aluzio&nbsp;&nbsp;&nbsp;&nbsp; | Aamodt&nbsp;&nbsp;&nbsp; |
| 100860 | Amabile&nbsp;&nbsp;&nbsp; | Aamodt&nbsp;&nbsp;&nbsp; |
| 107070 | Anestis&nbsp;&nbsp;&nbsp; | Aamodt&nbsp;&nbsp;&nbsp; |
+--------+------------+-----------+</pre><p class="western">
Setningen over vil f&oslash;rst sortere listen med ansatte etter
etternavn. Innenfor hvert etternavn vil listen bli sortert etter
fornavn. Sorteringen er alfanumerisk og stigende, siden ikke noe
annet er spesifisert. Resultatet begrenses til de 10 f&oslash;rste
radene etter at de er sortert (pga. LIMIT 10 til slutt i setningen).</p>
<p class="merk"><strong>MERK: </strong>Det er fullt mulig &aring;
sortere etter kolonner vi ikke henter, dvs. etter kolonner som ikke
er skrevet inn i SELECT-setningen - men det vil da ikke fremg&aring;
automatisk av resultatet hvilken kolonne det er sortert p&aring;.
Hadde vi f.eks. sortert tabellen ovenfor etter de ansattes alder
(feltet <i>birth_date</i><span style="font-style: normal">) ville
rekkef&oslash;lgen sett vilk&aring;rlig ut, siden alder ikke er et av
feltene i tabellen</span><i> </i>
</p>
<h2 class="western"><a name="__RefHeading___Toc4486_762629072"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Angi sorterings-retning</h2>
<p class="western">Hvis vi ikke angir retning, sorteres data
alfanumerisk i stigende rekkef&oslash;lge. Stigende rekkef&oslash;lge
kan angis eksplisitt med n&oslash;kkelordet <b>ASC</b> (for
ascending), men siden dette alltid er standard sorteringsrekkef&oslash;lge
er det som regel utelatt. Vi kan angi at data skal sorteres i
synkende rekkef&oslash;lge med parameteret <strong><b>DESC</b></strong><strong><span style="font-weight: normal">
(for descending)</span></strong><span style="font-weight: normal">,
slik:</span></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, salary FROM salaries</span></strong>
<strong><span style="font-weight: normal">ORDER BY salary </span></strong><strong><b>DESC</b></strong><strong><span style="font-weight: normal">, emp_no LIMIT 10;</span></strong>

+--------+--------+
| emp_no | salary |
+--------+--------+
|&nbsp; 43624 | 158220 |
|&nbsp; 43624 | 157821 |
| 254466 | 156286 |
|&nbsp; 47978 | 155709 |
| 253939 | 155513 |
| 109334 | 155377 |
| 109334 | 155190 |
| 109334 | 154888 |
| 109334 | 154885 |
|&nbsp; 80823 | 154459 |
+--------+--------+</pre><p class="merk">
<strong>MERK: </strong>I eksemplet ovenfor sorteres data etter l&oslash;nn
(<i>salary</i>), i synkende rekkef&oslash;lge, dvs, med h&oslash;yeste
l&oslash;nn &oslash;verst, og innenfor hver l&oslash;nnskategori
sorteres det etter ansattnummer (<i>emp_no</i>), i stigende
rekkef&oslash;lge. Som vi ser er det kun &eacute;n rad innenfor hver
l&oslash;nnsverdi, slik at det i praksis ikke blir sortert p&aring;
emp_no p&aring; disse f&oslash;rste 10 radene. 
</p>
<p class="western">Vil vi sortere flere kolonner i synkende
rekkef&oslash;lge m&aring; vi sette <b>DESC</b> etter hvert
kolonnenavn, slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, salary FROM salaries</span></strong>
<strong><span style="font-weight: normal">ORDER BY emp_no </span></strong><strong><b>DESC</b></strong><strong><span style="font-weight: normal">, salary </span></strong><strong><b>DESC</b></strong><strong><span style="font-weight: normal"> LIMIT 10;</span></strong>

+--------+--------+
| emp_no | salary |
+--------+--------+
| 499999 |&nbsp; 77303 |
| 499999 |&nbsp; 74327 |
| 499999 |&nbsp; 70745 |
| 499999 |&nbsp; 67043 |
| 499999 |&nbsp; 63707 |
| 499998 |&nbsp; 55003 |
| 499998 |&nbsp; 51182 |
| 499998 |&nbsp; 49971 |
| 499998 |&nbsp; 47429 |
| 499998 |&nbsp; 46206 |
+--------+--------+</pre><h3 class="western">
<a name="__RefHeading___Toc4488_762629072"></a>Sorteringsrekkef&oslash;lge</h3>
<p class="western">I de fleste tilfeller vil databasen v&aelig;re
satt opp slik at tekst-data sorteres i <b>leksikalsk rekkef&oslash;lge</b>.
Det vil si at tall kommer f&oslash;r bokstaver og at A og a behandles
som like. Noen databaser kan ha blitt satt opp med andre rekkef&oslash;lger.
Hvis du f&aring;r uventede resultater, kan det l&oslash;nne seg &aring;
ta en prat med administratoren for databasen (DBA) eller sjekke
dokumentasjonen for den versjonen av programvaren du har installert.</p>
<h2 class="western"><a name="__RefHeading___Toc9301_974749821"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Sortering etter spr&aring;k</h2>
<p class="western">Sortering angis ved n&oslash;kkelordene:
<strong>collation/collate </strong>og kategoriseres etter spr&aring;k
i henhold til internasjonal standard. N&aring;r man lager en tabell
kan man f.eks. angi at en kolonne skal sorteres etter norsk bokm&aring;l,
mens en annen kolonne skal sorteres etter engelsk eller fransk. Hvis
man ikke angir sorteringsspr&aring;k, brukes standardinnstillingen
databasen er satt opp med.</p>
<h3 class="western"><a name="__RefHeading___Toc4490_762629072"></a>Sortering
etter spr&aring;k med MySQL / MariaDB</h3>
<p class="western">Med <strong>MySQL / MariaDB</strong> kan du f&aring;
frem hvilken sorteringsrekkef&oslash;lge som er brukt p&aring; en
kolonne ved &aring; bruke funksjonen <strong>collation(), </strong>f.eks.
slik:</p>
<pre class="western"><strong><span style="font-weight: normal">select collation(last_name) from employees order by last_name limit 1;</span></strong>

+----------------------+
| collation(last_name) |
+----------------------+
| latin1_swedish_ci&nbsp;&nbsp;&nbsp; |
+----------------------+</pre><p class="western">
Du kan vise hvilke ulike valg man har for sortering, f.eks. med utf8
som tegnsett, med denne kommandoen:</p>
<pre class="western"><strong><span style="font-weight: normal">show collation like '%utf8%';</span></strong>

<font size="1" style="font-size: 8pt">+------------------------------+---------+-----+---------+----------+---------+</font>
<font size="1" style="font-size: 8pt">| Collation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Charset | Id&nbsp; | Default | Compiled | Sortlen |</font>
<font size="1" style="font-size: 8pt">+------------------------------+---------+-----+---------+----------+---------+</font>
<font size="1" style="font-size: 8pt">| utf8_general_ci&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp; |&nbsp; 33 | Yes&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</font>
<font size="1" style="font-size: 8pt">| utf8_bin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp; |&nbsp; 83 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</font>
<font size="1" style="font-size: 8pt">| utf8_unicode_ci&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp; | 192 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |</font>
<font size="1" style="font-size: 8pt">| utf8_icelandic_ci&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp; | 193 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |</font>
<font size="1" style="font-size: 8pt">| utf8_latvian_ci&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp; | 194 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |</font>
<font size="1" style="font-size: 8pt">| utf8_romanian_ci&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp; | 195 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |</font>
<font size="1" style="font-size: 8pt">| utf8_slovenian_ci&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp; | 196 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |</font>
<font size="1" style="font-size: 8pt">| utf8_polish_ci&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp; | 197 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |</font>
<font size="1" style="font-size: 8pt">| utf8_estonian_ci&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp; | 198 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |</font>
<font size="1" style="font-size: 8pt">| utf8_spanish_ci&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp; | 199 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |</font>
<font size="1" style="font-size: 8pt">| utf8_swedish_ci&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp; | 200 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |</font>
<font size="1" style="font-size: 8pt">| utf8_turkish_ci&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp; | 201 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |</font>
<font size="1" style="font-size: 8pt">| utf8_czech_ci&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp; | 202 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |</font>
<font size="1" style="font-size: 8pt">| utf8_danish_ci&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8&nbsp;&nbsp;&nbsp; | 203 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |</font>

<font size="1" style="font-size: 8pt">...............................................................................</font>

<font size="1" style="font-size: 8pt">| utf8mb4_croatian_mysql561_ci | utf8mb4 | 245 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 |</font>
<font size="1" style="font-size: 8pt">| utf8mb4_thai_520_w2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | utf8mb4 | 610 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |</font>
<font size="1" style="font-size: 8pt">+------------------------------+---------+-----+---------+----------+---------+</font>
<font size="1" style="font-size: 8pt">59 rows in set (0,01 sec)</font></pre><p class="western">
Betegnelsen <strong>_ci </strong>p&aring; slutten av&nbsp; navnene
angir at store og sm&aring; bokstaver sorteres sammen (<strong>ci =
case insensitive</strong>). Alternativene er <strong>_cs (case
sensitive) </strong>og<strong> _bn (binary).</strong></p>
<p class="merk"><strong>MERK:</strong> MySQL og MariaDB bruker
<em><strong>utf8_danish_ci</strong></em> til &aring; angi norsk og
dansk sortering for tegnsettet utf8.</p>
<h4 class="western"><a name="__RefHeading___Toc4492_762629072"></a>Endre
spr&aring;k per s&oslash;k</h4>
<p class="western">Vi kan endre sorterings-spr&aring;ket for et
enkelt s&oslash;k ved &aring; sette spr&aring;ket inn i
SQL-setningen. Nedenfor vises et s&oslash;k uten &aring; angi spr&aring;k,
hvor resultatet er sortert etter standardinnstillingen for databasen,
evt for tabellen, hvis den er angitt. Vi ser at Aamodt kommer f&oslash;rst
i tabellen, dvs. at dette ikke er etter norsk/dansk spr&aring;k, men
antagelig engelsk.</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT</span></strong><strong><span style="font-weight: normal"> * </span></strong><strong><span style="font-weight: normal">FROM</span></strong><strong><span style="font-weight: normal"> employees </span></strong><strong><span style="font-weight: normal">ORDER BY</span></strong><strong><span style="font-weight: normal"> last_name, first_name </span></strong><strong><span style="font-weight: normal">LIMIT</span></strong><strong><span style="font-weight: normal"> 5;</span></strong>

+--------+------------+------------+-----------+--------+------------+
| emp_no | birth_date | first_name | last_name | gender | hire_date&nbsp; |
+--------+------------+------------+-----------+--------+------------+
| 258641 | 1961-05-23 | Abdelkader | Aamodt&nbsp;&nbsp;&nbsp; | M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1994-12-02 |
| 258005 | 1953-02-17 | Adhemar&nbsp;&nbsp;&nbsp; | Aamodt&nbsp;&nbsp;&nbsp; | F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1991-01-21 |
| 455773 | 1960-05-04 | Aemilian&nbsp;&nbsp; | Aamodt&nbsp;&nbsp;&nbsp; | M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1988-04-21 |
| 436560 | 1959-03-16 | Alagu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Aamodt&nbsp;&nbsp;&nbsp; | F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1991-10-17 |
| 266651 | 1959-05-28 | Aleksander | Aamodt&nbsp;&nbsp;&nbsp; | F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1989-03-29 |
+--------+------------+------------+-----------+--------+------------+
5 rows in set (0,26 sec)</pre><p class="western">
Her er den samme tabellen sortert etter norsk/dansk spr&aring;k, og
vi ser at Acton n&aring; er f&oslash;rst (og Aamodt vil v&aelig;re
sidestilt med &Aring;modt).</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT * FROM employees ORDER BY last_name </span></strong><strong><b>COLLATE utf8_danish_ci</b></strong><strong><span style="font-weight: normal">, first_name </span></strong><strong><b>COLLATE utf8_danish_ci</b></strong><strong><span style="font-weight: normal"> LIMIT 5;</span></strong>

+--------+------------+------------+-----------+--------+------------+
| emp_no | birth_date | first_name | last_name | gender | hire_date&nbsp; |
+--------+------------+------------+-----------+--------+------------+
|&nbsp; 93347 | 1960-10-04 | Abdulla&nbsp;&nbsp;&nbsp; | Acton&nbsp;&nbsp;&nbsp;&nbsp; | M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1992-10-31 |
| 215122 | 1959-05-14 | Adit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Acton&nbsp;&nbsp;&nbsp;&nbsp; | M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1988-11-28 |
| 230078 | 1952-06-14 | Aimee&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Acton&nbsp;&nbsp;&nbsp;&nbsp; | F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1998-01-05 |
| 255705 | 1954-08-28 | Aimee&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Acton&nbsp;&nbsp;&nbsp;&nbsp; | F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1994-01-06 |
| 277402 | 1961-07-04 | Alassane&nbsp;&nbsp; | Acton&nbsp;&nbsp;&nbsp;&nbsp; | M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1990-02-19 |
+--------+------------+------------+-----------+--------+------------+
5 rows in set (0,34 sec)</pre><p class="western">
I tabellen nedenfor  er spr&aring;ket satt til <b>utf8_general_ci</b>,
som i praksis betyr engelsk spr&aring;k uten &aring; skille mellom
sm&aring; og store bokstaver, og Aamodt er igjen p&aring; toppen av
tabellen:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT * FROM employees ORDER BY last_name </span></strong><strong><b>COLLATE utf8_general_ci</b></strong><strong><span style="font-weight: normal">, first_name </span></strong><strong><b>COLLATE utf8_general_ci</b></strong><strong><span style="font-weight: normal"> LIMIT 5;</span></strong>

+--------+------------+------------+-----------+--------+------------+
| emp_no | birth_date | first_name | last_name | gender | hire_date&nbsp; |
+--------+------------+------------+-----------+--------+------------+
| 258641 | 1961-05-23 | Abdelkader | Aamodt&nbsp;&nbsp;&nbsp; | M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1994-12-02 |
| 258005 | 1953-02-17 | Adhemar&nbsp;&nbsp;&nbsp; | Aamodt&nbsp;&nbsp;&nbsp; | F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1991-01-21 |
| 455773 | 1960-05-04 | Aemilian&nbsp;&nbsp; | Aamodt&nbsp;&nbsp;&nbsp; | M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1988-04-21 |
| 436560 | 1959-03-16 | Alagu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Aamodt&nbsp;&nbsp;&nbsp; | F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1991-10-17 |
| 266651 | 1959-05-28 | Aleksander | Aamodt&nbsp;&nbsp;&nbsp; | F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1989-03-29 |
+--------+------------+------------+-----------+--------+------------+
5 rows in set (0,25 sec)</pre><h3 class="western">
<a name="__RefHeading___Toc4494_762629072"></a>Sortering etter spr&aring;k
med PostgreSQL</h3>
<p class="western">Med <em><strong>PostgreSQL</strong></em> kan man
f.eks. angi at etternavn skal sorteres etter norsk bokm&aring;l,
direkte i s&oslash;kesetningen, ved &aring; bruke n&oslash;kkelordet
<strong>COLLATE</strong> etterfulgt av den internasjonale standarden
for angivelse av spr&aring;k - &lt;spr&aring;k&gt;_&lt;LANDSKODE&gt;
f.eks. slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, first_name, last_name </span></strong><strong><b>collate &quot;nb_NO&quot;</b></strong><strong><span style="font-weight: normal"> FROM employees</span></strong>
<strong><span style="font-weight: normal">ORDER BY last_name </span></strong><strong><span style="font-weight: normal">LIMIT</span></strong><strong><span style="font-weight: normal"> 10;</span></strong>

 emp_no | first_name | last_name 
--------+------------+-----------
&nbsp; 20737 | Oscar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Acton
&nbsp; 23861 | Tayeb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Acton
&nbsp; 15229 | Xiahua&nbsp;&nbsp;&nbsp;&nbsp; | Acton
&nbsp; 17823 | Uriel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Acton
&nbsp; 15171 | Brigham&nbsp;&nbsp;&nbsp; | Acton
&nbsp; 21519 | Xumin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Acton
&nbsp; 14092 | Yahiko&nbsp;&nbsp;&nbsp;&nbsp; | Acton
&nbsp; 10695 | Zorica&nbsp;&nbsp;&nbsp;&nbsp; | Acton
&nbsp; 27201 | Soenke&nbsp;&nbsp;&nbsp;&nbsp; | Acton
&nbsp; 26736 | Shaz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Acton</pre><p class="western">
<strong><span style="font-weight: normal">Bruker vi </span></strong><strong><b>britisk
engelsk sortering</b></strong><strong><span style="font-weight: normal">
p&aring; etternavn gir det dette resultatet:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, first_name, last_name </span></strong><strong><b>collate &quot;en_GB&quot;</b></strong><strong><span style="font-weight: normal"> FROM employees</span></strong>
<strong><span style="font-weight: normal">ORDER BY last_name limit 10;</span></strong>

<strong> </strong><strong><span style="font-weight: normal">e</span></strong>mp_no | first_name | last_name 
--------+------------+-----------
&nbsp; 17400 | Basim&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Aamodt
&nbsp; 17885 | Takanari&nbsp;&nbsp; | Aamodt
&nbsp; 15427 | Aluzio&nbsp;&nbsp;&nbsp;&nbsp; | Aamodt
&nbsp; 16572 | Matt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Aamodt
&nbsp; 12982 | Sachem&nbsp;&nbsp;&nbsp;&nbsp; | Aamodt
&nbsp; 12516 | Sreenivas&nbsp; | Aamodt
&nbsp; 11761 | Bartek&nbsp;&nbsp;&nbsp;&nbsp; | Aamodt
&nbsp; 12791 | Mokhtar&nbsp;&nbsp;&nbsp; | Aamodt
&nbsp; 19898 | Vidar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Aamodt
&nbsp; 18182 | Dekang&nbsp;&nbsp;&nbsp;&nbsp; | Aamodt</pre><p class="merk">
<b>MERK:</b> S<span style="font-weight: normal">pr&aring;k- og
landskoden m&aring; st&aring; i doble anf&oslash;rselstegn, i likhet
med feltnavn hvor PostgreSQL skal skille mellom sm&aring; og store
bokstaver, siden PostgreSQL ellers h&aring;ndterer alt som sm&aring;
bokstaver, </span><span style="font-weight: normal">og dermed ikke
finner landskoden. </span><span style="font-weight: normal"> </span> 
</p>
<p class="western">Hvilke spr&aring;k som er installert p&aring;
serveren som PostgreSQL kj&oslash;rer p&aring; (og dermed kan
erstatte &quot;nb_NO&quot; i setningen over) kan man f&aring; frem p&aring;
en Linux-server med denne kommandoen fra et terminalvindu:</p>
<pre class="western"><strong><b>locale -a</b></strong>

<strong><span style="font-weight: normal">af_ZA</span></strong>
<strong><span style="font-weight: normal">af_ZA.iso88591</span></strong>
<strong><span style="font-weight: normal">af_ZA.utf8</span></strong>
<strong><span style="font-weight: normal">ak_GH</span></strong>
<strong><span style="font-weight: normal">ak_GH.utf8</span></strong>
<strong><span style="font-weight: normal">am_ET</span></strong>
<strong><span style="font-weight: normal">am_ET.utf8</span></strong>
<strong><span style="font-weight: normal">an_ES</span></strong>
<strong><span style="font-weight: normal">an_ES.iso885915</span></strong>
<strong><span style="font-weight: normal">an_ES.utf8</span></strong>
<strong><span style="font-weight: normal">anp_IN</span></strong>
<strong><span style="font-weight: normal">anp_IN.utf8</span></strong>
<strong><span style="font-weight: normal">ar_AE</span></strong>
<strong><span style="font-weight: normal">ar_AE.iso88596</span></strong>
<strong><span style="font-weight: normal">ar_AE.utf8</span></strong>
<strong><span style="font-weight: normal">ar_BH</span></strong>
<strong><span style="font-weight: normal">ar_BH.iso88596</span></strong>
<strong><span style="font-weight: normal">etc .....<br/>
</span></strong></pre><h3 class="western">
<a name="__RefHeading___Toc14210_2514959757"></a><strong><span style="font-weight: normal">Sortering
etter spr&aring;k med </span></strong><strong><span style="font-weight: normal">Microsoft
SQL Server</span></strong></h3>
<p class="western"><strong><span style="font-weight: normal">Sortering
etter spr&aring;k</span></strong><strong><b> (</b></strong><strong><b>collation</b></strong><strong><b>)</b></strong><strong><span style="font-weight: normal">
</span></strong><strong><span style="font-weight: normal">kan
anvendes p&aring; uttrykk, kolonner og databaser</span></strong><strong><span style="font-weight: normal">.
</span></strong><strong><span style="font-weight: normal">Spr&aring;ket
kan angis etter en av to spesifikasjoner:</span></strong><strong><span style="font-weight: normal">
</span></strong>
</p>
<ol>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql">Windows
	Collation Name</a>. 
	</p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/statements/sql-server-collation-name-transact-sql">SQL
	Server Collation Name</a>. 
	</p>
</ol>
<p class="western"><strong><span style="font-weight: normal">For &aring;
finne hvilke sorteringsrekkef&oslash;lger SQL-serveren st&oslash;tter
</span></strong><strong><span style="font-weight: normal">for norsk
spr&aring;k </span></strong><strong><span style="font-weight: normal">kan
man bruke denne SQL-setningen:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT name FROM sys.fn_helpcollations() where lower(name) like '%norwegian%' <br/>
</span></strong>
<strong><span style="font-weight: normal">name<br/>
-------------------------------------------------------<br/>
Danish_Norwegian_BIN<br/>
Danish_Norwegian_BIN2<br/>
Danish_Norwegian_CI_AI<br/>
Danish_Norwegian_CI_AI_WS<br/>
Danish_Norwegian_CI_AI_KS<br/>
Danish_Norwegian_CI_AI_KS_WS<br/>
Danish_Norwegian_CI_AS<br/>
Danish_Norwegian_CI_AS_WS<br/>
Danish_Norwegian_CI_AS_KS<br/>
Danish_Norwegian_CI_AS_KS_WS<br/>
Danish_Norwegian_CS_AI<br/>
Danish_Norwegian_CS_AI_WS<br/>
Danish_Norwegian_CS_AI_KS<br/>
Danish_Norwegian_CS_AI_KS_WS<br/>
Danish_Norwegian_CS_AS<br/>
Danish_Norwegian_CS_AS_WS<br/>
Danish_Norwegian_CS_AS_KS<br/>
Danish_Norwegian_CS_AS_KS_WS<br/>
Norwegian_100_BIN<br/>
Norwegian_100_BIN2<br/>
Norwegian_100_CI_AI<br/>
Norwegian_100_CI_AI_WS<br/>
Norwegian_100_CI_AI_KS<br/>
Norwegian_100_CI_AI_KS_WS<br/>
Norwegian_100_CI_AS<br/>
Norwegian_100_CI_AS_WS<br/>
Norwegian_100_CI_AS_KS<br/>
Norwegian_100_CI_AS_KS_WS<br/>
Norwegian_100_CS_AI<br/>
Norwegian_100_CS_AI_WS<br/>
Norwegian_100_CS_AI_KS<br/>
Norwegian_100_CS_AI_KS_WS<br/>
Norwegian_100_CS_AS<br/>
Norwegian_100_CS_AS_WS<br/>
Norwegian_100_CS_AS_KS<br/>
Norwegian_100_CS_AS_KS_WS<br/>
Norwegian_100_CI_AI_SC<br/>
Norwegian_100_CI_AI_WS_SC<br/>
Norwegian_100_CI_AI_KS_SC<br/>
Norwegian_100_CI_AI_KS_WS_SC<br/>
Norwegian_100_CI_AS_SC<br/>
Norwegian_100_CI_AS_WS_SC<br/>
Norwegian_100_CI_AS_KS_SC<br/>
Norwegian_100_CI_AS_KS_WS_SC<br/>
Norwegian_100_CS_AI_SC<br/>
Norwegian_100_CS_AI_WS_SC<br/>
Norwegian_100_CS_AI_KS_SC<br/>
Norwegian_100_CS_AI_KS_WS_SC<br/>
Norwegian_100_CS_AS_SC<br/>
Norwegian_100_CS_AS_WS_SC<br/>
Norwegian_100_CS_AS_KS_SC<br/>
Norwegian_100_CS_AS_KS_WS_SC<br/>
</span></strong>
<strong><span style="font-weight: normal">(52</span></strong><strong><span style="font-weight: normal"> </span></strong><strong><span style="font-weight: normal">rows affected)</span></strong></pre><p class="merk">
<strong><b>MERK: </b></strong><strong><span style="font-weight: normal">Av
alle disse mulighetene er det kun de som begynner med
Danish_Norwegian som gir oss riktig sortering av Aa sammen med &Aring;.
</span></strong>
</p>
<p class="western"><strong><span style="font-weight: normal">Her er
et eksempel hvor vi f&oslash;rst s&oslash;ker fornavn og etternavn
fra tabellen employees, og sorterer etter etternavn med databasens
standard-innstillinger for spr&aring;k:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT TOP 5 first_name, last_name FROM employees ORDER BY last_name;</span></strong>
<strong><span style="font-weight: normal"><br/>
first_name &nbsp;&nbsp;&nbsp;&nbsp;last_name &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
-------------- ---------------- <br/>
Weiyi &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aamodt &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Ziya &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aamodt &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Kensyu &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aamodt &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Gladys &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aamodt &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Roddy &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aamodt &nbsp;&nbsp;&nbsp;&nbsp;</span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Vi ser at Aamodt kommer
f&oslash;rst i sorteringen, dvs. at det ikke sorteres etter norsk
(eller dansk) spr&aring;k. Legger vi til</span></strong><strong><span style="font-weight: normal">
dansk-norsk sortering &ndash; </span></strong><strong><b>Danish_Norwegian_CI_AS
- </b></strong><strong><span style="font-weight: normal"> blir det
riktig: </span></strong>
</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT</span></strong><strong><span style="font-weight: normal"> </span></strong><strong><span style="font-weight: normal">TOP </span></strong><strong><span style="font-weight: normal">5 first_name, last_name </span></strong><strong><span style="font-weight: normal">FROM</span></strong><strong><span style="font-weight: normal"> employees </span></strong><strong><span style="font-weight: normal">ORDER BY</span></strong><strong><span style="font-weight: normal"> last_name </span></strong><strong><b>collate Danish_Norwegian_CI_AS</b></strong><strong><span style="font-weight: normal">;  </span></strong>
<strong><span style="font-weight: normal"><br/>
first_name &nbsp;&nbsp;&nbsp;&nbsp;last_name &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
-------------- ---------------- <br/>
Oscar &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Acton &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Xumin &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Acton &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Tayeb &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Acton &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Shaz &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Acton &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Soenke &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Acton &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></strong></pre><h3 class="western">
<a name="__RefHeading___Toc14212_2514959757"></a><strong><span style="font-weight: normal">Sortering
etter spr&aring;k med </span></strong><strong><span style="font-weight: normal">Oracle</span></strong></h3>
<p class="western"><strong><span style="font-weight: normal">Hvis vi
skal hente ute en sortert tabell, men vil begrense resultatet til
noen f&aring; rader, m&aring; vi med Oracle bruke to
SELECT-setninger: F&oslash;rst en som henter ut hele tabellen i
sortert rekkef&oslash;lge, og s&aring; setter vi denne inne i en
parentes og henter f.eks. kun 5 rader fra denne ved &aring; sette
SELECT * FROM f&oslash;r parentesen og WHERE rownum &lt;= 5  etter
parentesen, slik:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT * FROM (SELECT first_name, last_name FROM employees ORDER BY last_name) WHERE rownum &lt;= 5 ;</span></strong>

<strong><span style="font-weight: normal">first_name &nbsp;&nbsp;&nbsp;&nbsp;last_name &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
-------------- ---------------- <br/>
Weiyi &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aamodt &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Ziya &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aamodt &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Kensyu &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aamodt &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Gladys &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aamodt &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Roddy &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aamodt &nbsp;&nbsp;&nbsp;&nbsp;</span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Eksemplet over bruker
standard-instillingen for spr&aring;k, som vi ser ikke er norsk eller
dansk. </span></strong><strong><span style="font-weight: normal">For
&aring; sortere etter reglene for et annet spr&aring;k, bruker vi
ogs&aring; med Oracle &ndash;</span></strong><strong><span style="font-weight: normal">
funksjonen </span></strong><strong><b>NLSSORT(). </b></strong><strong><span style="font-weight: normal">Denne
funksjonen tar to parametre: Feltet som skal sorteres og en parentes
med &rsquo;NLS_SORT = &lt;SPR&Aring;KKODE&gt;&rsquo;  </span></strong><strong><span style="font-weight: normal">
f.eks. slik:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT * FROM (SELECT first_name, last_name FROM employees </span></strong><strong><b>ORDER BY NLSSORT(last_name, 'NLS_SORT = XDanish')</b></strong><strong><span style="font-weight: normal"> ) WHERE rownum &lt;= 5;</span></strong>

<strong><span style="font-weight: normal">first_name &nbsp;&nbsp;&nbsp;&nbsp;last_name &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></strong>
<strong><span style="font-weight: normal">-------------- ---------------- </span></strong>
<strong><span style="font-weight: normal">Lene 	     Acton</span></strong>
<strong><span style="font-weight: normal">Djenana 	     Acton</span></strong>
<strong><span style="font-weight: normal">Idoia 	     Acton</span></strong>
<strong><span style="font-weight: normal">Heon 	     Acton</span></strong>
<strong><span style="font-weight: normal">Zita 	     Acton </span></strong></pre><p class="merk">
<strong>MERK: </strong><strong><span style="font-weight: normal">Vi
ser at Oracle henter andre fornavn enn f.eks. SQL Server </span></strong><strong><span style="font-weight: normal">gj&oslash;r
for </span></strong><strong><span style="font-weight: normal">de 5
f&oslash;rste radene. Siden vi ikke har sortert p&aring; fornavn vil
det v&aelig;re tilfeldig hvilke som kommer f&oslash;rst innenfor
hvert etternavn.</span></strong></p>
<p class="western"><strong><span style="font-weight: normal">Vi kan
f&aring; en oversikt over hvilke Spr&aring;kkoder som NLS_SORT()
st&oslash;tter </span></strong><strong><span style="font-weight: normal">ved
&aring; g&aring; til denne lenken i Oracles dokumentasjon:
<a href="https://docs.oracle.com/cloud/latest/db112/NLSPG/applocaledata.htm#g681743">https://docs.oracle.com/cloud/latest/db112/NLSPG/applocaledata.htm#g681743</a>.</span></strong></p>
<p class="western"><strong><span style="font-weight: normal">X&rsquo;en
f&oslash;r XDanish st&aring;r for </span></strong><strong><i><b>Extended</b></i></strong><strong><span style="font-style: normal"><span style="font-weight: normal">,
og tar hensyn til spesialiteter utenfor det som normalt ligger i
ASCII-tegnsettet, som f.eks at AA skal tolkes som &eacute;n bokstav:
&Aring;. Dessverre er det ingen XNorwegian, men XDanish fungerer fint
ogs&aring; for norsk.  </span></span></strong>
</p>
<p class="western"><strong><span style="font-weight: normal">Istedenfor
&aring; angi spr&aring;k i hver SQL-setning, kan vi ogs&aring; skrive
inn dette </span></strong><strong><span style="font-weight: normal">i
terminalklienten </span></strong><strong><span style="font-weight: normal">f&oslash;r
</span></strong><strong><span style="font-weight: normal">vi starter
</span></strong><strong><span style="font-weight: normal">s&oslash;kene:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">ALTER SESSION SET NLS_COMP = 'LINGUISTIC';</span></strong>
ALTER SESSION SET NLS_SORT = 'XDanish';</pre><p class="western">
<strong><span style="font-weight: normal">Koden over setter default
s&oslash;kespr&aring;k til Dansk </span></strong><strong><span style="font-weight: normal">for
gjelden</span></strong><strong><span style="font-weight: normal">d</span></strong><strong><span style="font-weight: normal">e
</span></strong><strong><i><b>session, </b></i></strong><strong><span style="font-style: normal"><span style="font-weight: normal">
dvs. s&aring; lenge vi er innlogget. </span></span></strong><strong><span style="font-weight: normal">
</span></strong>
</p>
<h2 class="western"><a name="__RefHeading___Toc15457_3971551474"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Filtrering av data med <strong><span style="font-style: normal"><span style="font-weight: normal">WHERE</span></span></strong></h2>
<p class="western">Ofte &oslash;nsker man &aring; hente ut et utvalg
fra en eller flere tabeller ved &aring; s&oslash;ke (filtrere) etter
spesifiserte s&oslash;kekriterier.  Dette kan vi gj&oslash;re ved &aring;
kombinere <strong>SELECT</strong> med n&oslash;kkelordet <strong>WHERE.</strong>
Her er et eksempel:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT from_date, to_date, salary FROM salaries</span></strong>
<strong><b>WHERE</b></strong><strong><span style="font-weight: normal"> emp_no = 50500; </span></strong>
+------------+------------+--------+
| from_date&nbsp; | to_date&nbsp;&nbsp;&nbsp; | salary |
+------------+------------+--------+
| 1991-08-28 | 1992-08-27 |&nbsp; 42391 |
| 1992-08-27 | 1993-08-27 |&nbsp; 45006 |
| 1993-08-27 | 1994-08-27 |&nbsp; 48098 |
| 1994-08-27 | 1995-08-27 |&nbsp; 51398 |
| 1995-08-27 | 1996-08-26 |&nbsp; 50937 |
| 1996-08-26 | 1997-08-26 |&nbsp; 53809 |
| 1997-08-26 | 1998-08-26 |&nbsp; 55322 |
| 1998-08-26 | 1999-08-26 |&nbsp; 57802 |
| 1999-08-26 | 2000-08-25 |&nbsp; 57745 |
| 2000-08-25 | 2001-08-25 |&nbsp; 61783 |
| 2001-08-25 | 9999-01-01 |&nbsp; 63934 |
+------------+------------+--------+</pre><p class="western" style="line-height: 140%">
Denne setningen henter ut fra- og til-dato og l&oslash;nn for
medarbeideren med ansattnummer 50500.</p>
<p class="merk"><strong>MERK: </strong>Hvis data sorteres med ORDER
BY m&aring; sorteringen st&aring; helt til slutt i setningen, mao
etter WHERE. ORDER BY er alltid det siste vi skriver inn i en
SQL-setning (med unntak for LIMIT som kommer helt til slutt med
PostgreSQL og MySQL/MariaDB).</p>
<p class="western"><strong>Filtreringsvalg med WHERE</strong></p>
<center>
	<table width="480" cellpadding="2" cellspacing="0">
		<col width="167"/>

		<col width="303"/>

		<tr>
			<td width="167" style="border-top: 1px solid #b2b2b2; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
				<strong>Filtrering</strong></p>
			</td>
			<td width="303" style="border: 1px solid #b2b2b2; padding: 0.05cm"><p class="western">
				<strong>Beskrivelse</strong></p>
			</td>
		</tr>
		<tr>
			<td width="167" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
				=</p>
			</td>
			<td width="303" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Er lik</p>
			</td>
		</tr>
		<tr>
			<td width="167" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
				&lt;&gt;</p>
			</td>
			<td width="303" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Er ulik</p>
			</td>
		</tr>
		<tr>
			<td width="167" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
				!=</p>
			</td>
			<td width="303" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Er ulik</p>
			</td>
		</tr>
		<tr>
			<td width="167" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
				&lt;</p>
			</td>
			<td width="303" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Er mindre enn</p>
			</td>
		</tr>
		<tr>
			<td width="167" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
				&lt;=</p>
			</td>
			<td width="303" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Er mindre enn eller lik</p>
			</td>
		</tr>
		<tr>
			<td width="167" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
				!&lt;</p>
			</td>
			<td width="303" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Er ikke mindre enn</p>
			</td>
		</tr>
		<tr>
			<td width="167" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
				&gt;</p>
			</td>
			<td width="303" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Er st&oslash;rre enn</p>
			</td>
		</tr>
		<tr>
			<td width="167" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
				&gt;=</p>
			</td>
			<td width="303" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Er st&oslash;rre enn eller lik</p>
			</td>
		</tr>
		<tr>
			<td width="167" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
				!&gt;</p>
			</td>
			<td width="303" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Er ikke st&oslash;rre enn</p>
			</td>
		</tr>
		<tr>
			<td width="167" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
				BETWEEN ... AND ...</p>
			</td>
			<td width="303" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Er mellom to verdier</p>
			</td>
		</tr>
		<tr>
			<td width="167" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
				IS NULL</p>
			</td>
			<td width="303" style="border-top: none; border-bottom: 1px solid #b2b2b2; border-left: 1px solid #b2b2b2; border-right: 1px solid #b2b2b2; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Er et tomt felt, dvs. er NULL, ingen verdi er satt</p>
			</td>
		</tr>
	</table>
</center>
<p class="western"><br/>
<br/>

</p>
<h3 class="western" style="line-height: 140%"><a name="__RefHeading___Toc4499_762629072"></a>
Flere eksempler p&aring; filtrering</h3>
<h4 class="western"><a name="__RefHeading___Toc15459_3971551474"></a><strong>Filtrere
etter en gitt verdi</strong></h4>
<pre class="western"><strong><span style="font-weight: normal">SELECT * FROM salaries</span></strong>
<strong><span style="font-weight: normal">WHERE salary &gt; 155000</span></strong>
<strong><span style="font-weight: normal">ORDER BY salary DESC;</span></strong>

+--------+--------+------------+------------+
| emp_no | salary | from_date&nbsp; | to_date&nbsp;&nbsp;&nbsp; |
+--------+--------+------------+------------+
|&nbsp; 43624 | 158220 | 2002-03-22 | 9999-01-01 |
|&nbsp; 43624 | 157821 | 2001-03-22 | 2002-03-22 |
| 254466 | 156286 | 2001-08-04 | 9999-01-01 |
|&nbsp; 47978 | 155709 | 2002-07-14 | 9999-01-01 |
| 253939 | 155513 | 2002-04-11 | 9999-01-01 |
| 109334 | 155377 | 2000-02-12 | 2001-02-11 |
| 109334 | 155190 | 2002-02-11 | 9999-01-01 |
+--------+--------+------------+------------+</pre><h4 class="western">
<a name="__RefHeading___Toc15461_3971551474"></a><strong>Filtrere
etter kolonner som </strong><strong><em>ikke</em></strong><strong>
har en gitt verdi</strong></h4>
<pre class="western"><strong><span style="font-weight: normal">SELECT * FROM salaries</span></strong>
<strong><span style="font-weight: normal">WHERE salary &lt;&gt; 40000 LIMIT 10;</span></strong>

+--------+--------+------------+------------+
| emp_no | salary | from_date&nbsp; | to_date&nbsp;&nbsp;&nbsp; |
+--------+--------+------------+------------+
| 253406 |&nbsp; 38623 | 2002-02-20 | 9999-01-01 |
|&nbsp; 49239 |&nbsp; 38735 | 1996-09-17 | 1997-09-17 |
| 281546 |&nbsp; 38786 | 1996-11-13 | 1997-06-26 |
|&nbsp; 15830 |&nbsp; 38812 | 2001-03-12 | 2002-03-12 |
|&nbsp; 64198 |&nbsp; 38836 | 1989-10-20 | 1990-10-20 |
| 475254 |&nbsp; 38849 | 1993-06-04 | 1994-06-04 |
|&nbsp; 50419 |&nbsp; 38850 | 1996-09-22 | 1997-09-22 |
|&nbsp; 34707 |&nbsp; 38851 | 1990-10-03 | 1991-10-03 |
|&nbsp; 49239 |&nbsp; 38859 | 1995-09-18 | 1996-09-17 |
| 274049 |&nbsp; 38864 | 1996-09-01 | 1997-09-01 |
+--------+--------+------------+------------+</pre><h4 class="western">
<a name="__RefHeading___Toc15463_3971551474"></a><strong>Filtrere
etter en rekke gitte verdier</strong></h4>
<pre class="western"><strong><span style="font-weight: normal">SELECT * FROM salaries</span></strong>
<strong><span style="font-weight: normal">WHERE salary BETWEEN 156000 AND 158000</span></strong>
<strong><span style="font-weight: normal">ORDER BY salary;</span></strong>

+--------+--------+------------+------------+
| emp_no | salary | from_date&nbsp; | to_date&nbsp;&nbsp;&nbsp; |
+--------+--------+------------+------------+
| 254466 | 156286 | 2001-08-04 | 9999-01-01 |
|&nbsp; 43624 | 157821 | 2001-03-22 | 2002-03-22 |
+--------+--------+------------+------------+</pre><h4 class="western">
<a name="__RefHeading___Toc15465_3971551474"></a><strong>Filtrere
etter rader hvor det ikker er satt noen verdi for en kolonne</strong></h4>
<pre class="western"><strong><span style="font-weight: normal">SELECT * FROM salaries</span></strong>
<strong><span style="font-weight: normal">WHERE salary IS NULL;<br/>
</span></strong>
Empty set (0,00 sec)</pre><p class="merk">
<strong>MERK: </strong>Null-verdi (IS NULL) er ikke det samme som at
kolonnen inneholder 0 eller en tom streng, men betyr at kolonnen ikke
inneholder noe data, mao at det ikke er satt noen verdi for kolonnen
i den aktuelle raden.</p>
<h2 class="western"><a name="__RefHeading___Toc9303_974749821"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Kombinerte betingelser med AND, OR og IN</h2>
<p class="western"><strong><span style="font-weight: normal">Vi kan
lage </span></strong><strong><span style="font-weight: normal">avanserte</span></strong><strong><span style="font-weight: normal">
utvelgelser av data ved &aring; kombinere flere </span></strong><strong><b>WHERE</b></strong><strong><span style="font-weight: normal">-betingelser
</span></strong><strong><span style="font-weight: normal">med</span></strong><strong><span style="font-weight: normal">
n&oslash;kkelordene </span></strong><strong><b>AND</b></strong><strong><span style="font-weight: normal">,
</span></strong><strong><b>OR</b></strong><strong><span style="font-weight: normal">
og </span></strong><strong><b>IN</b></strong><strong><span style="font-weight: normal">.</span></strong></p>
<h3 class="western"><a name="__RefHeading___Toc4508_762629072"></a>Bruk
av <b>AND</b></h3>
<p class="western">For &aring; filtrere p&aring; mer enn &eacute;n
kolonne, kan vi koble sammen flere WHERE-betingelser med AND. Vi kan
for eksempel hente navnet p&aring; alle som er f&oslash;dt f&oslash;r
1. januar 1960 og ansatt etter 1. januar 2000 ved &aring; koble disse
to kriteriene sammen med AND, slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT first_name, last_name FROM employees</span></strong>
<strong><span style="font-weight: normal">WHERE birth_date &lt; '1960-01-01'</span></strong>
<strong><b>AND</b></strong><strong><span style="font-weight: normal"> hire_date &gt; '2000-01-01';&nbsp;&nbsp;</span></strong>

+------------+------------+
| first_name | last_name&nbsp; |
+------------+------------+
| Randi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Luit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
| Volkmar&nbsp;&nbsp;&nbsp; | Perko&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
| Xuejun&nbsp;&nbsp;&nbsp;&nbsp; | Benzmuller |
| Shahab&nbsp;&nbsp;&nbsp;&nbsp; | Demeyer&nbsp;&nbsp;&nbsp; |
| Jaana&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Verspoor&nbsp;&nbsp; |
| Jeong&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Boreale&nbsp;&nbsp;&nbsp; |
| Yucai&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Gerlach&nbsp;&nbsp;&nbsp; |
| Hideyuki&nbsp;&nbsp; | Delgrande&nbsp; |
+------------+------------+</pre><h3 class="western">
<a name="__RefHeading___Toc4510_762629072"></a>Bruk av <b>OR</b></h3>
<p class="western">OR er motsatt av AND, og henter ut data som
tilfredsstiller minst ett av flere kriterier. Setningen under henter
info for ansatte i avdelingene d009 og d007, dvs for alle som er
eller har v&aelig;rt ansatt i en av de to avdelingene, sorterer etter
emp_no og begrenser resultatet til 10 rader:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, dept_no FROM dept_emp</span></strong>
<strong><span style="font-weight: normal">WHERE dept_no = 'd009'</span></strong>
<strong><b>OR</b></strong><strong><span style="font-weight: normal"> dept_no = 'd007'</span></strong>
<strong><span style="font-weight: normal">ORDER BY emp_no LIMIT 10; </span></strong>

+--------+---------+
| emp_no | dept_no |
+--------+---------+
|&nbsp; 10002 | d007&nbsp;&nbsp;&nbsp; |
|&nbsp; 10011 | d009&nbsp;&nbsp;&nbsp; |
|&nbsp; 10016 | d007&nbsp;&nbsp;&nbsp; |
|&nbsp; 10034 | d007&nbsp;&nbsp;&nbsp; |
|&nbsp; 10038 | d009&nbsp;&nbsp;&nbsp; |
|&nbsp; 10041 | d007&nbsp;&nbsp;&nbsp; |
|&nbsp; 10049 | d009&nbsp;&nbsp;&nbsp; |
|&nbsp; 10050 | d007&nbsp;&nbsp;&nbsp; |
|&nbsp; 10053 | d007&nbsp;&nbsp;&nbsp; |
|&nbsp; 10060 | d007&nbsp;&nbsp;&nbsp; |
+--------+---------+</pre><p class="western">
Ved bruk av OR vil en rad bli hentet n&aring;r det f&oslash;rste
kriteriet er m&oslash;tt, og ved treff sjekkes som regel ikke de
andre kriteriene i det hele tatt.</p>
<h3 class="western"><a name="__RefHeading___Toc15467_3971551474"></a><strong><span style="font-weight: normal">Kombinasjon
av </span></strong><strong><b>OR</b></strong><strong><span style="font-weight: normal">
og </span></strong><strong><b>AND</b></strong></h3>
<p class="western">Vi kan kombinere betingelser med OR og AND s&aring;
mange ganger vi har behov for i samme SQL-setning. Men rekkef&oslash;lgen
p&aring; betingelsene kan v&aelig;re avgj&oslash;rende for
resultatet. Setter vi opp en SQL-setning som i eksemplet under, kan
vi f&aring; uventede resultater:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT birth_date FROM employees</span></strong>
<strong><span style="font-weight: normal">WHERE hire_date &lt; '1998-01-01' </span></strong><strong><b>OR</b></strong><strong><span style="font-weight: normal"> hire_date &gt; '1995-01-01'</span></strong>
<strong><b>AND</b></strong><strong><span style="font-weight: normal"> birth_date &gt; '1960-01-01' LIMIT 10;</span></strong>

+------------+
| birth_date |
+------------+
| 1953-09-02 |
| 1964-06-02 |
| 1959-12-03 |
| 1954-05-01 |
| 1955-01-21 |
| 1953-04-20 |
| 1957-05-23 |
| 1958-02-19 |
| 1952-04-19 |
| 1963-06-01 |
+------------+</pre><p class="western">
Vi ser at flere av resultatene har f&oslash;dselsdato <strong><em>f&oslash;r</em></strong><strong>
</strong>1. januar 1960. &Aring;rsaken er at <strong>AND</strong>
blir behandlet f&oslash;r <strong>OR</strong>. S&aring; SQL vil tolke
setningen over som &quot;Hent f&oslash;dselsdatoen til alle
medarbeidere som er ansatt f&oslash;r 1. januar 1998 uavhengig av
alder, og hent deretter f&oslash;dselsdatoen til alle medarbeidere
ansatt etter 1. januar 1995 som er f&oslash;dt etter 1. januar 1960,</p>
<p class="western">L&oslash;sningen p&aring; dette problemet er &aring;
bruke <b>parenteser</b> til &aring; knytte sammen riktige
betingelser. Det som st&aring;r inne i en parentes blir behandlet
sammen, f&oslash;r resten av setningen behandles. S&aring; denne
setningen vil gi riktig resultat:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT birth_date FROM employees</span></strong>
<strong><span style="font-weight: normal">WHERE (hire_date &lt; '1998-01-01' OR hire_date &gt; '1995-01-01')</span></strong>
<strong><span style="font-weight: normal">AND birth_date &gt; '1960-01-01' LIMIT 10;</span></strong>

+------------+
| birth_date |
+------------+
| 1964-06-02 |
| 1963-06-01 |
| 1960-10-04 |
| 1963-06-07 |
| 1961-05-02 |
| 1960-02-20 |
| 1962-07-10 |
| 1963-11-26 |
| 1960-08-09 |
| 1962-12-29 |
+------------+</pre><p class="merk">
<strong>MERK:</strong> Det anbefales &aring; bruke parenteser s&aring;
ofte som mulig - det er ingen ulempe/kostnad med parenteser, og de
sikrer at resultatet blir det man forventer.</p>
<h3 class="western"><a name="__RefHeading___Toc4512_762629072"></a>Bruk
av <b>IN</b></h3>
<p class="western">IN brukes til &aring; angi at data kan
tilfredsstille en eller flere av en rekke betingelser, IN etterf&oslash;lges
av en komma-separert liste med betingelser, alle omsluttet av en
parentes. Her er et eksempel:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, dept_no FROM dept_emp</span></strong>
<strong><span style="font-weight: normal">WHERE dept_no </span></strong><strong><b>IN</b></strong><strong><span style="font-weight: normal"> ('d001', 'd002', 'd007') </span></strong>
<strong><span style="font-weight: normal">ORDER BY emp_no LIMIT 10;</span></strong>

+--------+---------+
| emp_no | dept_no |
+--------+---------+
|&nbsp; 10002 | d007&nbsp;&nbsp;&nbsp; |
|&nbsp; 10016 | d007&nbsp;&nbsp;&nbsp; |
|&nbsp; 10017 | d001&nbsp;&nbsp;&nbsp; |
|&nbsp; 10034 | d007&nbsp;&nbsp;&nbsp; |
|&nbsp; 10041 | d007&nbsp;&nbsp;&nbsp; |
|&nbsp; 10042 | d002&nbsp;&nbsp;&nbsp; |
|&nbsp; 10050 | d002&nbsp;&nbsp;&nbsp; |
|&nbsp; 10050 | d007&nbsp;&nbsp;&nbsp; |
|&nbsp; 10053 | d007&nbsp;&nbsp;&nbsp; |
|&nbsp; 10055 | d001&nbsp;&nbsp;&nbsp; |
+--------+---------+</pre><p class="western">
Dette gir akkurat samme resultat som &aring; bruke OR flere ganger,
men er raskere &aring; skrive. En annen fordel med IN er at s&oslash;ket
g&aring;r raskere enn hvis man spesifiserer mange OR-betingelser. Men
den st&oslash;rste fordelen ligger i at man kan erstatte innholdet i
parentesen med et eget SELECT-s&oslash;k, slik at man kan bygge
dynamiske WHERE-setninger. Vi skal se mer p&aring; dette n&aring;r vi
behandler undersp&oslash;rringer. i kapittel 6.</p>
<h3 class="western"><a name="__RefHeading___Toc4514_762629072"></a>Bruk
av <b>NOT</b></h3>
<p class="western">NOT-betingelsen angir rett og slett det motsatte
av det som f&oslash;lger. NOT blir mao aldri brukt alene, men alltid
f&oslash;r en annen betingelse. NOT er derimot den eneste betingelsen
som skrives <em>f&oslash;r</em> kolonnenavnet det skal filtreres p&aring;.
Som for eksempel i denne setningen, som henter informasjon for alle
ansatte som ikke jobber eller har jobbet i avdeling d007 (og
begrenser resultatet til 10 rader):<strong> </strong>
</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, dept_no FROM dept_emp</span></strong>
<strong><span style="font-weight: normal">WHERE </span></strong><strong><b>NOT</b></strong><strong><span style="font-weight: normal"> dept_no = 'd007'</span></strong>
<strong><span style="font-weight: normal">ORDER BY emp_no LIMIT 10;</span></strong><span style="font-weight: normal">&nbsp;</span>

+--------+---------+
| emp_no | dept_no |
+--------+---------+
|&nbsp; 10001 | d005&nbsp;&nbsp;&nbsp; |
|&nbsp; 10003 | d004&nbsp;&nbsp;&nbsp; |
|&nbsp; 10004 | d004&nbsp;&nbsp;&nbsp; |
|&nbsp; 10005 | d003&nbsp;&nbsp;&nbsp; |
|&nbsp; 10006 | d005&nbsp;&nbsp;&nbsp; |
|&nbsp; 10007 | d008&nbsp;&nbsp;&nbsp; |
|&nbsp; 10008 | d005&nbsp;&nbsp;&nbsp; |
|&nbsp; 10009 | d006&nbsp;&nbsp;&nbsp; |
|&nbsp; 10010 | d004&nbsp;&nbsp;&nbsp; |
|&nbsp; 10010 | d006&nbsp;&nbsp;&nbsp; |</pre><p class="western">
<br/>
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc221_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Filtrering med bruk av jokertegn</h2>
<h3 class="western"><a name="__RefHeading___Toc9305_974749821"></a>Bruk
av <b>LIKE</b></h3>
<p class="western">Hittil har vi filtrert etter kjente verdier. Ofte
vet vi ikke eksakt hvilke verdier vi s&oslash;ker etter, og da er
jokertegn eller <b>s&oslash;kem&oslash;nstre</b> redningen. For &aring;
bruke jokertegn m&aring; vi bruke betingelsen <strong>LIKE</strong>.
Dette gir databasesystemet beskjed om at vi n&aring; skal s&oslash;ke
etter et m&oslash;nster og ikke en eller flere bestemte verdier.</p>
<p class="merk"><b>MERK: </b>Jokertegn kan bare brukes med
tekst-kolonner. Man kan ikke s&oslash;ke med jokertegn i tall, datoer
eller andre kolonne-typer.</p>
<h3 class="western"><a name="__RefHeading___Toc15765_604779659"></a>Skille
mellom sm&aring; og store bokstaver ved bruk av jokertegn  
</h3>
<p class="western">De ulike RDBMSene er ikke samstemte i &aring;
skille mellom sm&aring; og store bokstaver  ved bruk av jokertegn.
Oracle og PostgreSQL skiller mellom sm&aring; og store bokstaver,
mens Microsoft SQL Server og MySQL/MariaDB ikke gj&oslash;r det. 
</p>
<p class="western">Hvis du vil gj&oslash;re et s&oslash;k uavhengig
av bokstavst&oslash;rrelsen &ndash; dvs et s&oslash;k som er <i>case
insensitiv &ndash;</i><span style="font-style: normal"> s&aring; kan
du f&aring; dette til p&aring; flere m&aring;ter med Oracle og
PostgreSQL. </span>
</p>
<p class="western"><span style="font-style: normal">Med Po</span><span style="font-style: normal">s</span><span style="font-style: normal">tgreSQL
kan du bruke funksjonen ILIKE istedenfor LIKE. ILIKE angir en (case)
Insensitiv LIKE. </span><span style="font-style: normal">Men det kan
v&aelig;re mer effektivt &aring; konvertere feltet du s&oslash;ker p&aring;
</span><span style="font-style: normal">til enten sm&aring; eller
store bokstaver med en av funksjonene LOWER() eller UPPER() og s&aring;
angi s&oslash;kem&oslash;nstret med sm&aring; eller store bokstaver,
f.eks. slik:</span></p>
<pre class="western">SELECT * from employees where LOWER(last_name) LIKE '%facel%';</pre><p class="western">
<span style="font-style: normal">D</span><span style="font-style: normal">enne
m&aring;ten &aring; gj&oslash;re det p&aring; fungerer ogs&aring; for
Oracle og de fleste andre RDBMSer.</span></p>
<h3 class="western"><a name="__RefHeading___Toc223_487959650"></a>Prosent-tegn
(<b>%</b>)</h3>
<p class="western">Det mest brukte av alle jokertegn er %. I en
s&oslash;kestreng st&aring;r % for: <strong>alle forekomster av alle
tegn. </strong>
</p>
<p class="western">For eksempel kan vi s&oslash;ke etter ansatte med
etternavn som starter p&aring; G, velge ut en av hver (med DISTINCT)
og sortere dem etter etternavn, slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT DISTINCT last_name FROM employees WHERE last_name LIKE 'G%' </span></strong>
<strong><span style="font-weight: normal">ORDER BY last_name LIMIT 5; <br/>
</span></strong>
<strong><span style="font-weight: normal">+------------+ <br/>
| last_name &nbsp;| <br/>
+------------+ <br/>
| Gadepally &nbsp;| <br/>
| Gajiwala &nbsp;&nbsp;| <br/>
| Gammage &nbsp;&nbsp;&nbsp;| <br/>
| Gargeya &nbsp;&nbsp;&nbsp;| <br/>
| Garigliano | <br/>
+------------+</span></strong></pre><p class="western">
%-tegnet kan st&aring; i begynnelsen, slutten eller midt i
s&oslash;kesetningen, og du kan bruke flere %-tegn hvis n&oslash;dvendig.</p>
<p class="merk"><strong>MERK: </strong><strong><span style="font-weight: normal">S&oslash;king
etter tekst kombinert med </span></strong><strong>%</strong><strong><span style="font-weight: normal">-tegnet
skiller i noen databaser mellom store og sm&aring; bokstaver og i
andre ikke. Er du i tvil kan du f.eks. konvertere s&oslash;kefeltet</span></strong><strong>
</strong><strong><span style="font-weight: normal">til bare sm&aring;
bokstaver med funksjonen </span></strong><strong><b>lower() </b></strong><strong><span style="font-weight: normal">og
bruke sm&aring; bokstaver i s&oslash;kesetningen</span></strong><strong><b>,
f.eks. slik:</b></strong></p>
<p class="merk"><strong><span style="font-weight: normal">SELECT
emp_no, first_name, last_name FROM employees </span></strong><strong><span style="font-weight: normal">WHERE
lower(last_name) LIKE 'g%';</span></strong></p>
<p class="merk">Hvis du bruker Microsoft Access kan det hende at du
m&aring; bruke * istedenfor %.</p>
<p class="western">F&oslash;lgende s&oslash;k henter de 5 f&oslash;rste
radene med ansatte med navn som begynner p&aring; F og slutter p&aring;
y:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, first_name, last_name FROM employees &nbsp;<br/>
WHERE last_name LIKE 'F%y' <br/>
ORDER BY last_name, first_name LIMIT 5; </span></strong>
<strong><span style="font-weight: normal"><br/>
+--------+------------+-----------+ <br/>
| emp_no | first_name | last_name | <br/>
+--------+------------+-----------+ <br/>
| 212799 | Abdelkader | Falby &nbsp;&nbsp;&nbsp;&nbsp;| <br/>
| 488208 | Aiichiro &nbsp;&nbsp;| Falby &nbsp;&nbsp;&nbsp;&nbsp;| <br/>
| 207608 | Alain &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Falby &nbsp;&nbsp;&nbsp;&nbsp;| <br/>
| 283261 | Aleksander | Falby &nbsp;&nbsp;&nbsp;&nbsp;| <br/>
| 203729 | Anneli &nbsp;&nbsp;&nbsp;&nbsp;| Falby &nbsp;&nbsp;&nbsp;&nbsp;| <br/>
+--------+------------+-----------+</span></strong></pre><h3 class="western">
<a name="__RefHeading___Toc225_487959650"></a>Understrekingstegn <b>(_</b>)</h3>
<p class="western">Et annet mye brukt jokertegn er
understrekingstegnet (_). Det brukes akkurat likt %-tegnet, men
gjelder bare for ett tegn.</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT DISTINCT title FROM titles <br/>
WHERE title LIKE '___ior engineer'; <br/>
</span></strong>
<strong><span style="font-weight: normal">+-----------------+ <br/>
| title &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
+-----------------+ <br/>
| Senior Engineer | <br/>
+-----------------+</span></strong></pre><p class="western">
S&oslash;ket over vil hente titler som <i><b>junior engineer</b></i>
eller <i><b>senior engineer</b></i> siden vi ber spesifikt om 3 tegn
(___) som kan v&aelig;re hva som helst, etterfulgt av engineer. I
v&aring;rt datasett har vi bare Senior Engineer som matcher s&oslash;ket.
Vi har ogs&aring; effektivt silt ut evt. ingeni&oslash;rer av typen:
Anterior, Behavior, Exterior, Inferior, Interior, Superior eller
Ulterior (og andre som har f&aelig;rre eller flere enn 3 tegn f&oslash;r
engineer).</p>
<p class="merk"><strong>MERK: </strong>Hvis du bruker Microsoft
Access kan det hende at du m&aring; bruke ? istedenfor _.</p>
<h3 class="western"><a name="__RefHeading___Toc227_487959650"></a>Rette
klammer (<b>[ ]</b>)</h3>
<p class="western">Rette klammer brukes til &aring; spesifisere et
sett av tegn, som alle m&aring; v&aelig;re likt tilsvarende tegn, i
tilsvarende posisjon inne i klammene. For eksempel, for &aring; finne
alle ansatte med navn som begynner med bokstaven J eller M, kan man
skrive denne setningen (som begrenser resultatet til de 5 f&oslash;rste
radene av resultatet):</p>
<pre class="western"><strong><span style="font-weight: normal">1&gt; </span></strong><strong><span style="font-weight: normal">SELECT DISTINCT TOP 5 last_name </span></strong>
<strong><span style="font-weight: normal">FROM employees WHERE last_name LIKE '[JM]%'; <br/>
</span></strong>
<strong><span style="font-weight: normal">2&gt; go <br/>
</span></strong>
<strong><span style="font-weight: normal">last_name &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
---------------- <br/>
Maliniak &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Montemayor &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Joslin &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Merlo &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Makrucki &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></strong></pre><p class="merk">
<strong>MERK: </strong>Rette klammer anerkjennes ikke av alle
databasesystemer. Spesifikt anerkjennes rette klammer av<strong>
Microsoft Access</strong> og <strong>Microsoft SQL-server</strong></p>
<h2 class="western"><a name="__RefHeading___Toc14626_541183064"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Fullteksts&oslash;k</h2>
<p class="western">Fullteksts&oslash;k er s&oslash;k i tekstfelt hvor
det tas hensyn til spr&aring;ket det s&oslash;kes i. For eksempel kan
man s&oslash;ke i en norsk tekst, og s&aring; vet databasen hvordan
norsk spr&aring;k i er strukturert (i hovedtrekk). Det vil si det
DBMSen gj&oslash;r er &aring;  luke ut s&aring;kalte &laquo;stop
words&raquo;, som f.eks. &laquo;i, over, under, som, hvis, p&aring;,
noen&raquo; og en rekke andre vanlige sm&aring;ord som man vanligvis
ikke s&oslash;ker p&aring;. I tillegg foretas en &laquo;stemming&raquo;
av s&oslash;keordene, dvs. det lages en stamme av ordet, slik at man
f&aring;r med ulike varianter ordet kan opptre i, dvs. at det tas
hensyn til flertalls-endelser, verb-b&oslash;yninger osv. Og man kan
ogs&aring; f&aring; treff p&aring; synonymer til s&oslash;keordene.
Fullteksts&oslash;k er en del av det som kalles <b>Natural Language
Processing (NLP)</b>, som er en egen kunstart i seg selv. Og for &aring;
ta det med det samme: NLP er ikke p&aring; noen m&aring;te
perfeksjonert enn&aring;, og som vi skal se er det stort rom for
forbedringer i hvordan databasene tolker f.eks. norsk spr&aring;k.
Men det er likevel en nyttig funksjon som kan forbedre
s&oslash;keresultatene betraktelig hvis du s&oslash;ker i st&oslash;rre
mengder tekst. 
</p>
<h3 class="western"><a name="__RefHeading___Toc14628_541183064"></a>Fullteksts&oslash;k
med PostgreSQL</h3>
<p class="western">PostgreSQL har en innstilling som heter 
<b>default_text_search_config </b><span style="font-weight: normal">
og som viser hvilket spr&aring;k databasen er satt opp med til
fullteksts&oslash;k. Du kan f&aring; frem default-innstillingen med
denne SQL-setningen:</span></p>
<pre class="western">select name, setting from pg_settings where name= 'default_text_search_config';

            name            |      setting       
----------------------------+--------------------
 default_text_search_config | pg_catalog.english 
</pre><p class="western">
Som vi ser er denne databasen satt opp med engelsk som default spr&aring;k.
</p>
<p class="western">I eksemplet nedenfor s&oslash;ker vi i en tabell
som heter &laquo;kontakter&raquo;. Tabellen har et felt &laquo;fornavn&raquo;
og et felt &laquo;notater&raquo;. For raden hvor feltet &laquo;fornavn&raquo;
har verdien &laquo;Terje&raquo; inneholder feltet &laquo;notater&raquo;
denne teksten (tilfeldig sakset fra en artikkel om tilbakebetaling av
skatt):</p>
<p class="western"><i>&laquo;Til sammen 28 mrd. kroner skal
tilbakebetales, og de som har penger til gode, f&aring;r dem utbetalt
innen tre uker fra i dag. De aller fleste f&aring;r pengene p&aring;
konto oppgj&oslash;rsdatoen.&raquo;</i></p>
<p class="western"> Dette er resultatet n&aring;r vi s&oslash;ker
etter tekst i feltet &laquo;notater&raquo; som inneholder ordet
&laquo;hver&raquo;:</p>
<pre class="western">select fornavn from kontakter 
where to_tsvector(notater) @@ to_tsquery('hver');

 fornavn 
---------
(0 rows)</pre><p class="western" style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
<br/>

</p>
<p class="western">Vi har her brukt to fullteksts&oslash;k-funksjoner:
<b>to_tsvector()</b> og <b>to_tsquery(), </b><span style="font-weight: normal">bundet
sammen med to kr&oslash;llalfaer: </span><b>@@</b>. Den f&oslash;rste
funksjonen konverterer feltet notater ved bl.a. &aring; gjennomf&oslash;re
en &laquo;stemming&raquo; av ordene, dvs trekke ut ordenes stamme,
noe som gj&oslash;r dem om til s&aring;kalte &laquo;leksemer&raquo;
eller s&oslash;kbare ord, samt &aring; luke ut &laquo;stop words&raquo;
- sm&aring;ord som man sjelden s&oslash;ker etter, slik som &laquo;&aring;&raquo;,
&laquo;man&raquo;, &laquo;en&raquo;, &laquo;et&raquo; osv.. Den andre
funksjonen angir s&oslash;keordet eller s&oslash;keordene vi leter
etter.</p>
<p class="western">Vi f&aring;r ingen treff, og ingen advarsler om at
ordet &laquo;hver&raquo; er et s&aring;kalt &laquo;stop word&raquo;.
S&aring; vi setter s&oslash;kespr&aring;ket over til norsk, og
fors&oslash;ker igjen:</p>
<pre class="western">set default_text_search_config TO norwegian;
SET

select fornavn from kontakter 
where to_tsvector(notater) @@ to_tsquery('hver');

NOTICE:  text-search query contains only stop words or doesn't contain lexemes, ignored </pre><p class="western">
Denne gangen f&aring;r vi beskjed om at s&oslash;keordet &laquo;hver&raquo;
er et &laquo;stop word&raquo;, og at s&oslash;ket dermed ikke
inneholder noen s&oslash;kbare &laquo;leksemer&raquo;. S&aring; vi
legger til et s&oslash;keord til og ber om &aring; s&oslash;ke etter
tekst som inneholder begge ordene, slik:</p>
<pre class="western">select fornavn from kontakter 
where to_tsvector(notater) @@ to_tsquery('hver &amp; uker');

 fornavn 
---------
 Terje
(1 row)</pre><p class="western">
Denne gangen f&aring;r vi ett treff, siden feltet notater i raden
hvor fornavn er Terje inneholder order &laquo;uker&raquo;. Vi f&aring;r
treff selv om teksten ikke inneholder order &laquo;hver&raquo;, siden
det er definert som et &laquo;stop word&raquo; og derfor ignoreres.</p>
<p class="western">Vil vi s&oslash;ke etter tekst som inneholder
minst ett av s&oslash;keordene, kan vi liste opp ordene med
r&oslash;r-tegnet <b>|</b>  mellom, for eksempel slik:</p>
<pre class="western">select fornavn from kont where 
to_tsvector(notater) @@ to_tsquery('to | tre | fire'); 
<br/>
fornavn<br/>
--------- <br/>
Terje</pre><p class="western">
Setningen over s&oslash;ker i feltet notater etter tekst som
inneholder ett av ordene &laquo;to&raquo;, &laquo;tre&raquo; eller
&laquo;fire&raquo;<br/>
<br/>
<br/>

</p>
<p class="western">Vi kan ogs&aring; s&oslash;ke p&aring; en setning
eller en del av en setning ved &aring; angi at vi vil s&oslash;ke p&aring;
ord som f&oslash;lger etter hverandre. Det gj&oslash;r vi ved &aring;
sette dette tegnet mellom ordene: <b>&lt;-&gt;</b><span style="font-weight: normal">,
</span><span style="font-weight: normal">for eksempel slik:</span></p>
<pre class="western">select fornavn from kontakter 
where to_tsvector(notater) @@ to_tsquery('f&aring;r &lt;-&gt; dem &lt;-&gt; utbetalt');<br/>
 
fornavn 
---------
 Terje</pre><p class="western" style="font-style: normal; font-weight: normal">
PostgreSQL vil tolke s&oslash;kestrengen over som: S&oslash;k etter
ordet &laquo;f&aring;r&raquo; etterfulgt av ordet &laquo;dem&raquo;
etterfulgt av ordet &laquo;utbetalt&raquo;. Ordene m&aring; komme
rett etter hverandre, uten noen andre ord imellom. Vi kan angi at det
skal komme ett eller flere ord mellom hvert s&oslash;keord ved &aring;
erstatte bindestreken mellom &lt; og &gt; med et tall.  Tallet 1
angir det samme som bindestreken, dvs. at ordene f&oslash;lger rett
p&aring; hverandre, mens tallet 2 angir at det skal v&aelig;re ett
ord mellom s&oslash;keordene, tallet 3 at det skal v&aelig;re to ord
mellom s&oslash;keordene osv.</p>
<p class="western" style="font-style: normal; font-weight: normal">En
variant av s&oslash;ket over som tillater at det st&aring;r ett
vilk&aring;rlig ord mellom f&aring;r og utbetalt, vil m.a.o. se slik
ut:</p>
<pre class="western">select fornavn from kontakter 
where to_tsvector(notater) @@ to_tsquery('f&aring;r &lt;2&gt; utbetalt'); <br/>

fornavn<br/>
--------- <br/>
Terje</pre><p class="western">
<span style="font-style: normal"><span style="font-weight: normal">D</span></span><span style="font-style: normal"><span style="font-weight: normal">ersom
vi s&oslash;ker etter deler av setninger, dvs. uten noen mulige ord
mellom ordene i s&oslash;kesetningen, kan vi  forenkle skrivem&aring;ten
ved &aring; bruke fulltekst-funksjonen </span></span><b>phraseto_tsquery</b><b>()</b><span style="font-weight: normal">,
f.eks. slik: </span>
</p>
<pre class="western">select fornavn from kontakter 
where to_tsvector(notater) @@ <b>phraseto_tsquery(</b>'f&aring;r dem utbetalt'<b>)</b>;
<br/>
fornavn<br/>
--------- <br/>
Terje <br/>
(1 row)</pre><p class="western" style="font-style: normal; font-weight: normal">
Vi kan kombinere ulike betingelser, for eksempel slik:</p>
<pre class="western">select fornavn from kontakter 
where to_tsvector(notater) @@ to_tsquery('to &lt;-&gt; uker | tre &lt;-&gt; uker | fire &lt;-&gt; uker');
<br/>
fornavn <br/>
--------- <br/>
Terje</pre><p class="western" style="font-style: normal; font-weight: normal">
Setningen over s&oslash;ker etter tekst i feltet notater som
inneholder &laquo;to uker&raquo;, &laquo;tre uker&raquo; eller &laquo;fire
uker&raquo;</p>
<p class="western" style="font-style: normal; font-weight: normal">S&oslash;ker
vi p&aring; ordet &laquo;oppgj&oslash;rsdato&raquo; ser vi at vi f&aring;r
treff p&aring; ordet &laquo;oppgj&oslash;rsdatoen&raquo;, siden det
er ordets stamme vi s&oslash;ker etter:</p>
<pre class="western">select fornavn from kontakter 
where to_tsvector(notater) @@ to_tsquery('oppgj&oslash;rsdato');

 fornavn 
---------
 Terje</pre><p class="western">
Men s&oslash;ker vi p&aring; order &laquo;uke&raquo; f&aring;r vi
ikke treff, selv om feltet inneholder ordet &laquo;uker&raquo;:</p>
<pre class="western">select fornavn from kontakter 
where to_tsvector(notater) @@ to_tsquery('uke');

 fornavn 
---------
(0 rows)</pre><p class="western">
Med andre ord er ikke &laquo;stemmingen&raquo; perfekt enn&aring;.
Men dette er en funksjonalitet som det er verdt &aring; l&aelig;re
seg, for den blir stadig mer treffsikker for hver versjon av
RDBMSene.</p>
<h3 class="western"><a name="__RefHeading___Toc14630_541183064"></a>Fullteksts&oslash;k
med Microsoft SQL-server 
</h3>
<p class="western">TO DO .....</p>
<p class="western">Vi skal se hvordan fulltekst-s&oslash;k fungerer
med SQL-server ved &aring; s&oslash;ke i et felt som heter <b>notater</b>
etter ord og fraser i denne teksten som matcher et s&oslash;kekriterium.
Her er teksten i feltet notater, som vi skal s&oslash;ke i:</p>
<p class="western"><i>&laquo;Til sammen 28 mrd. kroner skal
tilbakebetales, og de som har penger til gode, f&aring;r dem utbetalt
innen tre uker fra i dag. De aller fleste f&aring;r pengene p&aring;
konto oppgj&oslash;rsdatoen.&raquo;</i></p>
<p class="western" style="font-style: normal">Dersom vi f&aring;r
treff p&aring; s&oslash;ket returneres fornavnet til personen notatet
er knyttet til.</p>
<p class="western" style="font-style: normal">Vi m&aring; f&oslash;rst
sette opp SQL-serveren til &aring; h&aring;ndtere fullteksts&oslash;k.
Det gj&oslash;res i f&oslash;lgende to trinn:</p>
<ol>
	<li><p class="western" style="font-style: normal">Opprette en
	fulltekst-katalog i databasen<br/>
<br/>
For eksempel kan vi
	opprette en fulltekst-katalog i databasen &laquo;Publikasjoner&raquo;
	slik:</p>
</ol>
<pre class="western"><code class="western">CREATE FULLTEXT CATALOG </code><code class="western">Publikasjoner</code><code class="western">DocFTCat; </code></pre>
<ol start="2">
	<li><p class="western" align="left" style="font-style: normal">Opprette
	en fulltekst-indeks p&aring; tabell-feltet du vil gj&oslash;re s&oslash;ket
	p&aring;.</p>
</ol>
<p class="western" align="left"><span style="font-style: normal">F&oslash;rst
m&aring; vi s&oslash;rge for at vi har en indeks p&aring; et unikt
felt som ikke inneholder null-</span><span style="font-style: normal">verdier</span><span style="font-style: normal">
(hvis vi ikke har det fra f&oslash;r):</span></p>
<pre class="western"><code class="western">CREATE UNIQUE INDEX ui_</code><code class="western">ID</code><code class="western"> ON </code><code class="western">Publikasjoner</code><code class="western">.</code><code class="western">artikler</code><code class="western">(</code><code class="western">artikkelID</code><code class="western">);</code></pre>
<ol start="2">
	<p class="western"><span style="font-style: normal">S&aring;</span><span style="font-style: normal">
	kan </span><span style="font-style: normal">vi </span><span style="font-style: normal">opprette
	en fulltekst-indeks p&aring; feltet &laquo;</span><span style="font-style: normal">notater</span><span style="font-style: normal">&raquo;
	i tabellen &laquo;artikler&raquo; slik:</span></p>
</ol>
<pre class="western"><code class="western"><span style="font-style: normal">CREATE FULLTEXT INDEX ON </span></code><code class="western"><span style="font-style: normal">Publikasjoner</span></code><code class="western"><span style="font-style: normal">.</span></code><code class="western"><span style="font-style: normal">artikler</span></code><code class="western"><span style="font-style: normal">  </span></code>
<code class="western">( </code><code class="western">notater</code><code class="western">                     -- Full-text inde</code><code class="western">ksens</code><code class="western"> </code><code class="western">kolonnenavn</code><code class="western">   </code>
<code class="western">  </code><code class="western">T</code><code class="western">YPE COLUMN FileExtension    -- Na</code><code class="western">vn</code><code class="western"> </code><code class="western">p&aring;</code><code class="western"> </code><code class="western">kolonnen</code><code class="western"> </code><code class="western">som inneholder 						   informasjon om</code><code class="western"> fi</code><code class="western">ltype</code>
<code class="western">  </code><code class="western">Language 2057                -- 2057 </code><code class="western">er</code><code class="western"> LCID for Britis</code><code class="western">k</code><code class="western"> Eng</code><code class="western">elsk</code><code class="western">  </code>
<code class="western">)  </code>
<code class="western">KEY INDEX ui_ukDoc ON AdvWksDocFTCat --Unique inde</code><code class="western">ks</code><code class="western">  </code>
<code class="western">WITH CHANGE_TRACKING AUTO            --Population type;  </code>
<code class="western">GO  </code></pre>
<ol start="3">
	<li><p class="western" style="font-style: normal">to do...</p>
</ol>
<p class="western" style="font-style: normal"><br/>
<br/>

</p>
<p class="western" style="font-style: normal"><br/>
<br/>

</p>
<p class="merk"><span style="font-style: normal"><b>MERK:</b></span><span style="font-style: normal">
Navnet vi gir katalogen og indeksen velger vi selv, men det kan v&aelig;re
smart &aring; gi dem navn som henspeiler p&aring; hva de er og hvilke
databaser/tabeller/felt de er knyttet til.</span></p>
<p class="western" align="left" style="font-style: normal"><br/>
<br/>

</p>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc13177_1590063026"></a>
<strong><font size="6" style="font-size: 24pt">Kapittel</font></strong><strong><font size="6" style="font-size: 24pt">
4</font></strong><strong><br/>
</strong><strong>F</strong><strong>unksjoner
og <br/>
</strong><strong>b</strong><strong>eregnede </strong><strong>kolonner</strong></h1>
<h2 class="western"><a name="__RefHeading___Toc231_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Beregnede kolonner</h2>
<p class="western">Data lagret i en database er ikke alltid i den
formen vi &oslash;nsker. For eksempel kan fornavn og etternavn v&aelig;re
lagret i to ulike kolonner i databasen (som de burde v&aelig;re),
mens programmet som skriver ut adresser kanskje vil ha hele navnet i
&eacute;n kolonne. SQL har heldigvis funksjoner som kan lage nye
kolonner basert p&aring; eksisterende kolonner, og hvor du ogs&aring;
kan skj&oslash;te dette sammen med tekst du setter inn via
SQL-setningen. Som vi skal se kan vi ogs&aring; gj&oslash;re enkle
utregninger med tallkolonner, som f.eks. &aring; dele en &aring;rsl&oslash;nn
p&aring; 12 for &aring; hente ut en m&aring;nedsl&oslash;nn, gange
pris med antall for &aring; hente ut en ordreverdi osv.</p>
<h2 class="western"><a name="__RefHeading___Toc233_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Skj&oslash;te sammen kolonner</h2>
<p class="western"><strong><span style="font-weight: normal">Syntaksen
for &aring; skj&oslash;te sammen kolonner med tekst og/eller andre
kolonner varierer dessverre mellom de ulike RDBMSene.</span></strong></p>
<p class="western">Her er et enkelt eksempel som setter sammen to
kolonner til &eacute;n, og setter inn et mellomrom mellom kolonnene:</p>
<h3 class="western"><a name="__RefHeading___Toc235_487959650"></a><strong><span style="font-weight: normal">Microsoft
SQL-server</span></strong></h3>
<pre class="western"><strong><span style="font-weight: normal">SELECT TOP 5 first_name + ' ' + last_name AS Navn &nbsp;<br/>
FROM employees ORDER BY Navn; <br/>
 <br/>
Navn &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
------------------------------- <br/>
Aamer Anger &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Aamer Armand &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Aamer Azevdeo &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Aamer Azuma &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Aamer Baak &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></strong></pre><h3 class="western">
<a name="__RefHeading___Toc237_487959650"></a><strong><span style="font-weight: normal">O</span></strong><strong><span style="font-weight: normal">racle</span></strong></h3>
<p class="western">Med Oracle skrives den samme SQL-setningen med ||
istedenfor + :</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT first_name || ' ' || last_name </span></strong><strong><span style="font-weight: normal">Navn</span></strong><strong><span style="font-weight: normal"> </span></strong>
<strong><span style="font-weight: normal">FROM employees </span></strong><strong><span style="font-weight: normal">WHERE rownum&lt;=5</span></strong><strong><span style="font-weight: normal"><br/>
ORDER BY </span></strong><strong><span style="font-weight: normal">Navn</span></strong><strong><span style="font-weight: normal">;</span></strong>

<strong><span style="font-weight: normal">NAVN</span></strong>
<strong><span style="font-weight: normal">----------------------</span></strong>
<strong><span style="font-weight: normal">Aamod Michaels</span></strong>
<strong><span style="font-weight: normal">Bouchung Remmers</span></strong>
<strong><span style="font-weight: normal">Rafail Beutelspacher</span></strong>
<strong><span style="font-weight: normal">Siddarth Ratnakar</span></strong>
<strong><span style="font-weight: normal">Vishwani Linares </span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Eller s&aring; kan du bruke
funksjonen concat(), slik:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT concat(first_name,last_name) </span></strong><strong><span style="font-weight: normal">Navn</span></strong><strong><span style="font-weight: normal"> </span></strong>
<strong><span style="font-weight: normal">FROM employees  </span></strong><strong><span style="font-weight: normal">WHERE rownum&lt;=5</span></strong>
<strong><span style="font-weight: normal">ORDER BY </span></strong><strong><span style="font-weight: normal">Navn</span></strong><strong><span style="font-weight: normal">;</span></strong>

<strong><span style="font-weight: normal">NAVN</span></strong>
<strong><span style="font-weight: normal">----------------------</span></strong>
<strong><span style="font-weight: normal">Aamod Michaels</span></strong>
<strong><span style="font-weight: normal">Bouchung Remmers</span></strong>
<strong><span style="font-weight: normal">Rafail Beutelspacher</span></strong>
<strong><span style="font-weight: normal">Siddarth Ratnakar</span></strong>
<strong><span style="font-weight: normal">Vishwani Linares </span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Med funksjonen</span></strong><strong>
concat() </strong><strong><span style="font-weight: normal">kan du
med Oracle skj&oslash;te sammen felt med andre felt eller tekst ved &aring;
sette komma mellom hver del (felt eller tekst) og sette tekst-delene
i anf&oslash;rselstegn. Men du kan bare skj&oslash;te sammen to deler
av gangen. Er dette to felt, settes det automatisk inn et mellomr</span></strong><strong><span style="font-weight: normal">o</span></strong><strong><span style="font-weight: normal">m
mellom disse. Vil du skj&oslash;te sammen flere enn to deler, kan du
n&oslash;ste flere concat()-funksjoner inne i hverandre, f.eks. slik:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT concat('Fornavn: ',concat(first_name,concat('Etternavn: ',last_name))) </span></strong><strong><span style="font-weight: normal">Navn</span></strong><strong><span style="font-weight: normal"> &nbsp;<br/>
FROM employees WHERE rownum&lt;</span></strong><strong><span style="font-weight: normal">=5</span></strong><strong><span style="font-weight: normal"> <br/>
ORDER BY </span></strong><strong><span style="font-weight: normal">Navn</span></strong><strong><span style="font-weight: normal">;<br/>
<br/>
</span></strong><strong><span style="font-weight: normal">Navn</span></strong><strong><span style="font-weight: normal"> <br/>
----------------------------------------- <br/>
Fornavn: Aamod Etternavn: Michaels <br/>
Fornavn: Bouchung Etternavn: Remmers <br/>
Fornavn: Rafail Etternavn: Beutelspacher <br/>
Fornavn: Siddarth Etternavn: Ratnakar <br/>
Fornavn: Vishwani Etternavn: Linares </span></strong></pre><p class="merk">
<strong>MERK: </strong>Med Oracle bruker man ikke ordet <em><b>AS</b></em><em>
</em>mellom kolonnenavn og alias, men skriver bare f.eks.; SELECT
first_name fornavn FROM ... og alts&aring; <i>ikke </i>SELECT
first_name AS fornavn FROM ...<br/>
Noen versjoner av Oracle kan
imidlertid tillate bruk av<b> </b><b>as</b><b> </b><span style="font-weight: normal">med</span>
feltnavn, men ikke med tabellnavn.</p>
<h3 class="western"><a name="__RefHeading___Toc239_487959650"></a><strong><span style="font-weight: normal">MySQL/MariaDB</span></strong></h3>
<p class="western"><strong><span style="font-weight: normal">MySQL/MariaDB
</span></strong><strong><span style="font-weight: normal">bruker
</span></strong><strong><span style="font-weight: normal">funksjonen</span></strong><strong>
concat() </strong><strong><span style="font-weight: normal">til &aring;
skj&oslash;te sammen feltnavn og tekst (et mellomr</span></strong><strong><span style="font-weight: normal">o</span></strong><strong><span style="font-weight: normal">m
er ogs&aring; &aring; regne som tekst) ved &aring; sette komma mellom
hver del (felt eller tekst) </span></strong><strong><span style="font-weight: normal">-</span></strong><strong><span style="font-weight: normal">
</span></strong><strong><span style="font-weight: normal">men ikke
etter den siste -</span></strong><strong><span style="font-weight: normal">
og sette tekst-delene i anf&oslash;rselstegn.  </span></strong>Syntaksen
blir dermed slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT concat(first_name,' ',last_name) AS </span></strong><strong><span style="font-weight: normal">Navn</span></strong><strong><span style="font-weight: normal"> </span></strong>
<strong><span style="font-weight: normal">FROM employees<br/>
ORDER BY </span></strong><strong><span style="font-weight: normal">Navn LIMIT 5</span></strong><strong><span style="font-weight: normal">;</span></strong>

<strong><span style="font-weight: normal">+---------------+ <br/>
| Navn &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
+---------------+ <br/>
| Amer Anger &nbsp;&nbsp;| <br/>
| Aamer Armand &nbsp;| <br/>
| Aamer Azevdeo | <br/>
| Aamer Azuma &nbsp;&nbsp;| <br/>
| Aamer Baak &nbsp;&nbsp;&nbsp;| <br/>
+---------------+</span></strong></pre><p class="merk">
<strong><b>MERK:</b></strong><strong><span style="font-weight: normal">
T</span></strong><strong><span style="font-weight: normal">il
forskjell fra concat() med Oracle m&aring; vi </span></strong><strong><span style="font-weight: normal">n&aring;r
vi bruker concat() </span></strong><strong><span style="font-weight: normal">med
MySQL/MariaDB sette inn mellomrommet manuelt. </span></strong>
</p>
<h3 class="western"><a name="__RefHeading___Toc241_487959650"></a><strong><span style="font-weight: normal">PostgreSQL</span></strong></h3>
<p class="western">Med PostgreSQL kan vi velge mellom denne syntaksen
(samme som MySQL/MariaDB):</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT concat(first_name,' ',last_name) AS Navn &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
FROM employees &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
ORDER BY Navn LIMIT 5; <br/>
</span></strong>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight: normal">navn &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
--------------------- <br/>
Abdelaziz Alencar <br/>
Abdelaziz Ananiadou <br/>
Abdelaziz Anick <br/>
Abdelaziz Assaf <br/>
Abdelaziz Atrawala<br/>
</span></strong></pre><p class="western">
og denne (samme som Oracle, men med valgfri AS f&oslash;r aliaset):</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT first_name || ' ' || last_name AS Navn &nbsp;<br/>
FROM employees </span></strong>
<strong><span style="font-weight: normal">ORDER BY Navn LIMIT 5; </span></strong>
<strong><span style="font-weight: normal"><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navn &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
--------------------- <br/>
Abdelaziz Alencar <br/>
Abdelaziz Ananiadou <br/>
Abdelaziz Anick <br/>
Abdelaziz Assaf <br/>
Abdelaziz Atrawala</span></strong></pre><h2 class="western">
<a name="__RefHeading___Toc243_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Bruk av aliaser</h2>
<p class="western">Som vi ser av eksemplene ovenfor har vi brukt et
<b>alias</b> for den sammenskj&oslash;tede kolonnen: <strong>fullname.</strong></p>
<p class="western">Aliaser er mye brukt n&aring;r vi henter beregnede
data, eller bare for &aring; gi kolonnen et mer anvendelig navn. Uten
bruk av alias vil databasesystemet gi et kolonnenavn som enten er lik
kolonnenavnet slik det er lagret i tabellstrukturen eller dersom
kolonnen er resultat av en funksjon eller et uttrykk s&aring; kan
funksjonen eller formelen som resulterte i kolonnen eller noe annet
bli brukt som kolonnenavn. Uten alias kan f.eks. resultatet se slik
ut med PostgreSQL:</p>
<pre class="western">SELECT first_name || ' ' || last_name FROM employees LIMIT 3;

    ?column?    
----------------
 Georgi Facello
 Bezalel Simmel
 Parto Bamford
(3 rows)</pre><p class="western">
og slik med MySQL / MariaDB:</p>
<pre class="western">SELECT concat(first_name,' ' ,last_name) FROM employees LIMIT 3;

+-----------------------------------+
| concat(first_name,' ' ,last_name) |
+-----------------------------------+
| Georgi Facello                    |
| Bezalel Simmel                    |
| Parto Bamford                     |
+-----------------------------------+</pre><p class="western">
<br/>
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc245_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Kalkulerte kolonner</h2>
<p class="western">Vi kan opprette nye, beregnede kolonner ved &aring;
utf&oslash;re kalkulasjoner p&aring; eksisterende kolonner, f.eks.
ved &aring; multiplisere en kolonne (pris) med en annen (antall) for
&aring; beregne en ordreverdi, eller dele &aring;rsl&oslash;nn p&aring;
12 for &aring; regne ut m&aring;nedsl&oslash;nn. Her er en SQL
setning som gj&oslash;r det siste:</p>
<h3 class="western"><a name="__RefHeading___Toc16212_413252541"></a>Kalkulerte
kolonner med MySQL / MariaDB og PostgreSQL:</h3>
<pre class="western" style="font-weight: normal"><font color="#000000"><font face="Liberation Mono"><span style="background: transparent">SELECT emp_no AS Ansattnummer, salary/12 AS M&aring;nedsl&oslash;nn </span></font></font>
<font face="Liberation Mono"><font color="#000000"><span style="font-weight: normal"><span style="background: transparent">FROM salaries WHERE to_date = '9999-01-01' </span></span></font><font color="#000000"><span style="font-weight: normal"><span style="background: transparent">LIMIT</span></span></font><font color="#000000"><span style="font-weight: normal"><span style="background: transparent"> 5; </span></span></font></font>
<font color="#000000"><font face="Liberation Mono"><span style="font-weight: normal"><span style="background: transparent"><br/>
</span></span></font></font>+--------------+--------------+ <br/>
| Ansattnummer | M&aring;nedsl&oslash;nn &nbsp;&nbsp;| <br/>
+--------------+--------------+ <br/>
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10001 | &nbsp;&nbsp;&nbsp;7413.1667 | <br/>
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10002 | &nbsp;&nbsp;&nbsp;6043.9167 | <br/>
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10003 | &nbsp;&nbsp;&nbsp;3609.2500 | <br/>
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10004 | &nbsp;&nbsp;&nbsp;6171.4167 | <br/>
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10005 | &nbsp;&nbsp;&nbsp;7891.0000 | <br/>
+--------------+--------------+</pre><h3 class="western">
<a name="__RefHeading___Toc16214_413252541"></a>Kalkulerte kolonner
med Microsoft SQL Server:</h3>
<pre class="western"><font color="#000000"><span style="background: transparent">SELECT TOP 5 emp_no AS Ansattnummer, salary/12 AS M&aring;nedsl&oslash;nn FROM salaries WHERE to_date = '9999-01-01' </span></font>
<br/>
Ansattnummer M&aring;nedsl&oslash;nn &nbsp;<br/>
------------ ----------- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11572 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5791 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11573 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5460 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11574 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4050 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11575 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5476 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11576 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7768</pre><h3 class="western">
<a name="__RefHeading___Toc16216_413252541"></a>Kalkulerte kolonner
med Oracle:</h3>
<pre class="western"><font color="#000000"><span style="background: transparent">SELECT emp_no AS Ansattnummer, salary/12 AS M&aring;nedsl&oslash;nn FROM salaries WHERE to_date = '01-01-9999' and rownum &lt; 6; </span></font><span style="background: transparent"><br/>
</span><br/>
ANSATTNUMMER M&Aring;NEDSL&Oslash;NN <br/>
------------ ---------- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;200091 5480,83333 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;200092 &nbsp;&nbsp;&nbsp;5695,75 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;200094 6314,16667 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;200097 &nbsp;&nbsp;&nbsp;&nbsp;9563,5 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;200098 4439,66667</pre><p class="merk">
<b>MERK:</b> Legg merke til at MySQL/MariaDB/PostgreSQL velger samme
ansatte, fra begynnelsen av tabellen, dvs. i den rekkef&oslash;lge de
ble lagt inn, som starter med 10001, mens MS SQL Server og Oracle
velger andre, tilfeldige rader. Vi har ingen kontroll med hvilke
ansatte vi henter ut n&aring;r vi begrenser antall rader med noen av
RDBMSene, hvis vi ikke eksplisitt sorterer s&oslash;ket. 
</p>
<p class="western">Her er et mer avansert eksempel som deler antall
kvinner med antall ansatte og multipliserer resultatet med 100 for &aring;
regne ut prosentandelen kvinner i bedriften:</p>
<h3 class="western"><a name="__RefHeading___Toc16218_413252541"></a>Kalkulering
via undersp&oslash;rringer med MySQL / MariaDB:</h3>
<pre class="western"><a name="yui_3_17_2_1_1474470933046_613"></a><strong><span style="font-weight: normal">SELECT (SELECT count(*) FROM employees WHERE gender = 'M') AS Menn,</span></strong>
<strong><span style="font-weight: normal">(SELECT count(*) FROM employees WHERE gender = 'F') AS Kvinner,</span></strong>
<strong><span style="font-weight: normal">((SELECT count(*) FROM employees WHERE gender = 'F')/(SELECT count(*) FROM</span></strong>
<strong><span style="font-weight: normal">employees))*100 AS Kvinneandel;</span></strong>

<strong><span style="font-weight: normal">+--------+---------+-------------+ <br/>
| Menn &nbsp;&nbsp;| Kvinner | Kvinneandel | <br/>
+--------+---------+-------------+ <br/>
| 179974 | &nbsp;120051 | &nbsp;&nbsp;&nbsp;&nbsp;40.0137 | <br/>
+--------+---------+-------------+</span></strong></pre><h3 class="western">
<a name="__RefHeading___Toc16220_413252541"></a>Kalkulering via
undersp&oslash;rringer med PostgreSQL:</h3>
<p class="western" style="font-weight: normal">Hvis vi pr&oslash;ver
den samme SQL-setningen med PostgreSQL f&aring;r vi dette uventede
resultatet:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT (SELECT count(*) FROM employees WHERE gender = 'M') AS Menn,</span></strong>
<strong><span style="font-weight: normal">(SELECT count(*) FROM employees WHERE gender = 'F') AS Kvinner,</span></strong>
<strong><span style="font-weight: normal">((SELECT count(*) FROM employees WHERE gender = 'F')/(SELECT count(*) FROM</span></strong>
<strong><span style="font-weight: normal">employees))*100 AS Kvinneandel;</span></strong>

<strong>  <span style="font-weight: normal">menn &nbsp;| kvinner | kvinneandel &nbsp;<br/>
--------+---------+------------- <br/>
 179973 | &nbsp;120051 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 <br/>
 </span></strong></pre><p class="western">
Vi f&aring;r en kvinneandel p&aring; 0 fordi vi deler et heltall med
et annet heltall, og svaret blir rundet av til n&aelig;rmeste
heltall. Vi kan fikse dette ved &aring; gj&oslash;re om (&laquo;cast&rsquo;e&raquo;)
telleren i br&oslash;ken til desimaltall. Dette gj&oslash;res ganske
enkelt ved &aring; sette to kolon-tegn etterfulgt av datatypen vi
&oslash;nsker, i dette tilfelle kan vi f.eks. bruke float eller
decimal (decimal gir flere desimaler), slik ::float eller slik:
::decimal. Her er en setning som gir et bedre svar:</p>
<pre class="western">SELECT (SELECT count(*) FROM employees WHERE gender = 'M') AS Menn, <br/>
(SELECT count(*) FROM employees WHERE gender = 'F') AS Kvinner, <br/>
((SELECT count(*) FROM employees WHERE gender = 'F')<b>::float</b>/(SELECT count(*) FROM employees))*100 AS Kvinneandel; 
<br/>
&nbsp;menn &nbsp;| kvinner | &nbsp;&nbsp;kvinneandel &nbsp;&nbsp;&nbsp;&nbsp;<br/>
--------+---------+------------------ <br/>
179973 | &nbsp;120051 | 40.0137988960883</pre><h3 class="western">
<a name="__RefHeading___Toc16222_413252541"></a>Kalkulering via
undersp&oslash;rringer med Oracle:</h3>
<pre class="western">SELECT (SELECT count(*) FROM employees WHERE gender = 'M') &nbsp;Menn, <br/>
(SELECT count(*) FROM employees WHERE gender = 'F') &nbsp;Kvinner, <br/>
((SELECT count(*) FROM employees WHERE gender = 'F')/(SELECT count(*) FROM<br/>
employees))*100 Kvinneandel <b>from dual</b>;
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MENN &nbsp;&nbsp;&nbsp;KVINNER KVINNEANDEL <br/>
---------- ---------- ----------- <br/>
&nbsp;&nbsp;&nbsp;179973 &nbsp;&nbsp;&nbsp;&nbsp;120051 &nbsp;40,0137989</pre><p class="merk">
<b>MERK:</b> Oracle lar oss ikke bruke SELECT uten at vi velger fra
en tabell, men vi kan bruke den &laquo;fiktive&raquo; tabellen <b>dual</b><span style="font-weight: normal">
(som Oracle har opprettet for dette form&aring;let) og velge fra den,
s&aring; f&aring;r vi riktig svar</span></p>
<h3 class="western"><a name="__RefHeading___Toc16224_413252541"></a>Kalkulering
via undersp&oslash;rringer med Microsoft SQL Server:</h3>
<p class="western" style="font-weight: normal">Med SQL Server f&aring;r
vi samme problem som med PostgreSQL, s&aring; vi m&aring; konvertere
heltallet i telleren i br&oslash;ken til et desimaltall &ndash; og
det gj&oslash;res med funksjonen convert(float, &laquo;det som skal
konverteres&raquo;), eller cast(&laquo;det som skal konverteres&raquo;
to float), f.eks. slik:</p>
<pre class="western">SELECT (SELECT count(*) FROM employees WHERE gender = 'M') &nbsp;Menn, (SELECT count(*) FROM employees WHERE gender = 'F') Kvinner, (<b>convert(</b><b>float</b><b>,</b>(SELECT count(*) FROM employees WHERE gender = 'F')<b>)</b>/(SELECT count(*) FROM employees))*100 Kvinneandel

<font color="#000000"><span style="background: transparent">Menn &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Kvinner &nbsp;&nbsp;&nbsp;&nbsp;Kvinneandel &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font><br/>
----------- ----------- ------------------------ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;179974 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;120051 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40.013665527872675<br/>
</pre><p class="merk">
<b>MERK:</b> Legg merke til at desimalene i svaret er litt
forskjellige med MS SQL Server i forhold til de andre tre. Det
skyldes subtile forskjeller i hvordan desimalene utregnes i de ulike
RDBMSene. 
</p>
<h2 class="western"><a name="__RefHeading___Toc10137_1613255157"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Betingelser med CASE</h2>
<p class="western"><strong><span style="font-weight: normal">SQL har
begrensede muligheter til &aring; legge inn betingelser i s&oslash;kene,
og en av disse er med </span></strong><strong><span style="font-weight: normal">konstruksjonen</span></strong><strong><span style="font-weight: normal">
CASE, </span></strong><strong><span style="font-weight: normal">som
fungerer slik:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">CASE WHEN &lt;</span></strong><tt class="western"><span style="font-weight: normal">betingelse&gt;</span></tt><strong><span style="font-weight: normal"> THEN &lt;</span></strong><strong><tt class="western"><span style="font-weight: normal">resultat&gt;</span></tt></strong>
     [WHEN ... THEN ...]
     [ELSE &lt;<tt class="western">result</tt><tt class="western">at hvis ingen av betingelsene inntreffer&gt;</tt>]
END<br/>

(<strong><span style="font-weight: normal">Det som st&aring;r i rette klammer er valgfritt)</span></strong></pre><p class="merk">
<strong><b>MERK:</b></strong><strong><span style="font-weight: normal">
Hvis du ikke har med en ELSE til slutt kan du f&aring; en feilmelding
hvis ingen av betingelsene </span></strong><strong><span style="font-weight: normal">inntreffer</span></strong><strong><span style="font-weight: normal">.
Det anbefales derfor alltid &aring; ha med en ELSE som fanger opp de
som ikke tilfredsstiller noen av betingelsene.</span></strong></p>
<h3 class="western"><a name="__RefHeading___Toc15469_3971551474"></a><strong><span style="font-weight: normal">CASE
med </span></strong><strong><span style="font-weight: normal">MySQL /
MariaDB, </span></strong><strong><span style="font-weight: normal">PostgreSQL,
</span></strong><strong><span style="font-weight: normal">MS SQL
Server og Oracle </span></strong>
</h3>
<p class="western"><strong><span style="font-weight: normal">Her er
</span></strong><strong><span style="font-weight: normal">et</span></strong><strong><span style="font-weight: normal">
eksempel </span></strong><strong><span style="font-weight: normal">som
fungerer helt likt </span></strong><strong><span style="font-weight: normal">(hurra!)
</span></strong><strong><span style="font-weight: normal">med </span></strong><strong><span style="font-weight: normal">alle
4 RDBMSene</span></strong><strong><span style="font-weight: normal">:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT </span></strong><strong><b>CASE WHEN </b></strong><strong><span style="font-weight: normal">gender = 'M' </span></strong><strong><b>THEN</b></strong><strong><span style="font-weight: normal"> 'Mann' </span></strong><strong><b>ELSE</b></strong><strong><span style="font-weight: normal"> 'Kvinne' </span></strong><strong><b>END</b></strong><strong><span style="font-weight: normal"> </span></strong><strong><span style="font-weight: normal">AS</span></strong><strong><span style="font-weight: normal"> Kj&oslash;nn</span></strong><strong><span style="font-weight: normal">, </span></strong>
<strong><span style="font-weight: normal">first_name </span></strong><strong><span style="font-weight: normal">AS Fornavn</span></strong><strong><span style="font-weight: normal">, last_name </span></strong><strong><span style="font-weight: normal">AS Etternavn </span></strong><strong><span style="font-weight: normal">FROM employees;<br/>
</span></strong>
<strong><font color="#000000"><font face="Liberation Mono"><span style="font-weight: normal"><span style="background: transparent">+--------+------------+-----------+ </span></span></font></font></strong><strong><font face="Liberation Mono"><span style="font-weight: normal"><br/>
| Kj&oslash;nn &nbsp;| </span></font></strong><strong><font face="Liberation Mono"><span style="font-weight: normal">Fornavn   </span></font></strong><strong><font face="Liberation Mono"><span style="font-weight: normal"> | </span></font></strong><strong><font face="Liberation Mono"><span style="font-weight: normal">Etternavn</span></font></strong><strong><font face="Liberation Mono"><span style="font-weight: normal"> | <br/>
+--------+------------+-----------+ <br/>
| Mann &nbsp;&nbsp;| Georgi &nbsp;&nbsp;&nbsp;&nbsp;| Facello &nbsp;&nbsp;| <br/>
| Kvinne | Bezalel &nbsp;&nbsp;&nbsp;| Simmel &nbsp;&nbsp;&nbsp;| <br/>
| Mann &nbsp;&nbsp;| Parto &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Bamford &nbsp;&nbsp;| <br/>
| Mann &nbsp;&nbsp;| Chirstian &nbsp;| Koblick &nbsp;&nbsp;| <br/>
| Mann &nbsp;&nbsp;| Kyoichi &nbsp;&nbsp;&nbsp;| Maliniak &nbsp;| <br/>
| Kvinne | Anneke &nbsp;&nbsp;&nbsp;&nbsp;| Preusig &nbsp;&nbsp;| <br/>
| ....   | ....   &nbsp;&nbsp;&nbsp;&nbsp;| ....     &nbsp;| </span></font></strong>
<strong><font face="Liberation Mono"><span style="font-weight: normal">+--------+------------+-----------+ </span></font></strong></pre><p class="western">
<strong><span style="font-weight: normal"><br/>
</span></strong><strong><span style="font-weight: normal">Et
potensielt problem med setningen over er hvis det ikke er satt kj&oslash;nn
p&aring; en ansatt &ndash; f.eks. ved at det st&aring;r en NULL-verdi
i gender-feltet. Disse vil da (muligens feilaktig) bli listet som
kvinner. </span></strong>
</p>
<p class="western"><strong><span style="font-weight: normal">La oss
sette gender til NULL for ansatt nummer 10001 </span></strong><strong><span style="font-weight: normal">og
kj&oslash;re setningen p&aring; nytt</span></strong><strong><span style="font-weight: normal">:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">U</span></strong><strong><span style="font-weight: normal"><span style="background: transparent">PDATE</span></span></strong><strong><font color="#000000"><font face="monospace"><span style="font-weight: normal"><span style="background: transparent"> </span></span></font></font></strong><strong><font color="#000000"><font face="Liberation Mono"><span style="font-weight: normal"><span style="background: transparent">employees SET gender = </span></span></font></font></strong><strong><font color="#000000"><font face="Liberation Mono"><span style="font-weight: normal"><span style="background: transparent">NULL</span></span></font></font></strong><strong><font color="#000000"><font face="Liberation Mono"><span style="font-weight: normal"><span style="background: transparent"> WHERE emp_no = 10001;</span></span></font></font></strong>

<strong><span style="font-weight: normal">SELECT CASE WHEN gender = 'M' THEN 'Mann' ELSE 'Kvinne' END AS Kj&oslash;nn, first_name AS Fornavn, last_name AS Etternavn FROM employees LIMIT 3; &nbsp;<br/>
</span></strong>
<strong><font color="#000000"><font face="Liberation Mono"><span style="font-weight: normal"><span style="background: transparent">+--------+---------+-----------+ <br/>
| Kj&oslash;nn &nbsp;| Fornavn | Etternavn | <br/>
+--------+---------+-----------+ <br/>
| </span></span></font></font></strong><strong><font color="#000000"><font face="Liberation Mono"><b><span style="background: transparent">Kvinne | Georgi &nbsp;| Facello</span></b></font></font></strong><strong><font color="#000000"><font face="Liberation Mono"><span style="font-weight: normal"><span style="background: transparent"> &nbsp;&nbsp;| <br/>
| Kvinne | Bezalel | Simmel &nbsp;&nbsp;&nbsp;| <br/>
| Mann &nbsp;&nbsp;| Parto &nbsp;&nbsp;| Bamford &nbsp;&nbsp;| <br/>
+--------+---------+-----------+</span></span></font></font></strong></pre><p class="western">
<strong><span style="font-weight: normal">Setningen nedenfor, som
sjekker for b&aring;de mann og kvinne og trigger en </span></strong><strong><b>ELSE</b></strong><strong><span style="font-weight: normal">
hvis ingen av dem finnes, l&oslash;ser problemet </span></strong><strong><span style="font-weight: normal">med
Georgis utilsiktede kj&oslash;nnsendring</span></strong><strong><span style="font-weight: normal">:</span></strong></p>
<pre class="western"><font color="#000000"><span style="background: transparent">SELECT CASE WHEN gender = 'M' THEN 'Mann' WHEN gender = 'F' THEN 'Kvinne' </span></font><font color="#000000"><b><span style="background: transparent">ELSE 'Kj&oslash;nn ikke satt'</span></b></font><font color="#000000"><span style="background: transparent"> END AS Kj&oslash;nn, first_name AS F</span></font>ornavn, last_name AS Etternavn FROM employees LIMIT 10;

<font color="#000000"><font face="Liberation Mono"><span style="background: transparent">+------------------+---------+-----------+ </span></font></font><font face="Liberation Mono"><br/>
| Kj&oslash;nn &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Fornavn | Etternavn | <br/>
+------------------+---------+-----------+ <br/>
| Kj&oslash;nn ikke satt &nbsp;| Georgi &nbsp;| Facello &nbsp;&nbsp;| <br/>
| Kvinne &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Bezalel | Simmel &nbsp;&nbsp;&nbsp;| <br/>
| Mann &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Parto &nbsp;&nbsp;| Bamford &nbsp;&nbsp;| <br/>
+------------------+---------+-----------+</font></pre><p class="western">
Her er et eksempel til, hvor CASE brukes til &aring; kategorisere
antall nyansettelser per &aring;r i 3 kategorier: <i>mange</i>,
<i>middels</i> eller <i>f&aring;</i>. 
</p>
<pre class="western">SELECT 
    EXTRACT(YEAR FROM hire_date) AS &Aring;r,
    COUNT(*) AS Nyansatte,
    CASE
        WHEN COUNT(*) &gt; 30000 THEN 'mange'
        WHEN COUNT(*) BETWEEN 20000 AND 30000 THEN 'middels'
        ELSE 'f&aring;'
    END AS Nyansettelser
FROM
    employees
GROUP BY EXTRACT(YEAR FROM hire_date)
ORDER BY 1;

 &Aring;r &nbsp;| nyansatte | nyansettelser <br/>
------+-----------+--------------- <br/>
1985 | &nbsp;&nbsp;&nbsp;&nbsp;35316 | mange <br/>
1986 | &nbsp;&nbsp;&nbsp;&nbsp;36150 | mange 
1987 | &nbsp;&nbsp;&nbsp;&nbsp;33501 | mange 
1988 | &nbsp;&nbsp;&nbsp;&nbsp;31436 | mange 
1989 | &nbsp;&nbsp;&nbsp;&nbsp;28394 | middels 
1990 | &nbsp;&nbsp;&nbsp;&nbsp;25610 | middels 
1991 | &nbsp;&nbsp;&nbsp;&nbsp;22568 | middels 
1992 | &nbsp;&nbsp;&nbsp;&nbsp;20402 | middels 
1993 | &nbsp;&nbsp;&nbsp;&nbsp;17772 | f&aring; 
1994 | &nbsp;&nbsp;&nbsp;&nbsp;14835 | f&aring; 
1995 | &nbsp;&nbsp;&nbsp;&nbsp;12115 | f&aring; 
1996 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9574 | f&aring; 
1997 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6669 | f&aring; 
1998 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4155 | f&aring; 
1999 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1514 | f&aring; 
2000 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13 | f&aring;  </pre><p class="western">
Her er et eksempel hvor vi bruker en CASE WHEN til &aring; liste ut
antall menn og kvinner i bedriften:</p>
<pre class="western">SELECT 
CASE WHEN gender = 'F' THEN count(*) ELSE null END as Kvinner, 
CASE WHEN gender = 'M' THEN count(*) ELSE null END as Menn 
FROM employees GROUP BY gender;<br/>

Kvinner &nbsp;&nbsp;&nbsp;&nbsp;Menn &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
----------- ----------- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;120051 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;179976</pre><p class="western">
<br/>
<br/>

</p>
<p class="merk"><b>MERK:</b> Setningene over fungerer for Oracle,
MySQL/MariaDB og PostgreSQL. Ved &aring; bytte ut funksjonen
EXTRACT(YEAR from hire_date) med funksjonen year(hire_date) vil den
ogs&aring; fungere for MS SQL Server.</p>
<h2 class="western"><a name="__RefHeading___Toc247_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Bruk av funksjoner</h2>
<p class="western">DBMSer har ofte innebygde funksjoner for
manipulering av data. Det er viktig &aring; merke seg at det ikke er
noen konsistent bruk av slike funksjoner - man m&aring; sjekke
dokumentasjonen til den databasen man bruker for en oversikt over
funksjonene den st&oslash;tter og den syntaksen de bruker.</p>
<p class="western">Her er noen vanlige og mye brukte funksjoner:</p>
<h2 class="western"><a name="__RefHeading___Toc249_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Funksjoner for manipulering av tekst:</h2>
<p class="western"><strong><span style="font-weight: normal">Det er
begrenset i hvor stor grad SQL er egnet eller kapabel til &aring;
formatere tekst, men det finnes et knippe funksjoner, som heldigvis
er relativt like for RDBMSene.</span></strong></p>
<h4 class="western"><a name="__RefHeading___Toc16226_413252541"></a><strong>Noen
av </strong><strong>de vanligste tekst-funksjonene:</strong></h4>
<ul>
	<li><p class="western" style="margin-bottom: 0cm">LEFT() -
	Returnerer et antall tegn fra begynnelsen av en streng 
	</p>
	<li><p class="western" style="margin-bottom: 0cm">LENGTH() eller
	DATALENGTH() eller LEN() - Returnerer lengden p&aring; en streng 
	</p>
	<li><p class="western" style="margin-bottom: 0cm">LOWER() eller
	LCASE() (hvis Access) - Konverterer strengen til sm&aring; bokstaver
		</p>
	<li><p class="western" style="margin-bottom: 0cm">LTRIM() - Fjerner
	mellomrum fra begynnelsen av en streng 
	</p>
	<li><p class="western" style="margin-bottom: 0cm">RIGHT() -
	Returnerer et antall tegn slutten av en streng 
	</p>
	<li><p class="western" style="margin-bottom: 0cm">RTRIM() - Fjerner
	mellomrum fra slutten av en streng 
	</p>
	<li><p class="western" style="margin-bottom: 0cm">SOUNDEX() -
	Returnerer en strengs SOUNDEX-verdi, dvs. verdier som h&oslash;res
	ut som s&oslash;kestrengen 
	</p>
	<li><p class="western">UPPER() eller UCASE() (hvis Access) -
	Konverterer en streng til store bokstaver 
	</p>
</ul>
<p class="western">Eksemplet under gir et resultat som viser
avdelingsnavnet med store bokstaver ved bruk av funksjonen UPPER().</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT UPPER(dept_name) AS Avdeling FROM departments<br/>
ORDER BY dept_name;</span></strong>

avdeling<br/>
-------------------- <br/>
CUSTOMER SERVICE <br/>
DEVELOPMENT <br/>
FINANCE <br/>
HUMAN RESOURCES <br/>
MARKETING <br/>
PRODUCTION <br/>
QUALITY MANAGEMENT <br/>
RESEARCH <br/>
SALES</pre><p class="western">
<strong><span style="font-weight: normal">F&oslash;lgende eksempel
kombinerer funksjonene </span></strong><strong><b>upper()</b></strong><strong><span style="font-weight: normal">,
</span></strong><strong><b>left() </b></strong><strong><span style="font-weight: normal">og
</span></strong><strong><b>concat() </b></strong><strong><span style="font-weight: normal">til
&aring; liste ut f&oslash;rste bokstav i fornavnet etterfulgt av et
punktum, et mellomrom, og hele etternavnet:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT CONCAT(UPPER(LEFT(first_name,1)),'. ',last_name) AS Navn FROM employees LIMIT 5; <br/>
+-------------+ <br/>
| Navn &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
+-------------+ <br/>
| G. Facello &nbsp;| <br/>
| B. Simmel &nbsp;&nbsp;| <br/>
| P. Bamford &nbsp;| <br/>
| C. Koblick &nbsp;| <br/>
| K. Maliniak | <br/>
+-------------+</span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Vi ser av eksemplet over at
vi kan sette en funksjon inne i en annen funksjon, og sette det hele
inn i en tredje funksjon, hvis vi har behov for det.  Funksjonen
LEFT(first_name,1) henter ett tegn fra begynnelsen (LEFT) av verdiene
vi henter fra feltet first_name. RIGHT(first_name,3) vil s&aring;ledes
hente de </span></strong><strong><i><b>tre siste</b></i></strong><strong><span style="font-weight: normal">
tegnene fra fornavnet osv. </span></strong>
</p>
<p class="western"><strong><span style="font-weight: normal">Funksjonen
SOUNDEX() skiller seg litt fra de andre ved at den henter et felts
SOUNDEX-verdi, dvs. verdier som </span></strong><strong><i><b>h&oslash;res
ut som</b></i></strong><strong><span style="font-style: normal"><span style="font-weight: normal">
det vi s&oslash;ker etter. Funksjonen </span></span></strong><strong><span style="font-style: normal"><span style="font-weight: normal">kan
</span></span></strong><strong><span style="font-style: normal"><span style="font-weight: normal">brukes
</span></span></strong><strong><span style="font-style: normal"><span style="font-weight: normal">for
eksempel </span></span></strong><strong><span style="font-style: normal"><span style="font-weight: normal">slik:</span></span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT DISTINCT first_name FROM employees </span></strong>
<strong><span style="font-weight: normal">WHERE SOUNDEX(first_name) = SOUNDEX('George'); <br/>
</span></strong>
<strong><span style="font-weight: normal">+------------+ <br/>
| first_name | <br/>
+------------+ <br/>
| Georgi &nbsp;&nbsp;&nbsp;&nbsp;| <br/>
| Georgy &nbsp;&nbsp;&nbsp;&nbsp;| <br/>
| George &nbsp;&nbsp;&nbsp;&nbsp;| <br/>
| Georg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
+------------+</span></strong></pre><p class="western">
<strong><span style="font-style: normal"><span style="font-weight: normal">S&oslash;ket
over henter alle fornavn som h&oslash;res ut som George, og siden vi
bruker n&oslash;kkelordet DISTINCT filtrerer vi ut duplikater slik at
vi f&aring;r en av hver variasjon. </span></span></strong>
</p>
<h2 class="western"><a name="__RefHeading___Toc251_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Funksjoner for manipulering av Dato og Tid</h2>
<p class="western">Dato og tid er komplekst. S&aring; komplekst at da
man gikk over fra Juliansk til Gregoriansk kalender gikk det mer enn
300 &aring;r fra den ny kalenderen ble introdusert i 1582 til alle
land hadde implementert den. Den Julianske kalenderen m&aring;tte
fornyes siden den ikke klarte &aring; beregne &aring;ret n&oslash;yaktig
nok, slik at bl.a. skudd&aring;rsberegningene ble feil. For &aring;
f&aring; til overgangen m&aring;tte man fjerne 10-12 dager helt, slik
at det er et hull i kalenderen ved overgangen der 10-12 dager
mangler. I USA ble f.eks. september 1752 hele 11 dager  kortere enn
vanlig. 	</p>
<p class="western">IT-verden har brukt mye tid og krefter p&aring; &aring;
f&aring; tid og dato riktig. Og ikke minst er man p&aring;passelig
med ikke &aring; gjenta tabben med &aring; sette av kun 2 siffer til
&aring;rstall, som f&oslash;rte til my ekstra stress og
konsulenttimer rundt &aring;rtusenskiftet.  Dato- og Tidsfunksjoner
varierer ritignok en del mellom de ulike databasesystemene, men det
er tegn til at man samler seg rundt ANSI-standarder i st&oslash;rre
grad i tidligere. De fleste DBMSer st&oslash;tter n&aring; f.eks.
bruk av funksjonen EXTRACT<b>()</b> (se nedenfor) for &aring; trekke
ut deler av en dato/tidspunkt. Flere har ogs&aring; valgt &aring;
implementere funksjonen NOW() for &aring; hente dato og tid p&aring;
det &oslash;yeblikket funksjonen kj&oslash;res. 
</p>
<h3 class="western"><a name="__RefHeading___Toc15738_2263950102"></a>TIMESTAMP</h3>
<p class="western">En m&aring;leenhet som er felles for alle systemer
er det som gjerne kalles en <b>UNIX TIMESTAMP</b> eller bare
TIMESTAMP. Det er et heltall som er antall sekunder fra det som
regnes som &laquo;dataepokens begynnelse&raquo;, (som er satt til
midnatt 1. januar 1970) og frem til n&aring;v&aelig;rende tidspunkt.
Tidsstemplet i det &oslash;yeblikket dette skrives er f.eks.
<b>1498646852</b>, som kan oversettes til <span style="font-style: normal"><b>2017-06-28
12:48:36. </b></span><span style="font-style: normal"><span style="font-weight: normal">De
fleste RDBMSer vil v&aelig;re mer n&oslash;yaktige enn dette, og gi
tiden i </span></span><span style="font-style: normal"><span style="font-weight: normal">milli-
eller </span></span><span style="font-style: normal"><span style="font-weight: normal">mikrosekunder,
f.eks. slik:</span></span> <span style="font-style: normal"><b>2017-06-28
12:48:36.749456+02. </b></span><span style="font-style: normal"><span style="font-weight: normal">Tallet
</span></span><span style="font-style: normal"><b>+02 </b></span><span style="font-style: normal"><span style="font-weight: normal">
til slutt angir tidssonen. </span></span>
</p>
<p class="western">Mange av dato- og tidsfunksjonen i RDBMSene bygger
p&aring; Unix Timestamp. Vi skal n&aring; se p&aring; hvordan de 4
store h&aring;ndterer dato og tid.</p>
<h3 class="western"><a name="__RefHeading___Toc253_487959650"></a><strong><span style="font-weight: normal">Datofunksjoner
</span></strong><strong><span style="font-weight: normal">med</span></strong><strong><span style="font-weight: normal">
</span></strong><strong><span style="font-weight: normal">MySQL /
MariaDB</span></strong></h3>
<p class="western">MySQL / MariaDB har en rekke dato- og
tidsfunksjoner. Her er noen av de mest brukte:</p>
<ul>
	<li><p class="western" style="margin-bottom: 0.05cm">NOW() -
	Returnerer dato og tid akkurat n&aring; 
	</p>
	<li><p class="western" style="margin-bottom: 0.05cm">YEAR() -
	Returnerer &aring;r fra et datofelt 
	</p>
	<li><p class="western" style="margin-bottom: 0.05cm">QUARTER() -
	Returnerer kvartals-nummeret fra et datofelt</p>
	<li><p class="western" style="margin-bottom: 0.05cm">MONTH() -
	Returnerer m&aring;ned fra et datofelt</p>
	<li><p class="western" style="margin-bottom: 0.05cm">MONTHNAME() -
	Returnerer m&aring;nedens navn fra et datofelt 
	</p>
	<li><p class="western" style="margin-bottom: 0.05cm">DAY() -
	Returnerer dag fra et datofelt 
	</p>
	<li><p class="western" style="margin-bottom: 0.05cm">DAYNAME() -
	Returnerer navnet p&aring; ukedagen fra et datofelt</p>
	<li><p class="western" style="margin-bottom: 0.05cm">DAYOFMONTH() -
	Returnerer dagen fra et datofelt (f.eks. 28 fra &rsquo;2017-06-28&rsquo;)</p>
	<li><p class="western" style="margin-bottom: 0.05cm">DAYOFYEAR() -
	Returnerer dagen i &aring;ret fra et datofelt (f.eks. 179 fra
	&rsquo;2017-06-28&rsquo;) 
	</p>
	<li><p class="western" style="margin-bottom: 0.05cm">EXTRACT(YEAR/MONTH/DAY
	etc. from &lt;datofelt&gt;) - Returnerer &aring;rstallet fra et
	datofelt, og er kompatibel med PostgreSQL og Oracle.</p>
	<li><p class="western" style="margin-bottom: 0.05cm">DATE_FORMAT(datofelt,
	'&lt;formateringstegn&gt;') - Returnerer en streng formatert etter
	hvilke tegn vi angir etter datofeltet inne i parentesen,  f.eks.  %M
	for m&aring;ned skrevet med bokstaver og %Y for &aring;rstall med
	fire siffer). 
	</p>
</ul>
<h4 class="western"><a name="__RefHeading___Toc15740_2263950102"></a>Navn
p&aring; m&aring;neder og dager p&aring; ulike spr&aring;k</h4>
<p class="western">I setningen under velger vi ut navnet p&aring;
ukedagen fra funksjonen NOW(), som gir oss ukedagen i dag:</p>
<pre class="western">select DAYNAME(NOW()); &nbsp;&nbsp;<br/>
+----------------+ <br/>
| DAYNAME(NOW()) | <br/>
+----------------+ <br/>
| Wednesday &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
+----------------+ <br/>
1 row in set (0.00 sec) <br/>
</pre><p class="western">
Vi ser at ukedagen returneres p&aring; engelsk, siden denne databasen
er satt opp med engelsk som default-spr&aring;k. Vi kan angi hvilket
spr&aring;k vi vil ha navnet p&aring; ved &aring; sette inn en
standard spr&aring;k-kode p&aring; formen &lt;spr&aring;k&gt;_&lt;LAND&gt;,
hvor norsk bokm&aring;l er <b>nb_NO</b> og nynorsk er <b>nn_NO</b><span style="font-weight: normal">,
med denne setningen:</span></p>
<pre class="western">SET lc_time_names = 'nb_NO'; </pre><p class="western">
S&aring; kan vi kj&oslash;re den samme sp&oslash;rringen om igjen og
f&aring; resultatet p&aring; norsk bokm&aring;l:</p>
<pre class="western">select DAYNAME(NOW()); <br/>
+----------------+ <br/>
| DAYNAME(NOW()) | <br/>
+----------------+ <br/>
| onsdag &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
+----------------+ </pre><p class="western">
Eller hente navnet p&aring; m&aring;neden p&aring; fransk, hvis vi
&oslash;nsker det:</p>
<pre class="western">SET lc_time_names = 'fr_FR'; <br/>
<br/>
select MONTHNAME(NOW()); <br/>
+------------------+ <br/>
| MONTHNAME(NOW()) | <br/>
+------------------+ <br/>
| juin &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
+------------------+</pre><p class="western">
Funksjonen DATE_FORMAT() gir full kontroll over hvordan vi vil ha
datoen formatert, f.eks. slik:</p>
<pre class="western">select DATE_FORMAT(NOW(), 'Kl. %T, %W %e. %M, %Y') AS n&aring;; &nbsp;<br/>

+--------------------------------------+ <br/>
| n&aring; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
+--------------------------------------+ <br/>
| Kl. 14:37:31, torsdag 29. juni, 2017 | <br/>
+--------------------------------------+</pre><p class="western">
Vi ser at vi kan kombinere tekst og formateringstegn inne i
tekststrengen i parentesen. Formateringstegnene begynner med et
prosenttegn % og etterf&oslash;lges av en bokstav. Alt annet tolkes
som fritekst og blir gjengitt akkurat slik vi skriver det.  
</p>
<p class="western">Oversikt over hva de ulike formateringstegnene
betyr finnes i dokumentasjonen til MySQL og MariaDB.</p>
<h4 class="western"><a name="__RefHeading___Toc15742_2263950102"></a>Eksempler
fra HR-databasen</h4>
<p class="western">Setningen under henter ut ansattnummer og
gjeldende tittel for alle ansatte. (N&aring;r &aring;rstallet i
kolonnen <i><b>to_date </b></i><i><b>er </b></i>satt til 9999 betyr
det at dette er tittelen de har n&aring;)</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, title FROM titles<br/>
WHERE </span></strong><strong><b>YEAR(to_date)</b></strong><strong><span style="font-weight: normal"> = 9999 </span></strong><strong><span style="font-weight: normal">LIMIT 5</span></strong><strong><span style="font-weight: normal">;</span></strong>

<strong><span style="font-weight: normal">+--------+-----------------+ <br/>
| emp_no | title &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
+--------+-----------------+ <br/>
| &nbsp;10001 | Senior Engineer | <br/>
| &nbsp;10002 | Staff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
| &nbsp;10003 | Senior Engineer | <br/>
| &nbsp;10004 | Senior Engineer | <br/>
| &nbsp;10005 | Senior Staff &nbsp;&nbsp;&nbsp;| <br/>
+--------+-----------------+</span></strong></pre><p class="western">
Samme resultat kan hentes med extract-funksjonen, slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, title FROM titles<br/>
WHERE </span></strong><strong><b>EXTRACT</b></strong><strong><b>(YEAR from to_date)</b></strong><strong><span style="font-weight: normal"> = 9999 </span></strong><strong><span style="font-weight: normal">LIMIT 5</span></strong><strong><span style="font-weight: normal">;</span></strong>

<strong><span style="font-weight: normal">+--------+-----------------+ <br/>
| emp_no | title &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
+--------+-----------------+ <br/>
| &nbsp;10001 | Senior Engineer | <br/>
| &nbsp;10002 | Staff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
| &nbsp;10003 | Senior Engineer | <br/>
| &nbsp;10004 | Senior Engineer | <br/>
| &nbsp;10005 | Senior Staff &nbsp;&nbsp;&nbsp;| <br/>
+--------+-----------------+</span></strong></pre><p class="western">
Det vil g&aring; raskere &aring; filtrere ut dagens ansatte, titler,
l&oslash;nn osv ved &aring; bruke en av funksjonene over, i forhold
til &aring; filtrere p&aring; hele datoen slik: <i><b>WHERE to_date =
&rsquo;9999</b></i><i><b>-01-01</b></i><i><b>&rsquo;</b></i><i>. </i><span style="font-style: normal">Her
er et enkelt eksempel, som viser mer enn  60% reduksjon i tid ved &aring;
bruke funksjonen </span><span style="font-style: normal">YEAR</span><span style="font-style: normal">():</span></p>
<pre class="western">SELECT AVG(salary) FROM salaries <b>WHERE</b><b> to_date = '9999-01-01'</b>; <br/>
<br/>
+-------------+ <br/>
| avg(salary) | <br/>
+-------------+ <br/>
| &nbsp;72012.2359 | <br/>
+-------------+ <br/>
1 row in set (<b>4</b><b>.</b><b>29</b><b> sec</b>) <br/>
<br/>
<br/>
SELECT AVG(salary) FROM salaries <b>WHERE</b><b> </b><b>YEAR</b><b>(to_date) = 9999</b>; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>

+-------------+ <br/>
| avg(salary) | <br/>
+-------------+ <br/>
| &nbsp;72012.2359 | <br/>
+-------------+ <br/>
1 row in set (<b>1.</b><b>31</b><b> sec</b>)<i> </i></pre><p class="merk">
<b>MERK:</b> Tidsbesparelse ved bruk av funksjon fremfor &aring; s&oslash;ke
opp hele datofelt gjelder ikke for alle RDBMSer, s&aring; man b&oslash;r
teste dette ut med den versjonen av RDBMSen man bruker.</p>
<p class="western">I setningen under henter vi ut alle som ble ansatt
de 4 f&oslash;rste m&aring;nedene i 1995:</p>
<pre class="western">SELECT COUNT(*) AS Ansatte FROM employees 
WHERE MONTH(hire_date) &lt; 5 AND YEAR(hire_date) = 1995 ;

+---------+ <br/>
| Ansatte | <br/>
+---------+ <br/>
| &nbsp;&nbsp;&nbsp;4318 | <br/>
+---------+</pre><h3 class="western">
<a name="__RefHeading___Toc15744_2263950102"></a>Beregne differansen
mellom to datoer med funksjonen TIMESTAMPDIFF()</h3>
<p class="western">Med funksjonen <strong>TIMESTAMPDIFF()</strong>
kan vi beregne differansen mellom to datoer ved &aring; g&aring;
veien om UNIX TIMESTAMP, og f.eks. beregne gjennomsnittsalderen til
alle ansatte ut fra f&oslash;dselsdatoene deres, slik:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">SELECT </span></strong><strong><span style="font-weight: normal">AVG</span></strong><strong><span style="font-weight: normal">(</span></strong><strong><span style="font-weight: normal">TIMESTAMPDIFF</span></strong><strong><span style="font-weight: normal">(year,birth_date,</span></strong><strong><span style="font-weight: normal">NOW</span></strong><strong><span style="font-weight: normal">())) as </span></strong><strong><span style="font-weight: normal">snitt</span></strong><strong><span style="font-weight: normal">alder<br/>
FROM employees;</span></strong>
<strong><span style="font-weight: normal">+------------+ <br/>
| snittalder | <br/>
+------------+ <br/>
| &nbsp;&nbsp;&nbsp;58.4093 | <br/>
+------------+</span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Funksjonen </span></strong><strong><span style="font-weight: normal">TIMESTAMPDIFF()
tar tre parametre: </span></strong><strong><span style="font-weight: normal">Hvilken
tidsenhet vi vil ha svaret i (her har vi brukt </span></strong><strong><b>year</b></strong><strong><span style="font-weight: normal">),
navnet p&aring; datofeltet vi vil beregne differansen fra (her er det
feltet </span></strong><strong><b>birth_date</b></strong><strong><span style="font-weight: normal">),
og hvilken dato vi vil beregne differansen til (her har vi brukt
funksjonen </span></strong><strong><b>NOW()</b></strong><strong><span style="font-weight: normal">
for &aring; beregne alderen akkurat n&aring;).</span></strong></p>
<p class="western"><strong><span style="font-weight: normal">Hvis vi
for eksempel ville vise hva gjennomsnittsalderen til de ansatte var
15. februar 1995, trenger vi bare &aring; erstatte  funksjonen NOW()
med &rsquo;1995-02-15&rsquo;, slik:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT AVG(TIMESTAMPDIFF(year,birth_date,'1995-02-15')) as snittalder </span></strong>
<strong><span style="font-weight: normal">FROM employees; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
</span></strong>
<strong><span style="font-weight: normal">+------------+ <br/>
| snittalder | <br/>
+------------+ <br/>
| &nbsp;&nbsp;&nbsp;36.0442 | <br/>
+------------+</span></strong></pre><h3 class="western">
<a name="__RefHeading___Toc255_487959650"></a><strong><span style="font-weight: normal">Datofunksjoner
med </span></strong><strong><span style="font-weight: normal">Microsoft
SQL </span></strong><strong><span style="font-weight: normal">S</span></strong><strong><span style="font-weight: normal">erver</span></strong></h3>
<p class="western"><strong>Microsoft SQL-server</strong> har bl.a.
disse datofunksjonene:</p>
<ul>
	<li><p class="western">DATEPART() - henter en del av et datofelt, 
	f.eks. DATEPART(year, datofelt) henter &aring;rstallet med fire
	siffer fra feltet datofelt. 
	</p>
	<li><p class="western">DATENAME() - henter navnet til en del av et
	datofelt.</p>
	<li><p class="western">YEAR() gir det samme som DATEPART-eksemplet
	ovenfor. 
	</p>
	<li><p class="western">MONTH() - henter tallet til m&aring;neden
	(oktober = 10, osv) fra et datofelt 
	</p>
	<li><p class="western">DAY() - henter dagen fra et datofelt, f.eks.
	&laquo;28&raquo; fra &laquo;2017-06-28&raquo;. 
	</p>
</ul>
<h4 class="western"><a name="__RefHeading___Toc15746_2263950102"></a>Eksempler
p&aring; bruk av datofunksjoner med Microsoft SQL Server</h4>
<p class="merk"><b>MERK: </b>I eksemplene nedenfor brukes funksjonen
GETDATE() til &aring; hente dagens dato. Bytt ut GETDATE() med navnet
til et datofelt for &aring; bruke eksemplene til s&oslash;k i en
tabell. 
</p>
<p class="western">Vi kan f.eks. hente kvartal-numeret idag med denne
setningen:</p>
<pre class="western">select DATEPART(QUARTER,GETDATE()) AS Kvartal; <br/>
 <br/>
Kvartal &nbsp;&nbsp;&nbsp;&nbsp;<br/>
----------- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2</pre><p class="western">
Eller hente ukedagen idag med denne setningen:</p>
<pre class="western">select DATEPART(WEEKDAY,GETDATE()) AS Ukedag; &nbsp;<br/>
<br/>
Ukedag &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
----------- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4</pre><p class="merk">
<b>MERK: </b>Ukedagen i eksemplet over er en onsdag, som blir ukedag
4 siden databasen er satt opp med engelsk lokalisering, hvor s&oslash;ndag
er f&oslash;rste dag i uken</p>
<p class="western">Vi kan ogs&aring; hente navnet p&aring; ukedagen
og m&aring;neden med denne setningen:</p>
<pre class="western">SELECT DATENAME(WEEKDAY,GETDATE()) AS Ukedag,
DATENAME(MONTH,GETDATE()) AS M&aring;ned; <br/>
 <br/>
Ukedag &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&aring;ned &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
------------------------------ ------------------------------ <br/>
Wednesday &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;June &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><h4 class="western">
<a name="__RefHeading___Toc15748_2263950102"></a>Navn p&aring;
m&aring;neder og dager p&aring; ulike spr&aring;k 
</h4>
<p class="western">Vi kan endre spr&aring;ket vi vil ha resultatet i
med denne setningen:</p>
<pre class="western">SET LANGUAGE &lt;spr&aring;knavn&gt;</pre><p class="western">
For eksempel kan vi sette spr&aring;ket til norsk: 
</p>
<pre class="western">SET LANGUAGE Norwegian <br/>
<br/>
(Changed language setting to Norsk)</pre><p class="western">
og f&aring; ukedag og m&aring;nedsnavn ut p&aring; norsk:</p>
<pre class="western">SELECT DATENAME(WEEKDAY,GETDATE()) AS Ukedag,
DATENAME(MONTH,GETDATE()) AS M&aring;ned;<br/>
 <br/>
Ukedag &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&aring;ned &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
------------------------------ ------------------------------ <br/>
onsdag &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;juni &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><p class="western">
Og onsdag blir 3. ukedag, som den skal v&aelig;re etter norsk
beregning, hvor uken starter med mandag:</p>
<pre class="western">SELECT DATENAME(WEEKDAY,GETDATE()) AS Ukedag, <br/>
DATEPART(WEEKDAY,GETDATE()) AS dag; <br/>
 <br/>
Ukedag &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dag &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
------------------------------ ----------- <br/>
onsdag &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3</pre><h4 class="western">
<a name="__RefHeading___Toc15750_2263950102"></a>Eksempler fra
HR-databasen</h4>
<p class="western">Setningen under henter de fem f&oslash;rste radene
av en tabell som lister opp ansattnummer og tittel fra tabellen
<b>titles </b><span style="font-weight: normal">hvor &aring;rstallet
i feltet </span><b>to_date </b><span style="font-weight: normal"> er
9999, dvs at vi vil hente de titlene de ansatte har n&aring; (og luke
ut historiske data for de som har byttet tittel). </span>
</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT TOP 5 emp_no, title FROM titles </span></strong>
<strong><span style="font-weight: normal">WHERE DATEPART(year, to_date) = 9999; <br/>
</span></strong><strong><br/>
</strong><strong><span style="font-weight: normal">emp_no &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
----------- -------------------------------------------------- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10001 Senior Engineer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10002 Staff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10003 Senior Engineer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10004 Senior Engineer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10005 Senior Staff &nbsp;&nbsp;</span></strong></pre><p class="western">
Vi f&aring;r eksakt samme resultat ved &aring; bruke funksjonen
YEAR(), slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT TOP 5 emp_no, title FROM titles</span></strong>
<strong><span style="font-weight: normal">WHERE YEAR(to_date) = 9999;<br/>
</span></strong>
<strong><span style="font-weight: normal">emp_no &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
----------- -------------------------------------------------- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10001 Senior Engineer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10002 Staff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10003 Senior Engineer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10004 Senior Engineer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10005 Senior Staff &nbsp;&nbsp;</span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Vi kan for eksempel liste
ut hvor mange som er f&oslash;dt i oktober m&aring;ned med denne
setningen:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT COUNT(*) as oktoberbarn FROM employees </span></strong>
<strong><span style="font-weight: normal">WHERE MONTH(birth_date) = 10; <br/>
<br/>
oktoberbarn <br/>
----------- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25518 </span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Eller hvor mange kvinner
som ble ansatt i f&oslash;rste kvartal 1998 med denne setningen:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT COUNT(*) as Ansatte from employees </span></strong>
<strong><span style="font-weight: normal">WHERE DATEPART(QUARTER, hire_date) = 1 </span></strong>
<strong><span style="font-weight: normal">AND YEAR(hire_date) = 1998 AND gender = 'F'; <br/>
<br/>
Ansatte &nbsp;&nbsp;&nbsp;&nbsp;<br/>
----------- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;517</span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Vil vi beregne
</span></strong><strong><span style="font-weight: normal">gjennomsnitts</span></strong><strong><span style="font-weight: normal">alder</span></strong><strong><span style="font-weight: normal">en</span></strong><strong><span style="font-weight: normal">
</span></strong><strong><span style="font-weight: normal">til</span></strong><strong><span style="font-weight: normal">
de ansatte </span></strong><strong><span style="font-weight: normal">ut
fra f&oslash;dselsdato</span></strong><strong><span style="font-weight: normal">-feltet</span></strong><strong><span style="font-weight: normal">
kan vi bruke funksjonen </span></strong><strong><b>DATEDIFF()</b></strong><strong><span style="font-weight: normal">,
slik:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT AVG(DATEDIFF(YEAR, birth_date, GETDATE())) as Snittalder FROM employees; <br/>
<br/>
Snittalder &nbsp;<br/>
----------- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;58</span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Funksjonen </span></strong><strong><b>DATEDIFF()</b></strong><strong><span style="font-weight: normal">
tar 3 parametre: Hvilken tidsenhet vi vil beregne differansen med
(her </span></strong><strong><b>YEAR</b></strong><strong><span style="font-weight: normal">),
hvilken dato vi vil beregne differansen fra (her fra feltet
</span></strong><strong><b>birth_date</b></strong><strong><span style="font-weight: normal">)
og hvilken date vi vil beregne differansen til (her dagens dat</span></strong><strong><span style="font-weight: normal">o</span></strong><strong><span style="font-weight: normal">
angitt med </span></strong><strong><b>GETDATE()</b></strong><strong><span style="font-weight: normal">,
</span></strong><strong><span style="font-weight: normal">noe som gir
alderen idag</span></strong><strong><span style="font-weight: normal">).</span></strong></p>
<h3 class="western"><a name="__RefHeading___Toc257_487959650"></a><strong><font face="Helvetica, Arial, sans-serif"><span style="font-weight: normal">Datofunksjoner
med </span></font></strong><strong><font face="Helvetica, Arial, sans-serif"><span style="font-weight: normal">Oracle</span></font></strong></h3>
<p class="western"><strong><font face="Helvetica, Arial, sans-serif">Oracle</font></strong><font face="Helvetica, Arial, sans-serif">
har bl.a. disse datofunksjonene:</font></p>
<ul>
	<li><p class="western">TO_DATE(&lt;'dato som tekst'&gt;, f.eks.
	'12-31-2012') 
	</p>
	<li><p class="western">EXTRACT(year/month/day etc FROM &lt;datofelt&gt;)
	- eller f.eks. EXTRACT(YEAR FROM DATE '1998-03-07')</p>
</ul>
<p class="western">I setningen nedenfor konverterer vi en tekststreng
til en gyldig dato. Vi kj&oslash;rer SELECT mot Oracles
&laquo;dummy&raquo;-tabell <b>dual</b><span style="font-weight: normal">,
siden Oracle ikke tillater s&oslash;k uten FROM</span>:</p>
<pre class="western">SELECT TO_DATE('06-29-2017') idag FROM dual;

IDAG
---------------
06/29/2017</pre><p class="merk">
<b>MERK: </b>Funksjonen TO_DATE() vil ha tekststrengen p&aring; det
amerikanske formatet: <br/>
&lt;m&aring;ned&gt; - &lt;dag&gt; - &lt;&aring;r&gt;,
og ikke etter ISO-standarden &lt;&aring;r&gt; - &lt;m&aring;ned&gt; -
&lt;dag&gt;.</p>
<p class="western"><strong><span style="font-weight: normal">I neste
eksempel henter vi ut &aring;rstallet fra en dato:</span></strong></p>
<p class="western"><br/>
<br/>

</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT EXTRACT(YEAR FROM DATE '1998-03-07') &Aring;r FROM dual;</span></strong>

<strong><span style="font-weight: normal">&Aring;R</span></strong>
<strong><span style="font-weight: normal">---------</span></strong>
<strong><span style="font-weight: normal">1998</span></strong></pre><p class="merk">
<b>MERK: </b>Funksjonen EXTRACT() med DATE vil ha tekststrengen som
angir datoen skrevet  <br/>
etter ISO-standarden: &lt;&aring;r&gt; -
&lt;m&aring;ned&gt; - &lt;dag&gt;   (yyyy-mm-dd)</p>
<p class="western"><br/>
<br/>

</p>
<h4 class="western"><a name="__RefHeading___Toc16405_3466130985"></a><strong>Eksempler
fra HR-databasen</strong></h4>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, title</span></strong>
<strong><span style="font-weight: normal">FROM titles</span></strong>
<strong><span style="font-weight: normal">WHERE to_number(to_char(to_date, &lsquo;YYYY&rsquo;)) = 9999;</span></strong></pre><p class="western">
Alternativt kan vi bruke funksjonen EXTRACT() slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, title</span></strong>
<strong><span style="font-weight: normal">FROM titles</span></strong>
<strong><span style="font-weight: normal">WHERE EXTRACT(year from to_date) = 9999;</span></strong></pre><h3 class="western">
<a name="__RefHeading___Toc259_487959650"></a><strong><font face="Helvetica, Arial, sans-serif"><span style="font-weight: normal">Datofunksjoner
med </span></font></strong><strong><font face="Helvetica, Arial, sans-serif"><span style="font-weight: normal">PostgreSQL</span></font></strong></h3>
<p class="western"><strong><font face="Helvetica, Arial, sans-serif">PostgreSQL</font></strong><font face="Helvetica, Arial, sans-serif">
har bl.a. disse datofunksjonene:</font></p>
<ul>
	<li><p class="western" style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<font size="3" style="font-size: 12pt">DATE_PART() - f.eks.
	DATE_PART('year', &lt;datofelt&gt;) gir &aring;r med fire siffer. </font>
	</p>
	<li><p class="western" style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
	<font size="3" style="font-size: 12pt">EXTRACT(year/month/day/minute
	etc FROM &lt;datofelt&gt;) <br/>
- eller f.eks. EXTRACT(QUARTER 
	FROM DATE '1998-03-07')</font></p>
</ul>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, title</span></strong>
<strong><span style="font-weight: normal">FROM titles<br/>
WHERE DATE_PART('year', to_date) = 9999;</span></strong></pre><p class="western">
Alternativt kan vi bruke EXTRACT, slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, title</span></strong>
<strong><span style="font-weight: normal">FROM titles<br/>
WHERE EXTRACT(year from to_date) = 9999;</span></strong></pre><p class="western">
Her trekker vi ut sekunder-delen av NOW(): 
</p>
<pre class="western">SELECT EXTRACT(second FROM NOW());<br/>

date_part &nbsp;<br/>
----------- <br/>
49.719786</pre><p class="merk">
<b>MERK: </b>I eksemplet under ser vi at i motsetning til
MySQL/MariaDB er det med PostgreSQL raskere &aring; s&oslash;ke etter
hele datofeltet enn enn &aring; bruke funksjonen EXTRACT(year from
to_date):</p>
<pre class="western">SELECT AVG(salary) FROM salaries WHERE to_date = '9999-01-01'; 
        avg         
--------------------
 72012.235857307058
(1 row)

Time: 1279,727 ms</pre><p class="western">
Som vi ser under tar det nesten tre ganger s&aring; lang til &aring;
s&oslash;ke ut &aring;rstallet med funksjonen EXTRACT():</p>
<pre class="western">SELECT AVG(salary) FROM salaries WHERE EXTRACT(year from to_date) = 9999; 

        avg         
--------------------
 72012.235857307058
(1 row)

Time: 3069,452 ms</pre><p class="western">
PostgreSQL har en egen funksjon <b>AGE</b><strong>()</strong> for &aring;
beregne alder riktig ut fra f&oslash;dselsdato, f.eks. slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no </span></strong><strong><span style="font-weight: normal">AS</span></strong><strong><span style="font-weight: normal"> Ansattnummer, </span></strong><strong><span style="font-weight: normal">AGE</span></strong><strong><span style="font-weight: normal">(birth_date) </span></strong><strong><span style="font-weight: normal">AS</span></strong><strong><span style="font-weight: normal"> Alder</span></strong>
<strong><span style="font-weight: normal">FROM employees<br/>
ORDER BY Alder desc;</span></strong></pre><p class="western">
Setningen over henter ansattnummer og alder for alle ansatte sortert
med den eldste &oslash;verst p&aring; listen, slik;</p>
<pre class="western"> ansattnummer |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
--------------+------------------------
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 237571 | 64 years 7 mons 4 days
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 65308 | 64 years 7 mons 4 days
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 91374 | 64 years 7 mons 4 days
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 207658 | 64 years 7 mons 4 days
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 406121 | 64 years 7 mons 4 days
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 87461 | 64 years 7 mons 4 days
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13944 | 64 years 7 mons 3 days
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 48910 | 64 years 7 mons 3 days
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 51486 | 64 years 7 mons 3 days
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 33131 | 64 years 7 mons 3 days</pre><p class="merk">
<a name="yui_3_17_2_1_1474471030227_617"></a><strong>MER</strong><strong>K:
</strong>Vil man vite en persons alder p&aring; et gitt tidspunkt,
kan dette angis som et f&oslash;rste parameter i funksjonen, f.eks.
slik: <strong>age('2010-01-01',birth_date)</strong>, som gir alderen
de hadde 1. januar 2010</p>
<h3 class="western"><a name="__RefHeading___Toc23691_3962996256"></a>Egne
funksjoner med PostgreSQL</h3>
<p class="western">Det er enkelt &aring; lage egne funksjoner med
PostgreSQL. Syntaksen er denne:</p>
<pre class="western">CREATE OR REPLACE FUNCTION &lt;navn&gt;([parameter,...]) AS

 RETURNS &lt;datatype&gt;
 LANGUAGE '&lt;spr&aring;k&gt;'    

AS $[valgfri tekst]$

&lt;kode&gt;

$[valgfri tekst]$;</pre><p class="western">
Spr&aring;k som kan brukes til funksjoner er disse: SQL, PL/PgSQL,
C++, Perl og Python. Men man kan ogs&aring; installere flere spr&aring;k
som kan brukes til funksjoner.</p>
<p class="western">Her er et eksempel p&aring; en enkel funksjon som
legger til 10 til et felt eller en verdi:</p>
<pre class="western">CREATE OR REPLACE FUNCTION plus10(bigint)

  RETURNS bigint
  LANGUAGE 'sql'

AS $BODY$

select $1+10

$BODY$;</pre><p class="western">
og Slik kan den brukes:</p>
<pre class="western">select plus10(20);

plus10
-------
30</pre><p class="western">
Og her er et eksempel p&aring; en funksjon som tar to tekst-parametre
og sl&aring;r dem sammen med et mellomrom mellom dem, samtidig som
den konverterer f&oslash;rste bokstav i begge argumentene til stor
bokstav &ndash; med andre ord en funksjon som f.eks. lager fullt navn
av fornavn og etternavn:</p>
<pre class="western">CREATE OR REPLACE FUNCTION navn(text,text) 

RETURNS text
LANGUAGE 'sql' AS

$$

SELECT concat(left(upper($1),1),right($1,length($1)-1),' ',
left(upper($2),1),right($2,length($2)-1))

$$;</pre><p class="western">
Her er et eksempel p&aring; en funksjon som regner ut bonus for de
ansatte etter n&aring;r de ble ansatt &ndash; de som ble ansatt f&oslash;r
1. januar 1990 f&aring;r 10% bonus, de andre 5%.</p>
<pre class="western">CREATE OR REPLACE FUNCTION bonus(timestamp,int)

RETURNS INT
LANGUAGE 'sql'
AS

$$

SELECT CASE 
WHEN $1 &lt; '1990-01-01' THEN $2*10/100
ELSE $2*5/100 
END

$$;</pre><p class="western">
<br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="merk"><b>MERK: </b>Siden SQL er valgt som spr&aring;k,
skriver vi en SELECT-setning som utf&oslash;rer beregningen (legger
til 10). $1 refererer til det f&oslash;rste parameteret som sendes
inn til funksjonen, dvs. tallet eller verdien til feltet vi setter i
funksjonens parentes, $2 til det andre parameteret osv. Vi trenger
strengt tatt ikke sette noen tekst mellom de to $-tegnene som angir
begynnelsen og slutten p&aring; koden, men vi kan &ndash; som i den
f&oslash;rste funksjonen ($body$) eller vi kan la v&aelig;re, som i
den andre ($$). 
</p>
<ul>
	<p class="ressurs" align="center"><font face="Helvetica, Arial, sans-serif"><b>Eksterne
	ressurser</b></font></p>
	<li><p class="ressurs" align="left"><font face="Helvetica, Arial, sans-serif">Lenke
	til </font><font face="Helvetica, Arial, sans-serif"><b>MySQL</b></font><font face="Helvetica, Arial, sans-serif">s
	innebygde funksjoner:
	<a href="http://dev.mysql.com/doc/refman/5.7/en/functions.html" target="_blank">http://dev.mysql.com/doc/refman/5.7/en/functions.html</a>
	</font>
	</p>
	<li><p class="ressurs" align="left"><font face="Helvetica, Arial, sans-serif">Lenke
	til </font><font face="Helvetica, Arial, sans-serif"><b>MariaDB</b></font><font face="Helvetica, Arial, sans-serif">s
	innebygde funksjoner:</font></p>
	<p class="ressurs" align="left"><a href="https://mariadb.com/kb/en/mariadb/functions-and-operators/"><font face="Helvetica, Arial, sans-serif">https://mariadb.com/kb/en/mariadb/functions-and-operators/</font></a></p>
	<li><p class="ressurs"><font face="Helvetica, Arial, sans-serif">Lenke
	til dokumentasjon for </font><font face="Helvetica, Arial, sans-serif"><b>Oracle</b></font><font face="Helvetica, Arial, sans-serif">s
	innebygde funksjoner:
	<a href="https://docs.oracle.com/database/121/SQLRF/functions002.htm#SQLRF51180" target="_blank">https://docs.oracle.com/database/121/SQLRF/functions002.htm#SQLRF51180</a>
	</font>
	</p>
	<li><p class="ressurs"><font face="Helvetica, Arial, sans-serif">Lenke
	til dokumentasjon for </font><font face="Helvetica, Arial, sans-serif"><b>MS
	SQL </b></font><font face="Helvetica, Arial, sans-serif"><b>S</b></font><font face="Helvetica, Arial, sans-serif"><b>erver</b></font><font face="Helvetica, Arial, sans-serif">s
	innebygde funksjoner:
	<a href="https://technet.microsoft.com/en-us/library/ms174318%28v=sql.90%29.aspx" target="_blank">https://technet.microsoft.com/en-us/library/ms174318%28v=sql.90%29.aspx</a></font>
		</p>
	<li><p class="ressurs"><a name="yui_3_17_2_1_1474471030227_607"></a><font face="Helvetica, Arial, sans-serif">Lenke
	til dokumentasjon for </font><font face="Helvetica, Arial, sans-serif"><b>PostgreSQL</b></font><font face="Helvetica, Arial, sans-serif">s
	innebygde funksjoner:
	<a href="https://www.postgresql.org/docs/9.5/static/functions-datetime.html" target="_blank">https://www.postgresql.org/docs/9.5/static/functions-datetime.html</a></font>
		</p>
</ul>
<p class="western" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<h1 class="western" align="left" style="page-break-before: always"><a name="__RefHeading___Toc18232_1557834486"></a>
<font size="6" style="font-size: 24pt">Kapittel </font><font size="6" style="font-size: 24pt">5</font><br/>
<b>Ag</b><b>g</b><b>regering
av </b>data</h1>
<p class="western">SQL har spesielle funksjoner for &aring; aggregere
data uten &aring; m&aring;tte laste dem ned f&oslash;rst. Eksempler
p&aring; denne typen data kan v&aelig;re:</p>
<ul>
	<li><p class="western" style="margin-bottom: 0cm">Finne antall rader
	i en tabell (evt. etter gitte kriterier)</p>
	<li><p class="western" style="margin-bottom: 0cm">Finne summen av
	verdien i en kolonne for et sett med rader i en tabell</p>
	<li><p class="western">Finne maksimum, minimum eller
	gjennomsnittsverdiene i en kolonne (enten for alle rader eller for
	utvalgte rader)</p>
</ul>
<p class="western">Vi sparer mye tid ved &aring; la databasen foreta
aggregeringene, i forhold til f&oslash;rst &aring; m&aring;tte laste
ned alle dataene og s&aring; foreta aggregeringen hos klienten. I
likhet med filtrering er det en gevinst jo n&aelig;rmere dataene
aggregeringen skjer, slik at vi bare trenger &aring; laste ned de
ferdig filtrerte og aggregerte dataene.</p>
<p class="western">Disse SQL-funksjonene henter aggregerte data, og
st&oslash;ttes av de fleste DBMSer:</p>
<ul>
	<li><p class="western" style="margin-bottom: 0cm; line-height: 140%">
	AVG() - Henter en kolonnes gjennomsnittsverdi</p>
	<li><p class="western" style="margin-bottom: 0cm; line-height: 140%">
	COUNT() - Henter antall rader i en kolonne</p>
	<li><p class="western" style="margin-bottom: 0cm; line-height: 140%">
	MAX() - Henter den h&oslash;yeste verdien i en kolonne</p>
	<li><p class="western" style="margin-bottom: 0cm; line-height: 140%">
	MIN() - Henter den laveste verdien i en kolonne</p>
	<li><p class="western" style="line-height: 140%">SUM() - Henter
	summen av kolonnens verdier</p>
</ul>
<h2 class="western"><a name="__RefHeading___Toc12160_1251604522"></a><strong><font color="#1b75bc">&#61609;</font></strong>
AVG()</h2>
<p class="western">AVG() kan brukes til &aring; hente
gjennomsnittsverdien for alle eller utvalgte rader i tallbaserte
kolonner . Det er vanlig &aring; bruke AVG() med funksjonen ROUND(),
siden snittverdien som oftest regnes ut med et st&oslash;rre antall
desimaler enn &oslash;nskelig.</p>
<p class="western">Denne setningen henter gjennomsnittl&oslash;nnen
for alle ansatte i databasen (inkludert historiske data, dvs. snittet
for hele l&oslash;nnshistorikken til alle ansatte):</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT AVG(salary) AS &quot;Snittl&oslash;nn&quot;</span></strong>
<strong><span style="font-weight: normal">FROM salaries;&nbsp;</span></strong></pre><p class="western">
Denne setningen henter n&aring;v&aelig;rende gjennomsnittsl&oslash;nn
for alle ansatte&nbsp; - og runder av til 2 desimaler:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT ROUND(AVG(salary),2) AS &quot;Snittl&oslash;nn&quot;</span></strong>
<strong><span style="font-weight: normal">FROM salaries</span></strong>
<strong><span style="font-weight: normal">WHERE extract(year from to_date) = 9999; </span></strong></pre><p class="merk">
<strong>MERK:</strong><strong> </strong>Kolonner som har NULL-verdi
blir ikke regnet med i gjennomsnittet</p>
<h3 class="western"><a name="__RefHeading___Toc12378_1251604522"></a>MS
SQL Server og AVG()</h3>
<p class="western">Microsoft SQL server vil ikke la deg beregne
gjennomsnitt av et heltall uten f&oslash;rst &aring; konvertere det
til et desimaltall. Pr&oslash;ver vi f&aring;r vi denne
feilmeldingen:</p>
<pre class="western">select count(*), avg(salary) from salaries where year(to_date) = 9999;<br/>
<br/>
Msg 8115, Level 16, State 2, Server server4, Line 1 <br/>
Arithmetic overflow error converting expression to data type int.</pre><p class="western">
L&oslash;sningen er &aring; bruke funksjonen <b>convert()</b><span style="font-weight: normal">,
hvor vi inne i parentesen f&oslash;rst setter datatypen vi vil
konvertere til (i dette tilfelle f.eks. float eller decimal) ,
etterfulgt av hvilket felt vi vil konvertere. For eksempel slik:</span></p>
<pre class="western">select count(*) as ansatte, avg(convert(float,salary)) as &quot;snittl&oslash;nn&quot; from salaries where year(to_date) = 9999; <br/>
<br/>
 ansatte           snittl&oslash;nn <br/>
 ---------- ------------------------ <br/>
 &nbsp;&nbsp;&nbsp;240124 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;72012.235857307052 </pre><p class="western">
Vi kan ogs&aring; bruke funksjonen <b>cast()</b><span style="font-weight: normal">,
som ogs&aring; konverterer en datatype til en annen p&aring; denne
m&aring;ten:</span></p>
<pre class="western">select count(*) as ansatte, avg(<strong>cast(salary as bigint)</strong>) as &quot;snittl&oslash;nn&quot; from salaries where year(to_date) = 9999; 

   ansatte           snittl&oslash;nn 
----------- ------------------------ 
&nbsp;&nbsp;&nbsp; 240124 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    72012
</pre><h2 class="western">
<a name="__RefHeading___Toc12162_1251604522"></a><strong><font color="#1b75bc">&#61609;</font></strong>
COUNT()</h2>
<p class="western">COUNT() tellerantall rader i en tabell - evt.
etter gitte kriterier. Funksjonen jan brukes p&aring; to m&aring;ter:</p>
<ol>
	<li><p class="western" style="margin-bottom: 0cm">Bruk <strong>COUNT(*)</strong>
	til &aring; telle antall rader i en tabell, uavhengig av om radene
	inneholder verdier eller NULL-verdier</p>
	<li><p class="western">Bruk <strong>COUNT(&lt;kolonnenavn&gt;)</strong>
	til &aring; telle antall rader som har verdier i en tabell, og
	ignorer NULL-verdier</p>
</ol>
<p class="western">Eksempler:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT COUNT(*) AS Ansatte</span></strong>
<strong><span style="font-weight: normal">FROM employees;</span></strong>
<strong><span style="font-weight: normal">SELECT COUNT(hire_date) AS Ansatte_med_ansettelsesdato</span></strong>
<strong><span style="font-weight: normal">FROM employees;</span></strong></pre><p class="western">
Det f&oslash;rste eksemplet teller opp alle ansatte, mens det siste
eksemplet bare teller ansatte som vi har registrert ansettelsesdatoen
til.</p>
<h2 class="western"><a name="__RefHeading___Toc12164_1251604522"></a><strong><font color="#1b75bc">&#61609;</font></strong>
MAX()</h2>
<p class="western">For &aring; bruke MAX() m&aring; et kolonnenavn
angis:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT MAX(salary) AS &quot;Toppl&oslash;nn&quot;</span></strong>
<strong><span style="font-weight: normal">FROM salaries</span></strong></pre><p class="merk">
<strong>MERK: </strong>Kolonner med NULL-verdi ignoreres av MAX()</p>
<h2 class="western"><a name="__RefHeading___Toc12166_1251604522"></a><strong><font color="#1b75bc">&#61609;</font></strong>
MIN()</h2>
<p class="western">For &aring; bruke MIN() m&aring; et kolonnenavn
angis:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT MIN(salary) AS &quot;Minstel&oslash;nn&quot;</span></strong>
<strong><span style="font-weight: normal">FROM salaries</span></strong></pre><p class="merk">
<strong>MERK: </strong>Kolonner med NULL-verdi ignoreres ogs&aring;
av MIN()</p>
<h2 class="western"><a name="__RefHeading___Toc12168_1251604522"></a><strong><font color="#1b75bc">&#61609;</font></strong>
SUM()</h2>
<p class="western">SUM() brukes til &aring; beregne summen av
verdiene i en angitt kolonne.</p>
<pre class="western"><strong><span style="font-weight: normal">S</span></strong><strong><span style="font-weight: normal">ELECT SUM(salary) AS &quot;&Aring;rlig L&oslash;nnskostnad&quot;</span></strong>
<strong><span style="font-weight: normal">FROM salaries</span></strong>
<strong><span style="font-weight: normal">WHERE year(to_date) = 9999;</span></strong></pre><p class="western">
Setningen over summerer opp bedriftens samlede <strong>&aring;rlige</strong>
l&oslash;nnskostnad i dag (ekskludert historiske data)</p>
<pre class="western"><strong><span style="font-weight: normal">S</span></strong><strong><span style="font-weight: normal">ELECT SUM(salary/12) AS &quot;M&aring;nedlig L&oslash;nnskostnad&quot;</span></strong>
<strong><span style="font-weight: normal">FROM salaries</span></strong>
<strong><span style="font-weight: normal">WHERE year(to_date) = 9999; </span></strong></pre><p class="western">
Setningen over summerer opp bedriftens samlede <strong>m&aring;nedlige</strong>
l&oslash;nnskostnad i dag (ekskludert historiske data)</p>
<h3 class="western"><a name="__RefHeading___Toc12380_1251604522"></a>MS
SQL Server og SUM()</h3>
<p class="western">Siden feltet salary er av datatypen heltall
(integer), vil vi f&aring; feil resultat med MS SQL Server hvis vi
ikke f&oslash;rst konverterer feltet til et desimaltall. Derimot f&aring;r
vi ikke noen feilmelding, slik som med beregning av gjennomsnitt med
avg(). Her er resultatet, f&oslash;rst uten og s&aring; med
konvertering:</p>
<pre class="western">SELECT SUM(salary/12) AS &quot;M&aring;nedlig L&oslash;nnskostnad&quot; FROM salaries WHERE year(to_date) = 9999; &nbsp;<br/>
<br/>
M&aring;nedlig L&oslash;nnskostnad <br/>
--------------------- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1440878693 </pre><p class="western">
<br/>
<br/>
<br/>

</p>
<pre class="western">SELECT SUM(convert(float,salary)/12) AS &quot;M&aring;nedlig L&oslash;nnskostnad&quot; FROM salaries WHERE year(to_date) = 9999; &nbsp;<br/>
 <br/>
M&aring;nedlig L&oslash;nnskostnad &nbsp;&nbsp;&nbsp;<br/>
------------------------ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1440988843.5833328</pre><p class="western">
Som vi ser er det relativt stor forskjell mellom de to resultatene.
S&aring; husk alltid &aring; konvertere til desimaltall f&oslash;r du
foretar regneoperasjoner med MS SQL Server som kan resultere i
desimaler. Hadde vi konvertert til datatypen <i><b>decimal </b></i><span style="font-style: normal"><span style="font-weight: normal">istedenfor
</span></span><i><b>float, </b></i><span style="font-style: normal"><span style="font-weight: normal">hadde
vi f&aring;tt et litt ulikt resultat, men bare i selve desimalene,
</span></span><span style="font-style: normal"><span style="font-weight: normal">som
vi i dette tilfellet antagelig likevel ville avrundet med funksjonen
</span></span><i><span style="font-weight: normal">round()</span></i><span style="font-style: normal"><span style="font-weight: normal">
til n&aelig;rmeste heltall, noe som ville fjernet forskjellen.</span></span><span style="font-style: normal"><span style="font-weight: normal">
 </span></span>
</p>
<h2 class="western"><a name="__RefHeading___Toc12170_1251604522"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Aggregering med distinkte verdier</h2>
<p class="western">De 5 aggregat-funksjonene kan alle brukes p&aring;
distinkte verdier ved &aring; legge til argumentet DISTINCT:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT AVG(DISTINCT salary) AS &quot;Snittl&oslash;nn&quot;</span></strong>
<strong><span style="font-weight: normal">FROM salaries</span></strong>
<strong><span style="font-weight: normal">WHERE emp_no = '100002';</span></strong></pre><p class="western">
<br/>
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc12172_1251604522"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Kombinering av aggregerte funksjoner</h2>
<p class="western">Ofte vil vi hente ut flere aggregerte tall for en
elle flere kolonner, og det kan vi gj&oslash;re med samme
SQL-setning, f.eks. slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT COUNT(*) AS &quot;Antall Ansatte&quot;,</span></strong>
<strong>       <span style="font-weight: normal">MIN(salary) AS &quot;Minstel&oslash;nn&quot;,</span></strong>
<strong>       <span style="font-weight: normal">MAX(salary) AS &quot;Toppl&oslash;nn&quot;,</span></strong>
<strong>       <span style="font-weight: normal">ROUND(AVG(salary)) AS &quot;Snittl&oslash;nn&quot;</span></strong>
<strong><span style="font-weight: normal">FROM salaries</span></strong>
<strong><span style="font-weight: normal">WHERE extract(year from to_date) = 9999;</span></strong></pre><h2 class="western">
<br/>
<br/>

</h2>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc18234_1557834486"></a>
<font size="6" style="font-size: 24pt">Kapittel </font><font size="6" style="font-size: 24pt">6</font><br/>
Gruppering
av Data</h1>
<h2 class="western"><a name="__RefHeading___Toc18236_1557834486"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Gruppering av data med GROUP BY</h2>
<p class="western">Alle beregninger hittil har v&aelig;rt gjort p&aring;
alle data i en tabell som tilfredsstilte WHERE-betingelsen i
SQL-setningene. Ofte har vi behov for &aring; dele data inn i
kategorier - f.eks. &aring; liste opp ansatte per avdeling,
gjenomsnittsl&oslash;nn etter stillingskategori, eller data fordelt
p&aring; menn og kvinner . Dette gj&oslash;r vi ved &aring; lage
grupper med <strong>GROUP BY. </strong>F.eks. slik:</p>
<pre class="western"><a name="yui_3_17_2_1_1474495744656_73"></a><strong><span style="font-weight: normal">SELECT gender as &quot;Kj&oslash;nn&quot;, COUNT(*) AS Antall</span></strong>
<strong><span style="font-weight: normal">FROM employees</span></strong>
<strong><span style="font-weight: normal">GROUP BY gender;</span></strong></pre><p class="western">
Denne setningen henter to kolonner - en med den ansattes kj&oslash;nn
(registerert som &quot;F&quot; og &quot;M&quot;)&nbsp; og en med
antall ansatte innenfor hver kategori. <strong>GROUP BY gender</strong>
gj&oslash;r at antall ansatte blir listet opp per kj&oslash;nn.</p>
<p class="western"><strong>Dette er det vi trenger &aring; vite om
grupper:</strong></p>
<ul>
	<li><p class="western" style="margin-bottom: 0cm"><b>GROUP BY</b>
	kan inneholde s&aring; mange kolonner vi vil, med komma mellom hver
	kolonne. Slik kan grupper inneholde undergrupper. 
	</p>
	<li><p class="western" style="margin-bottom: 0cm">Har du angitt
	undergrupper blir data aggregert p&aring; den sist definerte
	undergruppen 
	</p>
	<li><p class="western" style="margin-bottom: 0cm">Hver kolonne som
	er listet i GROUP BY m&aring; v&aelig;re en eksisterende kolonne
	eller et gyldig uttrykk. Hvis et uttrykk er angitt i SELECT, m&aring;
	samme uttrykk brukes i GROUP BY. 
	</p>
	<li><p class="western" style="margin-bottom: 0cm">De fleste
	database-systemer tillater ikke at man bruker GROUP BY p&aring;
	kolonner med variabel lengde, slik som <em>text</em> eller <em>memo.</em>
		</p>
	<li><p class="western" style="margin-bottom: 0cm">Bortsett fra
	aggregerings-kalkuleringer, m&aring; hver kolonne i SELECT v&aelig;re
	tilstede i GROUP BY 
	</p>
	<li><p class="western" style="margin-bottom: 0cm">Hvis kolonnen du
	grupperer etter inneholder en rad med NULL-verdi, vil NULL bli
	listet opp som en gruppe. Er det flere rader med NULL-verdi,
	grupperes de sammen 
	</p>
	<li><p class="western" style="line-height: 140%">GROUP BY m&aring;
	komme etter WHERE og f&oslash;r ORDER BY i SQL-setningen 
	</p>
</ul>
<p class="merk"><strong>MERK: </strong>Oracle tillater ikke at man
grupperer p&aring; et alias, men det gj&oslash;r MySQL/MariaDB og
PostgreSQL. Det sikreste er &aring; gruppere p&aring; det opprinnelig
kolonnenavnet eller p&aring; funksjonen som beregner kolonnen,
f.eks.: <strong>GROUP BY extract(year from to_date)</strong> heller
enn<strong> GROUP BY &quot;&Aring;r&quot; </strong>e.l.</p>
<p class="western" style="margin-bottom: 0cm"><a name="yui_3_17_2_1_1474495744656_78"></a>
Husk at n&aring;r man bruker GROUP BY vil det (tiln&aelig;rmet)
alltid inkludere en eller flere aggregerte kolonner. Du kan derfor
ikke blande dette sammen med kolonner som ikke er aggregerte
(bortsett fra den eller de kolonnene du grupperer p&aring;).</p>
<h2 class="western"><a name="__RefHeading___Toc263_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Filtrering av grupper med HAVING</h2>
<p class="western">SQL lar deg filtrere hvilke grupper som skal
inkluderes eller ekskluderes. Dette gj&oslash;res ved &aring;
filtrere p&aring; hele grupper, og ikke individuelle rader. <strong>WHERE</strong>
brukes til &aring; filtrere enkelt-rader, men kan ikke brukes p&aring;
grupper. I stedet bruker vi <strong>HAVING </strong>n&aring;r vi skal
filtrere grupper.</p>
<p class="western">HAVING fungerer akkurat som WHERE, men brukes kun
p&aring; grupper.</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT dept_no as Avdeling, COUNT(*) AS Ansatte</span></strong>
<strong><span style="font-weight: normal">FROM dept_emp</span></strong>
<strong><span style="font-weight: normal">GROUP BY dept_no</span></strong>
<strong><span style="font-weight: normal">HAVING COUNT(*) &gt;=30000</span></strong>
<strong><span style="font-weight: normal">ORDER BY Ansatte desc;</span></strong>

<strong><span style="font-weight: normal">+----------+---------+ <br/>
| Avdeling | Ansatte | <br/>
+----------+---------+ <br/>
| d005 &nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;85707 | <br/>
| d004 &nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;73485 | <br/>
| d007 &nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;52245 | <br/>
+----------+---------+</span></strong></pre><p class="western">
Setningen over filtrerer ut avdelinger som har 30000 eller flere
ansatte. Som vi ser vil ikke WHERE fungere her, siden vi filtrerer
basert p&aring; gruppens aggregerte verdi, ikke p&aring; verdien til
enkelte rader.</p>
<p class="merk"><b>MERK:</b> WHERE filtrerer <strong>f&oslash;r</strong>
data er gruppert, HAVING filtrerer <strong>etter</strong> at data er
gruppert</p>
<p class="western" style="margin-bottom: 0.5cm"><a name="yui_3_17_2_1_1474495862883_79"></a>
Vi kan kombinere WHERE og HAVING i samme SQL-setning, hvis vi f&oslash;rst
vil filtrere ut rader, og s&aring; gruppere dem og filtrere ut
grupper etterp&aring;.</p>
<h2 class="western"><a name="__RefHeading___Toc13352_1054794037"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Gruppering med ROLLUP og CUBE</h2>
<p class="western">N&aring;r vi grupperer med GROUP BY kan vi hente
aggregerte tall for hver gruppe, for eksempel l&oslash;nnskostnader
per &aring;r, salg per produkt og geografisk omr&aring;de osv.
Samtidig mister vi de totale tallene for alle gruppene samlet.
Grupperer vi p&aring; m&aring;ned, mister vi totalen for &aring;ret.
Dersom vi &oslash;nsker &aring; ha med totalene ogs&aring;, har SQL
to innebygde funksjoner som hjelper oss med dette: ROLLUP og CUBE.
Forskjellen p&aring; de to er at ROLLUP tar med totaltall for f&oslash;rste
gruppe og for hele datasettet (alle gruppene), mens CUBE ogs&aring;
tar med totaltallene for alle <font size="2" style="font-size: 10pt">undergruppe</font><font size="2" style="font-size: 10pt">ne,
</font><font size="2" style="font-size: 10pt">det vil si for alle
kombinasjoner av data i sp&oslash;rringen</font><font size="2" style="font-size: 10pt">.</font></p>
<p class="western">Noen eksempler vil antagelig forklare dette bedre.
Nedenfor har vi gruppert l&oslash;nnskostnadene for bedriftene etter
stilling og kj&oslash;nn. Det gir f&oslash;lgende fire
kombinasjonsmuligheter: 
</p>
<ol>
	<li><p class="western" style="margin-bottom: 0cm">L&oslash;nnskostnader
	<font size="2" style="font-size: 10pt">gruppert b&aring;de etter
	stilling og kj&oslash;nn.</font></p>
	<li><p class="western" style="margin-bottom: 0cm">L&oslash;nnskostnader
	<font size="2" style="font-size: 10pt">gruppert bare etter stilling</font></p>
	<li><p class="western" style="margin-bottom: 0cm"><font size="2" style="font-size: 10pt">L&oslash;nnskostnader</font><font size="2" style="font-size: 10pt">
	</font><font size="2" style="font-size: 10pt">gruppert bare etter
	kj&oslash;nn </font>
	</p>
	<li><p class="western" style="margin-bottom: 0cm">Totale
	l&oslash;nnskostnader for hele bedriften<font size="2" style="font-size: 10pt">
	</font> 
	</p>
</ol>
<p class="western" style="margin-bottom: 0cm"><br/>

</p>
<p class="western" style="margin-bottom: 0cm">Av disse vil GROUP BY
uten ROLLUP og CUBE hente 1, ROLLUP hente 1, 2 og 4, siden stilling
(title) er &oslash;verste grupperingsniv&aring;, mens CUBE vil  hente
alle kombinasjonene, dvs CUBE vil ogs&aring; inkludere sub-totalene
for underguppen kj&oslash;nn. <br/>
<br/>

</p>
<p class="western" style="margin-bottom: 0cm">Eksemplene nedenfor
viser dette i praksis:</p>
<h3 class="western"><a name="__RefHeading___Toc12933_1158268304"></a>ROLLUP
og CUBE med Oracle</h3>
<pre class="western">SELECT title, gender, sum(salary) AS salary FROM salaries s 
INNER JOIN titles t ON s.emp_no=t.emp_no 
INNER JOIN employees e ON e.emp_no=s.emp_no 
WHERE extract(year from s.to_date) = 9999 
AND extract(year from t.to_date) = 9999 
AND title IN ('Engineer','Senior Staff') 
GROUP BY <b>ROLLUP(</b>title,gender<b>)</b>;    

TITLE		 GE	 SALARY
------------------ -- ----------
Engineer		  F   739970609
Engineer		  M  1106701015
Engineer		     1846671624
Senior Staff	  F  2645100493
Senior Staff	  M  3974769125
Senior Staff	     6619869618
			     8466541242</pre><p class="western">
Og med CUBE:</p>
<pre class="western">SELECT title, gender, sum(salary) AS salary FROM salaries s 
INNER JOIN titles t ON s.emp_no=t.emp_no 
INNER JOIN employees e ON e.emp_no=s.emp_no 
WHERE extract(year from s.to_date) = 9999 
AND extract(year from t.to_date) = 9999 
AND title IN ('Engineer','Senior Staff') 
GROUP BY <b>CUBE(</b>title,gender<b>)</b>;  
 

TITLE		  GE	 SALARY
------------------ -- ----------
			     8466541242
			  F  3385071102
			  M  5081470140
Engineer		     1846671624
Engineer		  F   739970609
Engineer		  M  1106701015
Senior Staff	     6619869618
Senior Staff	  F  2645100493
Senior Staff	  M  3974769125</pre><h3 class="western">
<a name="__RefHeading___Toc12935_1158268304"></a>ROLLUP med MySQL /
MariaDB 
</h3>
<p class="western">MariaDB har st&oslash;tte for ROLLUP, men ikke
CUBE p&aring; n&aring;v&aelig;rende tidspunkt (versjon 10.4).
Fors&oslash;ker vi med CUBEf&aring;r vi denne feilmeldingen:</p>
<pre class="western">ERROR 1235 (42000): This version of MariaDB doesn't yet support 'CUBE'</pre><p class="merk">
<b>MERK:</b> Syntaksen for ROLLUP med MySQL/MariaDB er annerledes enn
for de andre tre RDBMSene, som har like syntaks. 
</p>
<p class="western">Med MySQL / MariaDB brukes GROUP BY med ROLLUP
slik:</p>
<pre class="western">SELECT title, gender, sum(salary) as salary FROM salaries s 
INNER JOIN titles t ON s.emp_no=t.emp_no 
INNER JOIN employees e ON e.emp_no=s.emp_no
WHERE extract(year from s.to_date) = 9999 
AND extract(year from t.to_date) = 9999 
AND title in ('Engineer','Senior Staff') 
GROUP BY title,gender <b>WITH ROLLUP</b>; 

+--------------+--------+------------+
| title        | gender | salary     |
+--------------+--------+------------+
| Engineer     | F      |  739970609 |
| Engineer     | M      | 1106701015 |
| Engineer     | NULL   | 1846671624 |
| Senior Staff | F      | 2645100493 |
| Senior Staff | M      | 3974769125 |
| Senior Staff | NULL   | 6619869618 |
| NULL         | NULL   | 8466541242 |
+--------------+--------+------------+</pre><h3 class="western">
<a name="__RefHeading___Toc12937_1158268304"></a>ROLLUP og CUBE  med
PostgreSQL</h3>
<p class="western">PostgreSQL har st&oslash;tte for b&aring;de
ROLLUP, CUBE og GROUPING SETS. 
</p>
<p class="western"><br/>
<br/>

</p>
<p class="western">Med ROLLUP</p>
<pre class="western">SELECT title, gender, sum(salary) AS salary FROM salaries s 
INNER JOIN titles t ON s.emp_no=t.emp_no 
INNER JOIN employees e ON e.emp_no=s.emp_no 
WHERE extract(year from s.to_date) = 9999 
AND extract(year from t.to_date) = 9999 
AND title in ('Engineer','Senior Staff') 
GROUP BY <b>ROLLUP</b><b>(</b>title,gender<b>)</b>; 

    title     | gender |   salary    
--------------+--------+------------
 Engineer     | F      |  739970609
 Engineer     | M      | 1106701015
 Engineer     |        | 1846671624
 Senior Staff | F      | 2645100493
 Senior Staff | M      | 3974769125
 Senior Staff |        | 6619869618
              |        | 8466541242</pre><p class="western">
Eksempel med CUBE og funksjonen coalesce() for &aring; angi tekst for
sumtallene, Funksjonen coalesce() brukes her til &aring; angi en
tekst for null-verdier, dvs. der det ellers vill v&aelig;rt tomme
felt, slik det er for sumtallene i forrige eksempel. Det gir en
ryddigere oversikt: 
</p>
<pre class="western">SELECT coalesce(title,'Alle stillinger') as Stilling, coalesce(gender,'Begge Kj&oslash;nn') as Kj&oslash;nn, sum(salary) AS salary 
FROM salaries s 
INNER JOIN titles t ON s.emp_no=t.emp_no 
INNER JOIN employees e ON e.emp_no=s.emp_no 
WHERE extract(year from s.to_date) = 9999 
AND extract(year from t.to_date) = 9999 
AND title IN ('Engineer','Senior Staff') 
GROUP BY <b>CUBE</b><b>(</b>title,gender<b>)</b>; 

       stilling      |    kj&oslash;nn    |   salary    
--------------------+-------------+-------------
 Assistant Engineer | F           |    82794220
 Assistant Engineer | M           |   122861234
 Assistant Engineer | Begge Kj&oslash;nn |   205655454
 Engineer           | F           |   739970609
 Engineer           | M           |  1106701015
 Engineer           | Begge Kj&oslash;nn |  1846671624
 Manager            | F           |      302760
 Manager            | M           |      396753
 Manager            | Begge Kj&oslash;nn |      699513
 Senior Engineer    | F           |  2434356415
 Senior Engineer    | M           |  3652138993
 Senior Engineer    | Begge Kj&oslash;nn |  6086495408
 Senior Staff       | F           |  2645100493
 Senior Staff       | M           |  3974769125
 Senior Staff       | Begge Kj&oslash;nn |  6619869618
 Staff              | F           |   678880020
 Staff              | M           |  1039802540
 Staff              | Begge Kj&oslash;nn |  1718682560
 Technique Leader   | F           |   327817911
 Technique Leader   | M           |   485974035
 Technique Leader   | Begge Kj&oslash;nn |   813791946
 Alle stillinger    | F           |  6909222428
 Alle stillinger    | M           | 10382643695
 Alle stillinger    | Begge Kj&oslash;nn | 17291866123
(24 rows)</pre><p class="western">
Her er et enkelt eksempel med ROLLUP kombinert med CASE WHEN for &aring;
f&aring; norsk tekst p&aring; radene. 
</p>
<pre class="western">SELECT CASE WHEN gender='M' THEN 'Menn' <br/>
WHEN gender='F' THEN 'Kvinner' <br/>
ELSE 'Begge kj&oslash;nn' END  AS Kj&oslash;nn, <br/>
count(*) AS Antall <br/>
FROM employees <br/>
GROUP BY ROLLUP(gender);

      kj&oslash;nn      | antall 
-----------------+--------
 Begge kj&oslash;nn     | 300024
 Menn            | 179973
 Kvinner         | 120051</pre><p class="merk">
<b>MERK:</b> Legg merke til at ELSE &ndash; betingelsen her vil fange
opp sumtallet som genereres av ROLLUP for begge kj&oslash;nn.</p>
<h3 class="western"><a name="__RefHeading___Toc12939_1158268304"></a>ROLLUP
og CUBE med MS SQL Server</h3>
<pre class="western">1&gt; SELECT title, gender, sum(salary) as salary FROM salaries s 
INNER JOIN titles t ON s.emp_no=t.emp_no 
INNER JOIN employees e ON e.emp_no=s.emp_no 
WHERE year(s.to_date) = 9999 AND year(t.to_date) = 9999 
AND title IN ('Engineer','Senior Staff') 
GROUP BY <b>ROLLUP</b><b>(</b>title,gender<b>)</b>

2&gt; go

<font size="1" style="font-size: 8pt">title                                              gender salary              </font>
<font size="1" style="font-size: 8pt">-------------------------------------------------- ------ --------------------</font>
<font size="1" style="font-size: 8pt">Engineer                                           F                 739970609</font>
<font size="1" style="font-size: 8pt">Engineer                                           M                1106701015</font>
<font size="1" style="font-size: 8pt">Engineer                                           NULL             1846671624</font>
<font size="1" style="font-size: 8pt">Senior Staff                                       F                2645100493</font>
<font size="1" style="font-size: 8pt">Senior Staff                                       M                3974769125</font>
<font size="1" style="font-size: 8pt">Senior Staff                                       NULL             6619869618</font>
<font size="1" style="font-size: 8pt">NULL                                               NULL             8466541242</font></pre><p class="western">
<a name="__RefHeading___Toc12941_1158268304"></a>Og med CUBE;</p>
<pre class="western">1&gt; SELECT title, gender, sum(salary) as salary FROM salaries s 
INNER JOIN titles t ON s.emp_no=t.emp_no 
INNER JOIN employees e ON e.emp_no=s.emp_no 
WHERE year(s.to_date) = 9999 AND year(t.to_date) = 9999 
AND title IN ('Engineer','Senior Staff') 
<span style="font-weight: normal">GROUP BY</span><span style="font-weight: normal"> </span><b>CUBE</b><b>(</b><span style="font-weight: normal">title,gender</span><b>)</b>
 
2&gt; go

<font size="1" style="font-size: 8pt">title                                              gender salary              </font>
<font size="1" style="font-size: 8pt">-------------------------------------------------- ------ --------------------</font>
<font size="1" style="font-size: 8pt">Engineer                                           F                 739970609</font>
<font size="1" style="font-size: 8pt">Senior Staff                                       F                2645100493</font>
<font size="1" style="font-size: 8pt">NULL                                               F                3385071102</font>
<font size="1" style="font-size: 8pt">Engineer                                           M                1106701015</font>
<font size="1" style="font-size: 8pt">Senior Staff                                       M                3974769125</font>
<font size="1" style="font-size: 8pt">NULL                                               M                5081470140</font>
<font size="1" style="font-size: 8pt">NULL                                               NULL             8466541242</font>
<font size="1" style="font-size: 8pt">Engineer                                           NULL             1846671624</font>
<font size="1" style="font-size: 8pt">Senior Staff                                       NULL             6619869618</font></pre><h3 class="western">
<a name="__RefHeading___Toc26955_1534934292"></a>Sorterte sett</h3>
<p class="western">Vi kan ogs&aring; gruppere data i &laquo;sorterte
sett&raquo; slik at vi f.eks. Kan beregne medianen innen hver gruppe.
PostgreSQL har to innebygde funksjoner for &aring; beregne
<b>median</b>:<br/>
percentile_disc() og percentile_cont().
percentile_disc() returnerer en verdi som faktisk finnes i
datasettet, mens percentile_cont() beregner en verdi hvis det ikke
finnes en eksakt match. Medianen finner vi med &aring; gi funksjonene
parameteret 0.5, f.eks. for &aring; beregne median og gjennomsnitt
for l&oslash;nnen til de ulike stillingskategoriene, slik;</p>
<pre class="western">SELECT title, percentile_disc(0.5) <b>WITHIN GROUP (ORDER BY salary)</b>
AS median, round(avg(salary)) AS snitt
FROM titles t INNER JOIN salaries s ON t.emp_no=s.emp_no 
WHERE t.to_date = '9999-01-01' and s.to_date = '9999-01-01' 
GROUP BY title ORDER BY title;


       title        | median | snitt 
--------------------+--------+-------
 Assistant Engineer |  54775 | 57318
 Engineer           |  57050 | 59603
 Manager            |  74510 | 77724
 Senior Engineer    |  69498 | 70823
 Senior Staff       |  78674 | 80706
 Staff              |  65114 | 67331
 Technique Leader   |  66381 | 67507</pre><p class="merk">
Legg merke til at vi bruker <b>WITHIN GROUP (ORDERED BY &lt;felt&gt;)</b>
til &aring; sortere innen hver gruppe.</p>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc18238_1557834486"></a>
<font size="6" style="font-size: 24pt">Kapittel </font><font size="6" style="font-size: 24pt">7</font><br/>
Undersp&oslash;rringer</h1>
<h2 class="western"><a name="__RefHeading___Toc18240_1557834486"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Filtrere med undersp&oslash;rringer</h2>
<p class="western">SELECT-setninger er SQL-sp&oslash;rringer
(queries). Alle sp&oslash;rringer vi har gjort hittil er
enkeltst&aring;ende sp&oslash;rringer, dvs, enkle setninger som
henter data fra individuelle tabeller. Med SQL kan vi ogs&aring; lage
<b>undersp&oslash;rringer</b> (subqueries). Dette er sp&oslash;rringer
som er bygget inn i andre sp&oslash;rringer. Her er noen eksempler:</p>
<h3 class="western"><a name="__RefHeading___Toc54925_1647982490"></a><span style="font-weight: normal">Eksempel
1: </span><span style="font-weight: normal">H</span><span style="font-weight: normal">ent
</span><span style="font-weight: normal">titlene </span><span style="font-weight: normal">til
de ansatte i utvikling</span><span style="font-weight: normal">s</span><span style="font-weight: normal">avdelingen.</span></h3>
<p class="western"><br/>
Vi starter med <span style="font-style: normal"><span style="font-weight: normal">SELECT
DISTINCT(title)</span></span>, siden vi bare vil ha 1 av hver
kategori. Tabellen vi skal hente titlene fra er <i><span style="font-weight: normal">titles.
</span></i><span style="font-style: normal"><span style="font-weight: normal">Men
vi vil bare ha titlene til ansatte som jobber i avdelingen:
</span></span><i><span style="font-weight: normal">Development</span></i><span style="font-style: normal"><span style="font-weight: normal">.
En undersp&oslash;rring mot tabellen </span></span><i><span style="font-weight: normal">departments</span></i><span style="font-style: normal"><span style="font-weight: normal">
kan gi oss avdelingsnummeret til denne avdelingen, som er </span></span><i><span style="font-weight: normal">d007</span></i><span style="font-style: normal"><span style="font-weight: normal">.
Dette nummeret kan vi igjen bruke i en annen undersp&oslash;rring mot
tabellen </span></span><i><span style="font-weight: normal">dept_emp</span></i><span style="font-style: normal"><span style="font-weight: normal">
hvor ansatte er knyttet til avdelinger via feltene emp_no og dept_no,
hvor vi velger ut de ansatte som er knyttet til avdeling d007.  S&aring;
setter vi tabellen vi n&aring; har f&aring;tt med ansattnummerne inn
i parentesen til en IN-betingelse, slik at bare disse ansatte blir
valgt ut i hovedsp&oslash;rringen. Slik vil hele SQL-setningen se ut:
</span></span>
</p>
<pre class="western">SELECT DISTINCT(title) as Tittel <br/>
FROM titles <br/>
WHERE emp_no IN (SELECT emp_no FROM dept_emp WHERE dept_no IN (SELECT dept_no FROM departments where dept_name='Development'));

       Tittel <br/>
--------------------<br/>
 Engineer<br/>
 Senior Engineer<br/>
 Manager<br/>
 Assistant Engineer<br/>
 Staff<br/>
 Senior Staff<br/>
 Technique Leader<br/>
(7 rows) </pre><p class="merk">
<strong>MERK: </strong> En undersp&oslash;rring som skal brukes til &aring;
lage en liste til en IN-betingelse kan bare hente <strong>en enkelt
kolonne</strong>. Fors&oslash;ker vi &aring; hente flere kolonner i
undersp&oslash;rringen, f&aring;r vi en feilmelding!</p>
<h3 class="western"><a name="__RefHeading___Toc54927_1647982490"></a>Eksempel
2: Hent dagens l&oslash;nn for alle ansatte</h3>
<p class="western">Setningen nedenfor henter ansattnummer og dagens
l&oslash;nn for alle ansatte som er tilknyttet en avdeling (og
begrenser for enkelthets skyld resultatet til 10 rader).
Hovedsp&oslash;rringen henter ansattnummeret (<i>emp_no</i>) fra
tabellen <i>dept_emp</i>, og undersp&oslash;rringen henter ut l&oslash;nnen
fra tabellen <i>salaries</i>. WHERE-betingelsen i undersp&oslash;rringen
knytter l&oslash;nnen for hver rad til riktig ansattnummer.</p>
<pre class="western"><a name="yui_3_13_0_3_1473100571531_549"></a><strong><span style="font-weight: normal">SELECT emp_no AS Ansattnummer, </span></strong>
<strong><span style="font-weight: normal">(SELECT salary FROM salaries WHERE (salaries.emp_no = dept_emp.emp_no) AND extract(year from to_date) = 9999) AS &quot;L&oslash;nn&quot;</span></strong>
<strong><span style="font-weight: normal">FROM dept_emp WHERE extract(year from to_date) = 9999 limit 10;</span></strong>

&nbsp;ansattnummer | L&oslash;nn &nbsp;
--------------+-------
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10001 | 88958
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10002 | 72527
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10003 | 43311
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10004 | 74057
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10005 | 94692
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10006 | 59755
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10007 | 88070
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10009 | 94409
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10010 | 80324
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10012 | 54423</pre><p class="western">
Setningen over gir oss bare ansattnummer og l&oslash;nn. Vi kan
<font size="2" style="font-size: 10pt">utvide setningen</font> og
ogs&aring; hente navnet til de ansatte fra <i>employees</i>-tabellen,
slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no AS Ansattnummer, </span></strong>
<strong><span style="font-weight: normal"><br/>
(SELECT concat(first_name,' ',last_name) FROM employees WHERE employees.emp_no = dept_emp.emp_no) AS Navn,</span></strong>
<strong><span style="font-weight: normal"><br/>
(SELECT salary FROM salaries WHERE (salaries.emp_no = dept_emp.emp_no) AND extract(year from to_date) = 9999) AS &quot;L&oslash;nn&quot;</span></strong>
<strong><span style="font-weight: normal"><br/>
FROM dept_emp WHERE extract(year from to_date) = 9999 limit 10;</span></strong>

&nbsp;ansattnummer |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; navn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | L&oslash;nn &nbsp;
--------------+--------------------+-------
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10001 | Georgi Facello&nbsp;&nbsp;&nbsp;&nbsp; | 88958
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10002 | Bezalel Simmel&nbsp;&nbsp;&nbsp;&nbsp; | 72527
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10003 | Parto Bamford&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 43311
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10004 | Chirstian Koblick&nbsp; | 74057
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10005 | Kyoichi Maliniak&nbsp;&nbsp; | 94692
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10006 | Anneke Preusig&nbsp;&nbsp;&nbsp;&nbsp; | 59755
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10007 | Tzvetan Zielinski&nbsp; | 88070
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10009 | Sumant Peac&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 94409
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10010 | Duangkaew Piveteau | 80324
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10012 | Patricio Bridgland | 54423</pre><p class="western">
Her har vi bygget to undersp&oslash;rringer inn i en hoved-sp&oslash;rring.
Det er ingen begrensninger p&aring; hvor mange slike &laquo;subqueries&raquo;
vi kan bygge inn, men i praksis vil vi se at det kan ta uforholdsvis
mye tid med mange undersp&oslash;rringer av denne typen.</p>
<h3 class="western"><a name="__RefHeading___Toc16234_413252541"></a>Eksempel
3: Hente et resultat basert p&aring; en verdi vi ikke kjenner <br/>
(men
kan sl&aring; opp i en annen tabell)</h3>
<p class="western">En vanlig bruk av undersp&oslash;rringer er &aring;
s&oslash;ke etter kriterier vi ikke kjenner, men kan sl&aring; opp i
en annen tabell, Hvis vi for eksempel skulle hente ut hvor mange
ansatte som jobber i den avdelingen som Georgi Facello jobber i (uten
&aring; vite hvilken avdeling dette er), kan vi gj&oslash;re dette
slik;</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT count(*) from dept_emp WHERE extract(year from to_date) = 9999 AND</span></strong>
<strong><span style="font-weight: normal">dept_no = (SELECT dept_no from dept_emp WHERE extract(year from to_date) = 9999 AND emp_no = 10001 );</span></strong>

 count 
-------
&nbsp;61386</pre><p class="merk">
<strong>MERK:</strong> Vi m&aring; hente ut de som jobber i Facellos
avdeling idag, og vi m&aring; velge den avdelingen Facello jobber i
idag - derfor to betingelser med <strong>extract(year from to_date) =
9999</strong>.</p>
<h2 class="western"><a name="__RefHeading___Toc26939_4124954731"></a><strong><font color="#1b75bc">&#61609;</font></strong><strong>
</strong><strong>Bruke undersp&oslash;rringer </strong><strong>til &aring;
lage tabeller vi kan s&oslash;ke i med hovedsp&oslash;rringen</strong></h2>
<p class="western"><strong><span style="font-weight: normal">Siden
alle SELECT-setninger gir oss tilbake en tabell, kan vi bruke en
undersp&oslash;r</span></strong><strong><span style="font-weight: normal">r</span></strong><strong><span style="font-weight: normal">ing
til &aring; lage en tabell som vi s&aring; kan s&oslash;ke i med en
hovedsp&oslash;rring. </span></strong><strong><span style="font-weight: normal">Her
er et par eksempler </span></strong><strong><font size="2" style="font-size: 10pt"><span style="font-weight: normal">som
viser</span></font></strong><strong><span style="font-weight: normal">
n&aring;r dette kan v&aelig;re nyttig:</span></strong></p>
<p class="western"><strong><span style="font-weight: normal">H</span></strong><strong><span style="font-weight: normal">vis
vi vil vite hvor mange som har sluttet i bedriften, kan vi telle opp
alle som ikke har l&oslash;nn i dag. Det kan vi gj&oslash;re ved
f&oslash;rst &aring; liste ut alle som ikke har max(to_date) satt til
9999-01-01, </span></strong><strong><span style="font-weight: normal">som
betyr at de ikke har noen l&oslash;nn som ikke er avsluttet med en
sluttdato, mao at de ikke f&aring;r l&oslash;nn n&aring;</span></strong><strong><span style="font-weight: normal">.
Hvor mange dette er, kan vi se ved &aring; legge til en </span></strong><strong><i><span style="font-weight: normal">select
count(*) from</span></i></strong><strong><span style="font-weight: normal">
 f&oslash;r den opprinnelige setningen, som n&aring; blir en
undersp&oslash;rring, og m&aring; st&aring; i parentes. Den m&aring;
ogs&aring; ha e</span></strong><strong><span style="font-weight: normal">t</span></strong><strong><span style="font-weight: normal">
alias </span></strong><strong><span style="font-weight: normal">(</span></strong><strong><span style="font-weight: normal">selv
om vi ikke bruker denne til noe</span></strong><strong><span style="font-weight: normal">)</span></strong><strong><span style="font-weight: normal">.
</span></strong>
</p>
<p class="western"><strong><span style="font-weight: normal">Slik
lister vi ut alle som ikke har l&oslash;nn idag, dvs. som har
sluttet. (Her begrenset til 5 rader) :</span></strong></p>
<pre class="western"><strong><font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt"><span style="font-weight: normal">SELECT</span></font></font></strong><strong><span style="font-weight: normal"> emp_no, max(to_date) </span></strong><strong><span style="font-weight: normal">FROM</span></strong><strong><span style="font-weight: normal"> </span></strong><strong><span style="font-weight: normal">salaries</span></strong><strong><span style="font-weight: normal"> </span></strong><strong><font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt"><span style="font-weight: normal">GROUP BY</span></font></font></strong><strong><span style="font-weight: normal"> emp_no </span></strong><strong><span style="font-weight: normal">HAVING</span></strong><strong><span style="font-weight: normal"> max(to_date) != '9999-01-01' LIMIT 5;</span></strong>

<strong><span style="font-weight: normal">emp_no  |         max         </span></strong>
<strong><span style="font-weight: normal">--------+---------------------</span></strong>
<strong>  <span style="font-weight: normal">10008 | 2000-07-31 00:00:00</span></strong>
<strong>  <span style="font-weight: normal">10011 | 1996-11-09 00:00:00</span></strong>
<strong>  <span style="font-weight: normal">10015 | 1993-08-22 00:00:00</span></strong>
<strong>  <span style="font-weight: normal">10021 | 2002-07-15 00:00:00</span></strong>
<strong>  <span style="font-weight: normal">10025 | 1997-10-15 00:00:00</span></strong></pre><p class="merk">
<strong>MERK: </strong>Ved &aring; gruppere p&aring; emp_no f&aring;r
vi max(to_date) for hver ansatt. Dersom denne er satt til 9999-01-01,
betyr det at vedkommende fremdeles har denne l&oslash;nnen, og mao
fremdeles jobber i bedriften. S&aring; filtrerer vi ut de gruppene,
dvs. de ansatte, hvor max(to_date) ikke er lik 9999-01-01, dvs. hvor
de ikke har en n&aring;v&aelig;rende l&oslash;nn, mao har sluttet.
N&oslash;kkelordet HAVING brukes til &aring; filtrere ut grupper.</p>
<p class="western">Som vi ser er det ingen av disse p&aring; listen
som f&aring;r l&oslash;nn idag. Men hvor mange er det av dem? Det kan
vi finne ved &aring; lage en SELECT-setning som teller opp antall
rader i tabellen, som vi setter som en undersp&oslash;rring, slik:<strong>
</strong>
</p>
<pre class="western"><strong><font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt"><span style="font-weight: normal">SELECT</span></font></font></strong><strong><span style="font-weight: normal"> count(*) from </span></strong>

<strong><span style="font-weight: normal">(</span></strong><strong><font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt"><span style="font-weight: normal">SELECT</span></font></font></strong><strong><span style="font-weight: normal"> emp_no, max(to_date) </span></strong><strong><span style="font-weight: normal">FROM</span></strong><strong><span style="font-weight: normal"> </span></strong><strong><span style="font-weight: normal">salaries</span></strong><strong><span style="font-weight: normal"> </span></strong><strong><font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt"><span style="font-weight: normal">GROUP BY</span></font></font></strong><strong><span style="font-weight: normal"> emp_no </span></strong><strong><span style="font-weight: normal">HAVING</span></strong><strong><span style="font-weight: normal"> max(to_date) != '9999-01-01') </span></strong><strong><span style="font-weight: normal">as slut</span></strong><strong><span style="font-weight: normal">t</span></strong><strong><span style="font-weight: normal">et</span></strong><strong><span style="font-weight: normal"> ; <br/>
</span></strong>
<strong><span style="font-weight: normal">count &nbsp;<br/>
------- <br/>
59900 <br/>
(1 row) </span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Vi ser at det er 59 900
ansatte som ikke lenger har l&oslash;nn. Vi kan ogs&aring; sjekke
hvor mange som ikke er tilknyttet en avdeling, ved &aring; kj&oslash;re
det samme s&oslash;ket mot tabellen </span></strong><strong><i><span style="font-weight: normal">dept_emp
&ndash; </span></i></strong><strong><span style="font-style: normal"><span style="font-weight: normal">tabellen
som viser hvem som  jobber i hvilken avdeling. </span></span></strong><strong><span style="font-style: normal"><span style="font-weight: normal">Er
de ikke tilknyttet en avdeling, er de ikke i jobb (i denne
databasen). </span></span></strong><strong><span style="font-style: normal"><span style="font-weight: normal">Vi
f&aring;r det samme tallet &ndash; </span></span></strong><strong><span style="font-style: normal"><span style="font-weight: normal">det
er 59 900 som ikke er tilknyttet noen avdeling, dvs. som ikke har
max(to_date) satt til 9999-01-01</span></span></strong><strong><span style="font-style: normal"><span style="font-weight: normal">.
</span></span></strong>
</p>
<p class="western"><strong><span style="font-style: normal"><span style="font-weight: normal">Vi
kan p&aring; tilsvarende m&aring;te finne ut hvor mange som har
sluttet i leder-stillinger, ved &aring; kj&oslash;re samme s&oslash;k
mot </span></span></strong><strong><i><span style="font-weight: normal">dept_manager</span></i></strong><strong><span style="font-style: normal"><span style="font-weight: normal">
-tabellen:</span></span></strong></p>
<pre class="western"><strong><font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt"><span style="font-weight: normal">SELECT</span></font></font></strong><strong><span style="font-weight: normal"> count(*) </span></strong><strong><span style="font-weight: normal">F</span></strong><strong><font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt"><span style="font-weight: normal">ROM</span></font></font></strong><strong><span style="font-weight: normal"> </span></strong>

<strong><span style="font-weight: normal">(</span></strong><strong><span style="font-weight: normal">S</span></strong><strong><font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt"><span style="font-weight: normal">ELECT</span></font></font></strong><strong><span style="font-weight: normal"> emp_no, max(to_date) </span></strong><strong><span style="font-weight: normal">FROM</span></strong><strong><span style="font-weight: normal"> dept_manager </span></strong><strong><span style="font-weight: normal">GROUP BY</span></strong><strong><span style="font-weight: normal"> emp_no </span></strong><strong><span style="font-weight: normal">HAVING</span></strong><strong><span style="font-weight: normal"> max(to_date) != '9999-01-01') t ; &nbsp;&nbsp;&nbsp;<br/>
</span></strong>
<strong><span style="font-weight: normal">count &nbsp;<br/>
------- <br/>
&nbsp;&nbsp;&nbsp;15 <br/>
(1 row)</span></strong><strong> </strong></pre><p class="western">
<strong><span style="font-weight: normal">Vi ser at det er 15 ansatte
som har v&aelig;rt leder for en avdeling, men ikke er det lenger.
</span></strong><strong><span style="font-weight: normal">(Her ga vi
tabellen som undersp&oslash;rringen produserer aliaset </span></strong><strong><b>t</b></strong><strong><span style="font-weight: normal">,
og droppet n&oslash;kkelordet &laquo;as&raquo;, for &aring; vise at
det ogs&aring; g&aring;r fint, og i tillegg er kompatibelt med
Oracle).</span></strong><strong><b> </b></strong>
</p>
<p class="western"><strong><span style="font-weight: normal">Ved &aring;
kj&oslash;re undersp&oslash;rringen alene, ser vi hvem </span></strong><strong><span style="font-weight: normal">det</span></strong><strong><span style="font-weight: normal">
er </span></strong><strong><span style="font-weight: normal">som har
v&aelig;rt avdelingsleder, men ikke er det lenger</span></strong><strong><span style="font-weight: normal">:
 </span></strong>
</p>
<pre class="western"><strong><span style="font-weight: normal">select emp_no, max(to_date) from dept_manager group by emp_no having max(to_date) != '9999-01-01' ; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></strong><strong><br/>
</strong>
<strong><span style="font-weight: normal">emp_no | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
--------+--------------------- <br/>
111035 | 1991-03-07 00:00:00 <br/>
110303 | 1988-09-09 00:00:00 <br/>
111692 | 1988-10-17 00:00:00 <br/>
110386 | 1996-08-30 00:00:00 <br/>
111877 | 1996-01-03 00:00:00 <br/>
110725 | 1989-05-06 00:00:00 <br/>
110800 | 1994-06-28 00:00:00 <br/>
111400 | 1991-04-08 00:00:00 <br/>
110022 | 1991-10-01 00:00:00 <br/>
111784 | 1992-09-08 00:00:00 <br/>
110085 | 1989-12-17 00:00:00 <br/>
110344 | 1992-08-02 00:00:00 <br/>
110183 | 1992-03-21 00:00:00 <br/>
110511 | 1992-04-25 00:00:00 <br/>
110765 | 1991-09-12 00:00:00 <br/>
(15 rows) </span></strong></pre><p class="western">
<strong><span style="font-weight: normal">La oss sjekke n&aring;r den
f&oslash;rste p&aring; listen var leder, </span></strong><strong><span style="font-weight: normal">og
hvilken avdeling han/hun ledet, ved &aring; s&oslash;ke opp
ansattnummeret i </span></strong><strong><span style="font-weight: normal">
</span></strong><strong><i><span style="font-weight: normal">dept_manager</span></i></strong><strong><span style="font-weight: normal">
- tabellen </span></strong>
</p>
<pre class="western"><strong><font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt"><span style="font-weight: normal">SELECT</span></font></font></strong><strong><span style="font-weight: normal"> * </span></strong><strong><span style="font-weight: normal">FROM</span></strong><strong><span style="font-weight: normal"> dept_manager </span></strong><strong><span style="font-weight: normal">WHERE</span></strong><strong><span style="font-weight: normal"> emp_no = 111035; <br/>
</span></strong>
<strong><span style="font-weight: normal">dept_no | emp_no | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from_date &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_date &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
---------+--------+---------------------+--------------------- <br/>
d007 &nbsp;&nbsp;&nbsp;| 111035 | 1985-01-01 00:00:00 | 1991-03-07 00:00:00 <br/>
(1 row)</span></strong><strong> </strong></pre><p class="western">
<strong><span style="font-weight: normal">Vi ser at ansatt nummer
111035 var leder for avdeling d007 fra 1 januar 1985 til 7. mars
1991. Hva gjorde vedkommende etter dette? Vi kan s&oslash;ke opp
ansattnummeret i </span></strong><strong><i><span style="font-weight: normal">dept_emp</span></i></strong><strong><span style="font-weight: normal">
&ndash; tabellen for &aring; se om han/hun fremdeles er ansatt i
bedriften:</span></strong></p>
<pre class="western"><strong><br/>
</strong><strong><font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt"><span style="font-weight: normal">SELECT</span></font></font></strong><strong><span style="font-weight: normal"> * </span></strong><strong><span style="font-weight: normal">FROM</span></strong><strong><span style="font-weight: normal"> dept_emp </span></strong><strong><span style="font-weight: normal">WHERE</span></strong><strong><span style="font-weight: normal"> emp_no = 111035; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
</span></strong>
<strong><span style="font-weight: normal">emp_no | dept_no | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from_date &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_date &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
--------+---------+---------------------+--------------------- <br/>
111035 | d007 &nbsp;&nbsp;&nbsp;| 1985-01-01 00:00:00 | 9999-01-01 00:00:00 <br/>
(1 row)</span></strong></pre><p class="western">
Som vi ser jobber vedkommende der fremdeles, som ansatt i avdelingen
han eller hun ledet en periode.</p>
<h2 class="western"><a name="__RefHeading___Toc5699_920682125"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Bruke undersp&oslash;rringer til &aring; lage beregnede kolonner</h2>
<p class="western">En annen m&aring;te &aring; bruke Subqueries p&aring;
er for &aring; lage beregnede kolonner. Vi kan lage en SELECT-setning
som henter ut data til en beregnet kolonne, f.eks. slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT dept_name as Avdeling,</span></strong>
<strong>  <span style="font-weight: normal">(SELECT COUNT(*)</span></strong>
<strong>          <span style="font-weight: normal">FROM dept_emp</span></strong>
<strong>          <span style="font-weight: normal">WHERE dept_no = departments.dept_no </span></strong>
<strong><span style="font-weight: normal">	      AND extract(year </span></strong><strong><span style="font-weight: normal">FROM</span></strong><strong><span style="font-weight: normal"> to_date)=9999) AS Ansatte</span></strong>
<strong>  <span style="font-weight: normal">FROM departments</span></strong>
<strong>  <span style="font-weight: normal">ORDER BY Avdeling;&nbsp;</span></strong>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; avdeling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ansatte 
--------------------+---------
&nbsp;Customer Service&nbsp;&nbsp; |&nbsp;&nbsp; 17569
&nbsp;Development&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 61386
&nbsp;Finance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 12437
&nbsp;Human Resources&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 12898
&nbsp;Marketing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 14842
&nbsp;Production&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 53304
&nbsp;Quality Management |&nbsp;&nbsp; 14546
&nbsp;Research&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 15441
&nbsp;Sales&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 37701</pre><p class="western">
SQL-setningen over henter to kolonner for hver avdeling i tabellen
<em>departments: </em>Navnet til avdelingen og<em> </em>antall
ansatte i avdelingen. Antall ansatte er beregnet ut fra en
undersp&oslash;rring som er satt i parentes og som hentes til en
alias-kolonne. Undersp&oslash;rringen blir utf&oslash;rt for hver
avdeling som hentes, og den teller opp antall ansatte den aktuelle
avdelingen har.</p>
<p class="merk"><strong>MERK: </strong>Hvis to kolonner fra ulike
tabeller har samme navn, og disse skal bruke i samme SQL-setning, m&aring;
vi angi hvilken tabell de er hentet fra ved &aring; skrive
tabellnavnet f&oslash;r feltnavnet, og et punktum mellom.</p>
<p class="western"><br/>
<br/>

</p>
<h1 class="western"><a name="__RefHeading___Toc18242_1557834486"></a><a name="yui_3_17_2_1_1474496206645_73"></a>
<font size="6" style="font-size: 24pt">Kapittel </font><font size="6" style="font-size: 24pt">8<br/>
</font>Joins</h1>
<h2 class="western"><a name="__RefHeading___Toc18244_1557834486"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Koble data fra flere tabeller med Join-setninger</h2>
<p class="western">For &aring; lage en join mellom to tabeller m&aring;
man spesifisere alle tabellene som er involvert og forholdet mellom
dem, dvs. hvilke felt som er like i tabellene og kan brukes til &aring;
koble dem til hverandre. Som regel vil et felt som er definert som en
<b>fremmedn&oslash;kkel </b><span style="font-weight: normal">i en
tabell referere til et felt som er definert som </span><b>prim&aelig;rn&oslash;kkel
</b><span style="font-weight: normal">i en annen tabell, og dermed
vet vi at disse feltene kan brukes til &aring; koble tabellene
sammen. </span><span style="font-weight: normal">Definerte n&oslash;kler
</span><span style="font-weight: normal">er en stor hjelp for &aring;</span><span style="font-weight: normal">
sikre integriteten mellom tabellene som skal kobles sammen, men de er
ikke n&oslash;dvendige for &aring; lage en join. </span><span style="font-weight: normal">Det
er ogs&aring; som regel n&oslash;dvendig med et felt &aring; &laquo;joine
p&aring;&raquo;, dvs. et felt som finnes i begge tabellene som skal
kobles sammen og hvor en rad kan ha samme verdi i begge tabellene.
F.eks. kan to tabeller med persondata &laquo;joines p&aring;&raquo;
et felles felt: personnummer, eller to tabeller med produkter &laquo;joines
p&aring;&raquo; et felles felt: produkt_id, osv. </span><span style="font-weight: normal">Det
er teoretisk mulig &aring; lage en join mellom to tabeller </span><i><span style="font-weight: normal">uten</span></i><span style="font-style: normal"><span style="font-weight: normal">
et felles felt, men da kan det kun lages en spesiel type join
(cartesiansk join) som er et kryssprodukt mellom alle feltene i begge
tabellene (cartesiansk produkt), og det er stort sett aldri det vi
vil ha. </span></span>
</p>
<h3 class="western"><a name="__RefHeading___Toc17607_2563936057"></a>Ulike
typer joins</h3>
<p class="western">Joins bygger p&aring; teoriene om <b>matematiske
sett</b><span style="font-weight: normal">,</span><b> </b><span style="font-weight: normal">som
ligger utenfor denne bokens omr&aring;de, men et par s&oslash;k p&aring;
internet</span><span style="font-weight: normal">t</span><span style="font-weight: normal">
kan gi fine aha-opplevelser hvis de ulike typene av joins oppleves
som vanskelig &aring; skille fra hverandre. Vi skal her n&oslash;ye
oss med &aring; gi en enkel beskrivelse av de vanligste join-typene,
illustrert med noen eksempler og visuelle venn-diagrammer
(overlappende sirkler).</span> De fargede omr&aring;dene i
diagrammene symboliserer omr&aring;der hvor data blir hentet fra, de
hvite omr&aring;dene det som ikke blir hentet. 
</p>
<p class="western"><br/>
<br/>

</p>
<h2 class="western" style="page-break-before: always"><a name="__RefHeading___Toc17609_2563936057"></a>
<strong><font color="#1b75bc">&#61609;</font></strong> INNER JOIN</h2>
<p class="western">En INNER JOIN er en type join som henter rader som
har verdi i alle tabellene vi kobler sammen. Lager vi en join mellom
to tabeller, vil <b>kun de radene som har verdi i begge tabellene</b>
bli tatt med i resultatet. Dette kan illustreres grafisk slik:</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><img src="Introduksjon_til_SQL_html_f5b2e2a1a777586.gif" name="Bilde8" align="left" width="278" height="211" border="0"/>
<br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"> 
</p>
<p class="western"><br/>
<br/>

</p>
<p class="western">En INNER JOIN kan skrives p&aring; to ulike m&aring;ter.
Vi kan bruke en <b>INNER JOIN-sy</b><b>n</b><b>taks</b> eller en
<b>EQUIJOIN-syntaks</b>. Her er et eksempel skrevet med begge
syntakser:</p>
<h3 class="western"><a name="__RefHeading___Toc17613_2563936057"></a>INNER
JOIN skrevet med EQUIJOIN-syntaks</h3>
<p class="western">I sp&oslash;rringen nedenfor henter vi ut fornavn
etternavn og l&oslash;nn for de ansatte ved &aring; koble sammen
tabellene <i><b>employees</b></i> og <i><b>salaries. </b></i><span style="font-style: normal"><span style="font-weight: normal">Vi
lister f&oslash;rst opp feltene vi vil hente (med komma mellom
feltene, men ikke komma etter siste felt) og s&aring; setter vi inn
en WHERE-betingelse som sikrer at vi kobler riktig l&oslash;nn til
riktig navn. Til slutt i setningen tar vi med en betingelse som sier
at vi vil ha </span></span><i><b>dagens l&oslash;nn</b></i><span style="font-style: normal"><span style="font-weight: normal">,
dvs. l&oslash;nn som har feltet </span></span><i><b>to_date</b></i><span style="font-style: normal"><span style="font-weight: normal">
 satt til 9999-01-01. For eksemplets skyld henter vi bare de 5 f&oslash;rste
radene i resultatet:</span></span></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT first_name, last_name, salary FROM employees, salaries </span></strong>
<strong><b>WHERE employees.emp_no = salaries.emp_no</b></strong><strong><span style="font-weight: normal"> </span></strong>
<strong><span style="font-weight: normal">AND to_date = '9999-01-01' LIMIT 5;</span></strong>
<strong><span style="font-weight: normal"><br/>
+------------+-----------+--------+ <br/>
| first_name | last_name | salary | <br/>
+------------+-----------+--------+ <br/>
| Georgi &nbsp;&nbsp;&nbsp;&nbsp;| Facello &nbsp;&nbsp;| &nbsp;88958 | <br/>
| Bezalel &nbsp;&nbsp;&nbsp;| Simmel &nbsp;&nbsp;&nbsp;| &nbsp;72527 | <br/>
| Parto &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Bamford &nbsp;&nbsp;| &nbsp;43311 | <br/>
| Chirstian &nbsp;| Koblick &nbsp;&nbsp;| &nbsp;74057 | <br/>
| Kyoichi &nbsp;&nbsp;&nbsp;| Maliniak &nbsp;| &nbsp;94692 | <br/>
+------------+-----------+--------+</span></strong></pre><p class="merk">
<strong>MERK:</strong> Her m&aring; vi spesifisere hele navnet til
kolonnene <em><strong>emp_no</strong></em>, dvs. p&aring; formen:
<em><strong>tabellnavn.kolonnenavn</strong></em>, siden
prim&aelig;rn&oslash;kkelen og fremmedn&oslash;kkelen som skal kobles
sammen, har samme kolonne-navn.</p>
<p class="merk"><b>WHERE-betingelsen</b> er ekstremt viktig her. Uten
den vil alle feltene i hver tabell lenkes opp mot hverandre i en
potensielt enorm tabell (som kalles en en <b>CROSS JOIN</b>, eller et
Cartesiansk produkt), som i de aller fleste tilfeller ikke er det vi
vil ha.</p>
<h3 class="western"><a name="__RefHeading___Toc4436_762629072"></a>INNER
JOIN skrevet med INNER JOIN-syntaks</h3>
<p class="western">Setningen under gir det samme resultatet ved &aring;
bruke en <b>INNER JOIN</b><b>-syntaks</b><span style="font-weight: normal">,
som</span><b> </b>skrives p&aring; denne m&aring;ten:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT first_name, last_name, salary FROM employees &nbsp;</span></strong>
<strong><b>INNER JOIN</b></strong><strong><span style="font-weight: normal"> salaries </span></strong><strong><b>ON</b></strong><strong><span style="font-weight: normal"> employees.emp_no = salaries.emp_no </span></strong>
<strong><span style="font-weight: normal">WHERE to_date = '9999-01-01' LIMIT 5; &nbsp;&nbsp;<br/>
</span></strong>
<strong><span style="font-weight: normal">+------------+-----------+--------+ <br/>
| first_name | last_name | salary | <br/>
+------------+-----------+--------+ <br/>
| Georgi &nbsp;&nbsp;&nbsp;&nbsp;| Facello &nbsp;&nbsp;| &nbsp;88958 | <br/>
| Bezalel &nbsp;&nbsp;&nbsp;| Simmel &nbsp;&nbsp;&nbsp;| &nbsp;72527 | <br/>
| Parto &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Bamford &nbsp;&nbsp;| &nbsp;43311 | <br/>
| Chirstian &nbsp;| Koblick &nbsp;&nbsp;| &nbsp;74057 | <br/>
| Kyoichi &nbsp;&nbsp;&nbsp;| Maliniak &nbsp;| &nbsp;94692 | <br/>
+------------+-----------+--------+</span></strong></pre><p class="western">
Den generelle INNER JOIN-syntaksen er slik:</p>
<pre class="western">SELECT &lt;felt1, felt2, felt3 ...&gt; FROM &lt;tabell1&gt;
<b>INNER JOIN</b> &lt;tabell2&gt; <b>ON</b> &lt;tabell1.felt&gt; = &lt;tabell2.felt&gt;;</pre><p class="merk">
<b>MERK: </b><span style="font-weight: normal">Med INNER JOIN-syntaks
bruker vi ikke en WHERE-betingelse til &aring; angi hvilke felt som
skal brukes til &aring; lenke tabellene sammen, men n&oslash;kkelordet
</span><b>ON </b><span style="font-weight: normal">etterfulgt av
hvilke felt som skal v&aelig;re like i de to tabellene som skal
lenkes sammen. </span>
</p>
<h4 class="western"><a name="__RefHeading___Toc19107_2730267216"></a>Hvilken
syntaks er best for &aring; skrive en INNER JOIN-setning?</h4>
<p class="western">Det er ingen forskjell i utf&oslash;relsen av en
INNER JOIN om du skriver den med EQUIJOIN-syntaks eller INNER
JOIN-syntaks, s&aring; du kan velge den du synes er enklest &aring;
foholde deg til. Mange l&aelig;reb&oslash;ker anbefaler &aring; bli
vant til &aring; skrive INNER JOIN-syntaksen, siden den er mer lik
syntaksen for OUTER JOINS (se neste punkt)</p>
<h2 class="western"><a name="__RefHeading___Toc19109_2730267216"></a><strong><font color="#1b75bc">&#61609;</font></strong>
OUTER JOIN</h2>
<p class="western"><b>Outer joins</b> brukes n&aring;r man vil hente
alle rader fra en annen tabell, ogs&aring; de som <em>ikke</em> har
relaterte rader i den f&oslash;rste tabellen. Man kan skrive dette
som LEFT OUTER JOIN eller RIGHT OUTER JOIN ettersom om tabellen man
vil hente alle radene fra st&aring;r til venstre eller h&oslash;yre
for n&oslash;kkelordene OUTER JOIN i setningen. Man kan ogs&aring;
velge alle radene fra begge tabellene ved &aring; lage en FULL OUTER
JOIN, som er en kombinasjon av en LEFT OUTER JOIN og en RIGHT OUTER
JOIN. La oss se n&aelig;rmere p&aring; hvordan dette fungerer i teori
og praksis.</p>
<h3 class="western"><a name="__RefHeading___Toc17615_2563936057"></a>LEFT
OUTER JOIN</h3>
<p class="western">En LEFT OUTER JOIN er en kobling mellom to
tabeller der det hentes alle rader fra den tabellen som er skrevet
til venstre i setningen, mens det fra tabellen som er skrevet til
h&oslash;yre i setningen kun hentes rader som har verdi i den andre
tabellen. Dette kan illustreres grafisk slik:</p>
<p class="western"><img src="Introduksjon_til_SQL_html_24c6153cacc3fe3c.gif" name="Bilde9" align="left" width="278" height="211" border="0"/>
<br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<h3 class="western"><a name="__RefHeading___Toc17617_2563936057"></a>RIGHT
OUTER JOIN</h3>
<p class="western">En RIGHT OUTER JOIN er en kobling mellom to
tabeller der det hentes alle rader fra den tabellen som er skrevet
til h&oslash;yre i setningen, mens det fra tabellen som er skrevet
til venstre i setningen kun hentes rader som har verdi i den andre
tabellen. Dette kan illustreres grafisk slik:</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><img src="Introduksjon_til_SQL_html_f6429a52f2afa223.gif" name="Bilde10" align="left" width="278" height="211" border="0"/>
<br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<h3 class="western"><br/>
<br/>

</h3>
<h3 class="western"><a name="__RefHeading___Toc17619_2563936057"></a>FULL
OUTER JOIN</h3>
<p class="western"><strong><span style="font-weight: normal">En </span></strong><strong>FULL
OUTER JOIN </strong>henter alle rader fra begge tabellene, b&aring;de
den til venstre og den til h&oslash;yre i sp&oslash;rresetningen.
Dette kan illustreres grafisk slik:</p>
<p class="western"><img src="Introduksjon_til_SQL_html_a7b645aa8bf54d93.gif" name="Bilde11" align="left" width="278" height="211" border="0"/>
<br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western">Her er et eksempel p&aring; en FULL OUTER JOIN:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">SELECT count(*) FROM dept_emp AS de </span></strong><strong><b>FULL OUTER JOIN</b></strong><strong><span style="font-weight: normal"> employees AS e ON e.emp_no = de.emp_no;</span></strong></pre><p class="merk">
<strong>MERK: </strong>Ikke alle DBMSer st&oslash;tter <strong>FULL
OUTER JOIN</strong>s. <strong>MySQL / MariaDB</strong> gj&oslash;r
det f.eks. <strong>ikke,</strong> mens Microsoft SQL Server og Oracle
gj&oslash;r det. Man kan lage en tilsvarende FULL OUTER JOIN i MySQL
/ MariaDB med bruk av UNION.&nbsp; (Jfr. punktet om UNION og UNION
ALL nedenfor).</p>
<p class="western" style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc17621_2563936057"></a><strong><font color="#1b75bc">&#61609;</font></strong>
NATURAL JOIN</h2>
<p class="western">En NATURAL JOIN er en join hvor man ikke
spesifiserer hvilke felt det skal &laquo;joines p&aring;&raquo;, men
hvor RDBMSen selv finner felt som har samme navn og datatype til &aring;
lage en join. Dette forenkler syntaksen for &aring; skrive en
join-setning betraktelig, men det t&aring;kelegger hvilke felt som
brukes til en join. Feil kan oppst&aring; hvis det for eksempel
legges til et felt i en av tabellene som har sammen navn og datatype
som et felt i den andre tabellen, noe som vil medf&oslash;re at det
blir laget en join p&aring; dette nye feltet i tillegg til den
eksisterende join-betingelsen, og resultatet er kort skissert
&oslash;delagt. S&aring; uansett hvor fristende det kan virke &aring;
bruke NATURAL JOINs, anbefales det <i><b>ikke </b></i><span style="font-style: normal"><span style="font-weight: normal">av
denne forfatteren. Ta heller bryet med &aring; spesifis&eacute;re
feltene som skal brukes til en join, s&aring; vil du kunne unng&aring;
ubehagelige overraskelser senere. </span></span>
</p>
<p class="western"><span style="font-style: normal"><span style="font-weight: normal">Men
</span></span><span style="font-style: normal"><span style="font-weight: normal">siden
NATURAL JOIN er en del av SQL-standarden skal vi gi noen enkle
eksempler p&aring; syntaksen, som vi skal se er relativt enkel:</span></span></p>
<pre class="western">SELECT first_name, last_name, dept_no 
FROM employees <b>NATURAL JOIN</b> dept_emp;

 first_name | last_name | dept_no 
------------+-----------+---------
 Georgi     | Facello   | d005
 Bezalel    | Simmel    | d007
 Parto      | Bamford   | d004
 Chirstian  | Koblick   | d004
 Kyoichi    | Maliniak  | d003<span style="font-style: normal"><span style="font-weight: normal"> </span></span>
 <span style="font-style: normal"><span style="font-weight: normal">.....        .....    </span></span>   ....</pre><p class="western">
Setningen over vil lage en <b>NATURAL INNER JOIN</b>, siden det er
default-innstillingen, og bruke feltet <i><b>emp_no</b></i> til
join-betingelsen, siden det har same navn og datatype for de to
tabellene. For lage en LEFT, RIGHT eller FULL OUTER JOIN er syntaksen
slik:</p>
<pre class="western">SELECT first_name, last_name, dept_no 
FROM employees <b>NATURAL LEFT JOIN</b> dept_emp;

SELECT first_name, last_name, dept_no 
FROM employees <b>NATURAL RIGHT JOIN</b> dept_emp;

SELECT first_name, last_name, dept_no 
FROM employees <b>NATURAL FULL JOIN</b> dept_emp; </pre><h2 class="western">
<a name="__RefHeading___Toc4438_762629072"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Joins med flere enn to tabeller</h2>
<p class="western">Det er ingen begrensninger i SQL i forhold til
hvor mange tabeller man kan koble sammen i en SELECT-setning. Reglene
for sammenkobling er de samme. F&oslash;rst m&aring; alle tabellene
listes, og deretter defineres forholdet mellom dem, f.eks. slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT first_name, last_name, title, titles.from_date, salary, salaries.from_date </span></strong>
<strong><span style="font-weight: normal">FROM employees, salaries, titles<br/>
WHERE employees.emp_no = salaries.emp_no </span></strong>
<strong><span style="font-weight: normal">AND employees.emp_no = titles.emp_no </span></strong>
<strong><span style="font-weight: normal">AND salaries.to_date = '9999-01-01' </span></strong>
<strong><span style="font-weight: normal">AND titles.to_date = '9999-01-01' LIMIT 5;</span></strong>
<strong><span style="font-weight: normal"><br/>
</span></strong><strong><font size="1" style="font-size: 8pt"><span style="font-weight: normal">+------------+-----------+-----------------+------------+--------+------------+ <br/>
| first_name | last_name | title &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| from_date &nbsp;| salary | from_date &nbsp;| <br/>
+------------+-----------+-----------------+------------+--------+------------+ <br/>
| Georgi &nbsp;&nbsp;&nbsp;&nbsp;| Facello &nbsp;&nbsp;| Senior Engineer | 1986-06-26 | &nbsp;88958 | 2002-06-22 | <br/>
| Bezalel &nbsp;&nbsp;&nbsp;| Simmel &nbsp;&nbsp;&nbsp;| Staff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1996-08-03 | &nbsp;72527 | 2001-08-02 | <br/>
| Parto &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Bamford &nbsp;&nbsp;| Senior Engineer | 1995-12-03 | &nbsp;43311 | 2001-12-01 | <br/>
| Chirstian &nbsp;| Koblick &nbsp;&nbsp;| Senior Engineer | 1995-12-01 | &nbsp;74057 | 2001-11-27 | <br/>
| Kyoichi &nbsp;&nbsp;&nbsp;| Maliniak &nbsp;| Senior Staff &nbsp;&nbsp;&nbsp;| 1996-09-12 | &nbsp;94692 | 2001-09-09 | <br/>
+------------+-----------+-----------------+------------+--------+------------+</span></font></strong></pre><p class="western">
<br/>
Eller med <strong>INNER JOIN</strong> - syntaksen, slik:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT first_name, last_name, title, titles.from_date, salary, salaries.from_date FROM employees <br/>
INNER JOIN salaries ON employees.emp_no = salaries.emp_no<br/>
INNER JOIN titles ON employees.emp_no = titles.emp_no <br/>
WHERE salaries.to_date = '9999-01-01' <br/>
AND titles.to_date = '9999-01-01' LIMIT 5; </span></strong>
<strong><font size="1" style="font-size: 8pt"><span style="font-weight: normal"><br/>
+------------+-----------+-----------------+------------+--------+------------+ <br/>
| first_name | last_name | title &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| from_date &nbsp;| salary | from_date &nbsp;| <br/>
+------------+-----------+-----------------+------------+--------+------------+ <br/>
| Georgi &nbsp;&nbsp;&nbsp;&nbsp;| Facello &nbsp;&nbsp;| Senior Engineer | 1986-06-26 | &nbsp;88958 | 2002-06-22 | <br/>
| Bezalel &nbsp;&nbsp;&nbsp;| Simmel &nbsp;&nbsp;&nbsp;| Staff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1996-08-03 | &nbsp;72527 | 2001-08-02 | <br/>
| Parto &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Bamford &nbsp;&nbsp;| Senior Engineer | 1995-12-03 | &nbsp;43311 | 2001-12-01 | <br/>
| Chirstian &nbsp;| Koblick &nbsp;&nbsp;| Senior Engineer | 1995-12-01 | &nbsp;74057 | 2001-11-27 | <br/>
| Kyoichi &nbsp;&nbsp;&nbsp;| Maliniak &nbsp;| Senior Staff &nbsp;&nbsp;&nbsp;| 1996-09-12 | &nbsp;94692 | 2001-09-09 | <br/>
+------------+-----------+-----------------+------------+--------+------------+</span></font></strong></pre><h4 class="western">
<a name="__RefHeading___Toc16236_413252541"></a>Et mer komplekst
eksempel:</h4>
<p class="western">I setningen nedenfor vil vi hente ut en oversikt
over bedriftens avdelinger, med navn p&aring; avdelingen, navn, kj&oslash;nn
og alder p&aring; avdelingslederen, samt gjennomsnittl&oslash;nn,
samlede l&oslash;nnsutgifter og antall ansatte i avdelingen:</p>
<pre class="western">SELECT dept_name AS Avdeling, concat(first_name,' ',last_name) AS Leder,
gender AS Kj&oslash;nn, TIMESTAMPDIFF(year,birth_date,CURDATE()) AS Alder,
round(avg(salary)) AS Snittl&oslash;nn, sum(salary) AS L&oslash;nnskostnad, count(*) AS Ansatte
FROM departments AS d 
INNER JOIN dept_emp AS de ON d.dept_no = de.dept_no
INNER JOIN salaries AS s ON s.emp_no = de.emp_no
INNER JOIN dept_manager AS dm ON dm.dept_no = d.dept_no
INNER JOIN employees AS e ON e.emp_no = dm.emp_no 
WHERE year(s.to_date) = 9999
AND year(de.to_date) = 9999
AND year(dm.to_date) = 9999 
GROUP BY Avdeling ORDER BY Avdeling;

<font size="1" style="font-size: 6pt">+--------------------+-------------------+--------+-------+------------+----------------+---------+ <br/>
| Avdeling &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Leder &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Kj&oslash;nn &nbsp;| Alder | Snittl&oslash;nn &nbsp;| L&oslash;nnskostnad &nbsp;&nbsp;| Ansatte | <br/>
+--------------------+-------------------+--------+-------+------------+----------------+---------+ <br/>
| Customer Service &nbsp;&nbsp;| Yuchang Weedman &nbsp;&nbsp;| M &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;56 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;67285 | &nbsp;98511184.0833 | &nbsp;&nbsp;17569 | <br/>
| Development &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Leon DasSarma &nbsp;&nbsp;&nbsp;&nbsp;| F &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;52 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;67658 | 346104087.5000 | &nbsp;&nbsp;61386 | <br/>
| Finance &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Isamu Legleitner &nbsp;| F &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;59 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;78560 | &nbsp;81420828.0000 | &nbsp;&nbsp;12437 | <br/>
| Human Resources &nbsp;&nbsp;&nbsp;| Karsten Sigstam &nbsp;&nbsp;| F &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;58 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;63922 | &nbsp;68705388.6667 | &nbsp;&nbsp;12898 | <br/>
| Marketing &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Vishwani Minakawa | M &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;53 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;80059 | &nbsp;99019452.8333 | &nbsp;&nbsp;14842 | <br/>
| Production &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Oscar Ghazalie &nbsp;&nbsp;&nbsp;| M &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;53 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;67843 | 301359947.4167 | &nbsp;&nbsp;53304 | <br/>
| Quality Management | Dung Pesch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| M &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;56 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;65442 | &nbsp;79326603.0000 | &nbsp;&nbsp;14546 | <br/>
| Research &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Hilary Kambil &nbsp;&nbsp;&nbsp;&nbsp;| F &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;64 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;67913 | &nbsp;87387535.2500 | &nbsp;&nbsp;15441 | <br/>
| Sales &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Hauke Zhang &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| M &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;61 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;88853 | 279153816.8333 | &nbsp;&nbsp;37701 | <br/>
+--------------------+-------------------+--------+-------+------------+----------------+---------+</font></pre><h3 class="western">
<a name="__RefHeading___Toc4440_762629072"></a>Eksempler p&aring;
OUTER JOINS</h3>
<p class="western">Data i HR-databasen er organisert slik at det
f.eks. ikke ligger inne ansatte uten avdelingstilh&oslash;righet
eller lignende, men vi kan legge til en ny ansatt uten &aring; putte
vedkommende i noen avdeling, og s&aring; illustrere forskjellen p&aring;
inner og outer join ved &aring; s&oslash;ke opp antall ansatte med
avdelingstilh&oslash;righet (inner join), og antall ansatte totalt
(outer join).</p>
<p class="western">F&oslash;rst ser vi hvilket ansattnummer som er
det h&oslash;yeste:</p>
<pre class="western">
<strong><span style="font-weight: normal">SELECT max(emp_no) FROM employees;</span></strong>

+-------------+
| max(emp_no) |
+-------------+
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 499999 |
+-------------+</pre><p class="western">
S&aring; setter vi inn en ny rad i employees-tabellen med det neste
ansattnummeret i rekken, det vil si: 500000:</p>
<pre class="western"><strong><span style="font-weight: normal">I</span></strong><strong><span style="font-weight: normal">NSERT INTO employees (emp_no, first_name, last_name, birth_date, gender, hire_date ) VALUES (500000, '</span></strong><strong><span style="font-weight: normal">Ola</span></strong><strong><span style="font-weight: normal">', '</span></strong><strong><span style="font-weight: normal">Nordmann</span></strong><strong><span style="font-weight: normal">','1986-01-05','M','2016-01-01');</span></strong>

Query OK, 1 row affected (0,01 sec)</pre><p class="western">
S&aring; kan vi bruke en <b>INNER JOIN</b> til &aring; telle opp
antall ansatte som tilh&oslash;rer en avdeling, dvs b&aring;de har en
rad i tabellen employees og i tabellen dept_emp (hvor emp_no er
koblet til dept_no).</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT count(*) FROM employees AS e </span></strong><strong><b>INNER JOIN</b></strong><strong><span style="font-weight: normal"> dept_emp AS de ON e.emp_no = de.emp_no;</span></strong>

+----------+
| count(*) |
+----------+
|&nbsp;&nbsp; 331603 |
+----------+</pre><p class="western">
Kj&oslash;rer vi en <b>OUTER JOIN </b>som peker til
employees-tabellen, dvs. at vi vil ha med alle rader i
employees-tabellen, ogs&aring; de som ikke har noen oppf&oslash;ring
i dept_emp, f&aring;r vi:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT count(*) FROM employees AS e </span></strong><strong><b>LEFT OUTER JOIN</b></strong><strong><span style="font-weight: normal"> dept_emp AS de ON e.emp_no = de.emp_no;</span></strong>

+----------+
| count(*) |
+----------+
|&nbsp;&nbsp; 331604 |
+----------+</pre><p class="western">
Vi ser at vi har en ansatt ekstra med OUTER JOIN enn med INNER JOIN,
siden INNER JOIN bare inkluderer de i employees-tabellen som har
emp_no som ogs&aring; finnes i dept_emp-tabellen &ndash; og vi har
ikke lagt inn Ola Nordmann i dept_emp-tabellen enn&aring;.</p>
<p class="merk"><strong>MERK:</strong> Vi bruker en LEFT outer join
her fordi vi har skrevet employees f&oslash;rst (til venstre) i
SQL-setningen. 
</p>
<p class="western">Vi kan hente ut alle som er registrert i
employees-tabellen, men ikke i dept-emp-tabellen med denne setningen:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT * FROM employees WHERE emp_no NOT IN (SELECT emp_no FROM dept_emp);</span></strong>

+--------+------------+------------+-----------+--------+------------+
| emp_no | birth_date | first_name | last_name | gender | hire_date&nbsp; |
+--------+------------+------------+-----------+--------+------------+
| 500000 | 1986-01-05 | Ola&nbsp;&nbsp;&nbsp;&nbsp;    | Nordmann&nbsp; | M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 2016-01-01 |
+--------+------------+------------+-----------+--------+------------+</pre><p class="western">
Vi deler outer joins i <strong>LEFT OUTER JOIN</strong> og <strong>RIGHT
OUTER JOIN</strong> etter som om det er tabellen til venstre eller
h&oslash;yre i setningen vi vil hente alle rader fra. Vi kan m.a.o.
f&aring; samme resultat hvis vi bytter om rekkef&oslash;lgen p&aring;
tabellene og endrer fra left til right:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT count(*) FROM dept_emp AS de </span></strong><strong><b>RIGHT OUTER JOIN</b></strong><strong><span style="font-weight: normal"> employees AS e ON e.emp_no = de.emp_no;</span></strong>

+----------+
| count(*) |
+----------+
|&nbsp;&nbsp; 331604 |
+----------+</pre><h2 class="western">
<a name="__RefHeading___Toc24604_3325804077"></a><a name="yui_3_17_2_1_1474496389431_73"></a>
<strong><br/>
</strong><strong><font color="#1b75bc"><font face="FontAwesome"><font size="4" style="font-size: 15pt">&#61609;
</font></font></font></strong><strong><span style="font-weight: normal">Sett-operasjoner
med UNION, INTERSECT og EXCEPT </span></strong>
</h2>
<p class="western"><strong><span style="font-weight: normal">Sett-operasjoner
</span></strong><strong><span style="font-weight: normal">er
kombinasjoner av SQL-setninger som </span></strong><strong><span style="font-weight: normal">kopler
resultatet av SQL-setningene sammen til en felles tabell. Mens JOINs
kan &oslash;ke antall kolonner i en resultat-tabell, vil
sett-operasjoner kunne &oslash;ke antall rader, men ikke antall
kolonner i resultat-tabellen. Det er tre mye brukte sett-operasjoner:
UNION, INTERSECT og EXCEPT (som ogs&aring; kalles MINUS i noen
RDBMSer). Vi skal se hvordan de fungerer.</span></strong></p>
<h2 class="western"><a name="__RefHeading___Toc24606_3325804077"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Kombinerte Sp&oslash;rringer med UNION og UNION ALL</h2>
<p class="western"><strong><span style="font-weight: normal">De
fleste SQL-setninger inneholder en enkel SELECT-setning, som
returnerer data fra en eller flere tabeller. Men med SQL kan man ogs&aring;
utf&oslash;re kombinerte sp&oslash;rringer (multiple SELECTs) og
returnere data som et enkelt datasett. Slike kombinerte sp&oslash;rringer
kalles gjerne Unions eller Compound Queries. </span></strong>
</p>
<pre class="western"><strong><span style="font-weight: normal">sp&oslash;rring1 UNION [ALL] sp&oslash;rring2</span></strong></pre><p class="western">
Ofte vil en kombinert sp&oslash;rring gi samme resultat som en enkelt
sp&oslash;rring med flere<strong> WHERE</strong>-betingelser<strong>.
</strong>Eller sagt p&aring; en annen m&aring;te - en sp&oslash;rring
med flere WHERE-betingelser kan ogs&aring; struktureres som en
kombinert sp&oslash;rring.</p>
<h3 class="western"><a name="__RefHeading___Toc4442_762629072"></a>Bruk
av UNION og UNION ALL</h3>
<p class="western">I praksis brukes UNION mest n&aring;r vi skal
hente data fra flere tabeller og kombinere resultatet til ett
datasett:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_norge</span></strong>
<strong>   <b>UNION</b></strong>
<strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_sverige</span></strong>
<strong>   <b>UNION</b></strong>
<strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_danmark;</span></strong></pre><p class="western">
Dersom vi er sikre p&aring; at danske, svenske og norske kunder ikke
overlapper hverandre, vil s&oslash;ket g&aring; raskere hvis vi
bruker UNION ALL, som ikke sjekker for duplikater: 
</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_norge</span></strong>
<strong>  <b>UNION ALL</b></strong>
<strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_sverige</span></strong>
<strong>  </strong><strong><b>UNION ALL</b></strong>
<strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_danmark;</span></strong></pre><p class="western">
Vi kan ogs&aring; bruke<strong> UNION</strong> til &aring; simulere
en <strong>FULL OUTER JOIN, </strong>f.eks i MySQL / MariaDB, slik:</p>
<pre class="western"><strong>  <span style="font-weight: normal">SELECT concat(fornavn,' ',etternavn) as Navn, </span></strong>
<strong>  <span style="font-weight: normal">p.tel as Telefon, firmanavn as Firmanavn,</span></strong>
<strong>  <span style="font-weight: normal">f.tel as Firmatelefon</span></strong>
<strong>  <span style="font-weight: normal">FROM person p LEFT OUTER JOIN firma f</span></strong>
<strong>  <span style="font-weight: normal">ON p.firma_id = f.firma_id </span></strong>
<strong>     UNION  </strong>
<strong>  <span style="font-weight: normal">SELECT concat(fornavn,' ',etternavn) as Navn, </span></strong>
<strong>  <span style="font-weight: normal">p.tel as Telefon, firmanavn as Firmanavn,</span></strong>
<strong>  <span style="font-weight: normal">f.tel as Firmatelefon</span></strong>
<strong>  <span style="font-weight: normal">FROM person p RIGHT OUTER JOIN firma f</span></strong>
<strong>  <span style="font-weight: normal">ON p.firma_id = f.firma_id;<br/>
</span></strong></pre><p class="western">
Setningen over henter f&oslash;rst ut alle personer, ogs&aring; de
som ikke er knyttet til et firma, og s&aring; alle firma, ogs&aring;
de som ikke har noen personer knyttet til seg. Mao blir alle rader i
firmatabellen og alle rader i person-tabellen hentet ut, som er
hensikten med en FULL OUTER JOIN.</p>
<p class="western">En snedig bruk av UNION/UNION ALL er for &aring;
l&oslash;se problemstillingen: Hent de NN beste/siste/nyeste e.l.
radene per gruppe, f.eks. de 5 ansatte med h&oslash;yest l&oslash;nn
per stillingskategori (title) i bedriften. Det er enkelt &aring;
hente 1 fra hver gruppe, f.eks. den ansatte med h&oslash;yest eller
lavest l&oslash;nn innenfor hver stillingskategori. Det kan vi gj&oslash;re
med min() eller max() kombinert med group by. Og det er lett &aring;
finne de 5 eller 10 h&oslash;yest l&oslash;nnede i hele bedriften,
som vi kan gj&oslash;re ved &aring; sortere l&oslash;nnen synkende og
begrense resultatet til 5 eller 10. Men &aring; gj&oslash;re dette
kombinert med group by byr p&aring; problemer. Her kommer UNION til
unnsetning. Slik kan det gj&oslash;res - for &aring; spare plass
henter jeg bare ut de 5 h&oslash;yeste l&oslash;nningene for to
stillinger:</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT * FROM (SELECT </span></strong>
<strong>&nbsp;&nbsp;&nbsp; <span style="font-weight: normal">s.emp_no, t.title, salary</span></strong>
<strong><span style="font-weight: normal">FROM</span></strong>
<strong>&nbsp;&nbsp;&nbsp; <span style="font-weight: normal">salaries AS s,</span></strong>
<strong>&nbsp;&nbsp;&nbsp; <span style="font-weight: normal">titles AS t</span></strong>
<strong><span style="font-weight: normal">WHERE</span></strong>
<strong>&nbsp;&nbsp;&nbsp; <span style="font-weight: normal">s.emp_no = t.emp_no</span></strong>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: normal">AND s.to_date = '9999-01-01'</span></strong>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: normal">AND t.to_date = '9999-01-01'</span></strong>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: normal">AND title = 'Engineer'</span></strong>
<strong><span style="font-weight: normal">ORDER BY salary DESC limit 5) as a</span></strong>
<strong><b>UNION </b></strong>
<strong><span style="font-weight: normal">SELECT * FROM (SELECT </span></strong>
<strong>&nbsp;&nbsp;&nbsp; <span style="font-weight: normal">s.emp_no, t.title, salary</span></strong>
<strong><span style="font-weight: normal">FROM</span></strong>
<strong>&nbsp;&nbsp;&nbsp; <span style="font-weight: normal">salaries AS s,</span></strong>
<strong>&nbsp;&nbsp;&nbsp; <span style="font-weight: normal">titles AS t</span></strong>
<strong><span style="font-weight: normal">WHERE</span></strong>
<strong>&nbsp;&nbsp;&nbsp; <span style="font-weight: normal">s.emp_no = t.emp_no</span></strong>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: normal">AND s.to_date = '9999-01-01'</span></strong>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: normal">AND t.to_date = '9999-01-01'</span></strong>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: normal">AND title = 'Senior Staff'</span></strong>
<strong><span style="font-weight: normal">ORDER BY salary DESC limit 5) as b;</span></strong>

+--------+--------------+--------+
| emp_no | title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | salary |
+--------+--------------+--------+
| 453260 | Engineer&nbsp;&nbsp;&nbsp;&nbsp; | 130939 |
| 419180 | Engineer&nbsp;&nbsp;&nbsp;&nbsp; | 121819 |
| 456344 | Engineer&nbsp;&nbsp;&nbsp;&nbsp; | 120910 |
|&nbsp; 37330 | Engineer&nbsp;&nbsp;&nbsp;&nbsp; | 120417 |
| 464572 | Engineer&nbsp;&nbsp;&nbsp;&nbsp; | 119645 |
|&nbsp; 43624 | Senior Staff | 158220 |
| 254466 | Senior Staff | 156286 |
|&nbsp; 47978 | Senior Staff | 155709 |
| 253939 | Senior Staff | 155513 |
| 109334 | Senior Staff | 155190 |
+--------+--------------+--------+
10 rows in set (0,21 sec)</pre><p class="western">
Vi ser at vi m&aring; sette hvert s&oslash;k inn i en parentes som vi
kj&oslash;rer <em>SELECT *</em> fra. Dette er for &aring; kunne
kombinere ORDER BY og LIMIT med UNION, og dermed m&aring; vi ogs&aring;
lage en alias per stilling (per tabell) - jeg har kalt dem a og b i
setningen ovenfor, men de kan hete hva som helst, s&aring; lenge de
har et navn. 
</p>
<p class="merk"><strong>MERK: UNION</strong> filtrerer ut duplikater.
Vil vi ha med duplikate rader bruker vi uttrykket: <strong>UNION ALL.
</strong>Dersom vi vet at det ikke vil v&aelig;re duplikater i
sluttresultatet, er det mer effektivt &aring; bruke <strong>UNION
ALL,</strong> hvor det ikke sjekkes for duplikater enn <strong>UNION</strong>
(som gj&oslash;r en tidkrevende sjekk for duplikater).</p>
<p class="merk">UNION og UNION ALL fungerer naturlig nok bare hvis
det er identiske felt i de sp&oslash;rringene som kobles sammen.</p>
<p class="western"><br/>
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc23952_604322462"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Kombinerte sp&oslash;rringer med INTERSECT og EXCEPT 
</h2>
<pre class="western"><em><code class="western">query1</code></em> INTERSECT [ALL] <em><code class="western">query2</code></em>
<em><code class="western">query1</code></em> EXCEPT [ALL] <em><code class="western">query2</code></em></pre><p class="western">
Disse sp&oslash;rringene fungerer som UNION / UNION ALL, bortsett fra
at: 
</p>
<p class="western"><code class="western">INTERSECT</code> returnerer
alle rader som finnes <b>b&aring;de</b> i resultatet fra den f&oslash;rste
<b>og</b> den andre sp&oslash;rringen. Duplikater fjernes hvis man
ikke bruker <code class="western">INTERSECT ALL</code>.</p>
<p class="western"><code class="western">EXCEPT</code> returnerer
alle rader som finnes i resultatet fra den f&oslash;rste sp&oslash;rringen,
men <b>ikke</b> i resultatet fra den andre sp&oslash;rringen. (Dette
kalles ogs&aring; for <em>differ</em><em>ansen</em> mellom de to
sp&oslash;rringene). Duplikater fjernes hvis man ikke bruker EXCEPT<code class="western">
ALL</code>.</p>
<h3 class="western"><a name="__RefHeading___Toc23954_604322462"></a>INTERSECT
og EXCEPT med MS SQL server</h3>
<p class="western">Her er et par eksempler p&aring; bruk av INTERSECT
og EXCEPT med Microsoft SQL Server:</p>
<p class="western">Med INTERSECT f&aring;r vi i setningen under
listet ut navn, epost og telefon for alle kunder fra Norge, som <b>ogs&aring;</b>
er kunder i Sverige og Danmark</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_norge</span></strong>
<strong>  </strong><strong><b>INTERSECT</b></strong>
<strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_sverige</span></strong>
<strong>  </strong><strong><b>INTERSECT</b></strong>
<strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_danmark;</span></strong></pre><p class="western">
Med INTERSECT og EXCEPT f&aring;r vi i setningen under listet ut
navn, epost og telefon for alle kunder fra Norge, som <b>ogs&aring;</b>
er kunder i Sverige, men <b>ikke</b> er kunder i Danmark</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_norge</span></strong>
<strong>  </strong><strong><b>INTERSECT</b></strong>
<strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_sverige</span></strong>
<strong>  </strong><strong><b>EXCEPT</b></strong>
<strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_danmark;</span></strong></pre><p class="western">
Med EXCEPT f&aring;r vi i setningen under listet ut navn, epost og
telefon for alle kunder fra Norge, som <b>ikke </b> er kunder i
Sverige eller Danmark</p>
<pre class="western"><strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_norge</span></strong>
<strong>  </strong><strong><b>EXCEPT</b></strong>
<strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_sverige</span></strong>
<strong>  </strong><strong><b>EXCEPT</b></strong>
<strong><span style="font-weight: normal">SELECT navn, epost, telefon</span></strong>
<strong><span style="font-weight: normal">FROM kunder_danmark;</span></strong></pre><p class="western">
<br/>
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc24608_3325804077"></a><strong><font color="#1b75bc">&#61609;
</font></strong>PIVOT-tabeller med SQL</h2>
<p class="western">En <b>pivot-tab</b><b>ell </b><span style="font-weight: normal">er
en tabell som inneholder aggregerte </span><span style="font-weight: normal">tall
fra en mer detaljert tabell.</span> Ved &aring; gruppere <font size="2" style="font-size: 10pt">data
p&aring; ulike meningsfulle m&aring;ter kan man dermed rearrangere
(&laquo;pivotere&raquo;) en tabell slik at man f&aring;r frem ulik
statistisk informasjon. De ulike RDBMSene har forskjellige funksjoner
for &aring; gj&oslash;re dette. Her er noen </font><font size="2" style="font-size: 10pt">eksempler
p&aring; hvordan d</font><font size="2" style="font-size: 10pt">isse
kan brukes:</font><font size="2" style="font-size: 10pt"> </font>
</p>
<h3 class="western"><a name="__RefHeading___Toc24610_3325804077"></a>PostgreSQL:
PIVOT med CROSSTAB()</h3>
<p class="western">Her er et eksempel fra PostgreSQL, som bruker
funksjonen CROSSTAB() til &aring; lage PIVOT-tabeller.</p>
<p class="western">F&oslash;rst m&aring; vi installere
crosstab-funksjonen, som ligger i en &laquo;extension&raquo; ved navn
<b>tablefunc:</b></p>
<pre class="western"><code class="western">CREATE</code> <code class="western">extension tablefunc;</code></pre><p class="western" style="font-weight: normal">
Crosstab-funksjonen tar en SELECT-setning som parameter og denne m&aring;
returnere 3 kolonner:</p>
<ol>
	<li><p class="western" style="font-weight: normal">F&oslash;rste
	kolonne m&aring; v&aelig;re en identifikator, unik for hver rad,
	dvs. i praksis en prim&aelig;rn&oslash;kkel</p>
	<li><p class="western" style="font-weight: normal">Andre kolonne
	representerer kategoriene i pivot-tabellen. Verdiene her blir
	felt-navnene til alt unntatt prim&aelig;rn&oslash;kkelen i den nye
	tabellen.</p>
	<li><p class="western"><span style="font-weight: normal">Tredje
	kolonne inneholder verdiene </span><span style="font-weight: normal">for
	hver </span><font size="2" style="font-size: 10pt"><span style="font-weight: normal">kategori</span></font><span style="font-weight: normal">
	</span><span style="font-weight: normal">(dvs. alle felt unntatt
	prim&aelig;rn&oslash;kkelen) </span><span style="font-weight: normal">i
	den nye, &laquo;</span><span style="font-weight: normal">pivoterte&raquo;</span><span style="font-weight: normal">
	tabellen .</span></p>
</ol>
<p class="western" style="font-weight: normal">Her er en
eksempel-tabell med studenter, deres fag og karakterer:</p>
<pre class="western">&nbsp;&nbsp;&nbsp;student &nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;fag &nbsp;&nbsp;&nbsp;&nbsp;| karakter &nbsp;<br/>
----------------+------------+---------- <br/>
Kari Pettersen | Norsk &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| B <br/>
Kari Pettersen | Engelsk &nbsp;&nbsp;&nbsp;| A <br/>
Kari Pettersen | Matematikk | A <br/>
Ola Nilsen &nbsp;&nbsp;&nbsp;&nbsp;| Norsk &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| A <br/>
Ola Nilsen &nbsp;&nbsp;&nbsp;&nbsp;| Matematikk | B <br/>
Ola Nilsen &nbsp;&nbsp;&nbsp;&nbsp;| Engelsk &nbsp;&nbsp;&nbsp;| C</pre><p class="western">
Vi kan gj&oslash;re om denne tabellen med PIVOT-funksjonen CROSSTAB()
slik:</p>
<pre class="western">SELECT * FROM <b>crosstab('SELECT student, fag, karakter </b><b>FROM</b><b> studenter </b><b>ORDER BY</b><b> </b><b>student</b><b>,</b><b>fag</b><b>') </b><b>AS</b><b> </b><b>tabell</b><b> (</b><b>s</b><b>tudent text, </b><font face="Liberation Mono, monospace"><font size="2" style="font-size: 9pt"><b>engelsk</b></font></font><b> text, </b><b>matematikk</b><b> text, </b><b>norsk</b><b> text)</b>; <br/>

&nbsp;&nbsp;&nbsp;student &nbsp;&nbsp;&nbsp;&nbsp;| engelsk | matematikk | norsk &nbsp;<br/>
---------------+---------+------------+---------<br/>
Kari Pettersen | A &nbsp;&nbsp;&nbsp;&nbsp;  | A &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   | B <br/>
Ola Nilsen &nbsp;&nbsp;&nbsp;&nbsp;| C &nbsp;&nbsp;&nbsp;&nbsp;  | B &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;| A</pre><p class="merk">
<b>MERK:</b> Siden vi har undersortert select-seningen inne i
crosstab-funksjonen etter fag, m&aring; vi liste opp de ulike fagene
i alfabetisk rekkef&oslash;lge i neste parentes for at riktig
karakter skal bli satt til riktig kolonneoverskrift.  
</p>
<h3 class="western"><a name="__RefHeading___Toc26599_1493065540"></a>PIVOT
og UNPIVOT med MS SQL Server</h3>
<p class="western" style="font-weight: normal">F&oslash;rst lager vi
en eksempel-tabell <i><b>studenter</b></i>, med tre kolonner:
student, fag og karakter:</p>
<pre class="western">create table studenter (
student NVARCHAR(25),
fag NVARCHAR(20),
karakter float(2)
);

insert into studenter VALUES
('Kari Pettersen','Norsk',2.1),
('Kari Pettersen','Engelsk',1.8),
('Kari Pettersen','Matematikk',2.3),
('Ola Nilsen','Norsk',2.0),
('Ola Nilsen','Matematikk',2.6),
('Ola Nilsen','Engelsk',2.8);

<b>select * from studenter;</b>

student		fag		karakter<br/>
---------------	-----------	---------
Kari Pettersen	Norsk		2,1
Kari Pettersen	Engelsk	1,8
Kari Pettersen	Matematikk	2,3
Ola Nilsen		Norsk		2
Ola Nilsen		Matematikk	2,6
Ola Nilsen		Engelsk	2,8
</pre><p class="western">
<br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western">Vi kan bruke SQL Servers PIVOT-funksjon til &aring;
regne ut snittkarakterene for hvert fag og presentere dem i en ny
tabell, slik:</p>
<pre class="western">SELECT 'Snittkarakter' as [Alle Studenter], norsk, engelsk, matematikk 
FROM (SELECT fag, karakter FROM studenter) AS SourceTable
<b>PIVOT</b>
(avg(karakter) FOR fag IN (norsk,engelsk,matematikk)) AS PivotTable;


Alle Studenter	norsk			engelsk		matematikk
---------------	------------------	----------------	-------------
Snittkarakter	2,04999995231628	2,29999995231628	2,44999992847443
</pre><p class="western">
<br/>
<br/>

</p>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc23693_3962996256"></a>
<font size="6" style="font-size: 24pt">Kapittel </font><font size="6" style="font-size: 24pt">9</font><br/>
Vindusfunksjoner</h1>
<h2 class="western"><a name="__RefHeading___Toc23695_3962996256"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Vindusfunksjoner</h2>
<p class="western">Vindusfunksjoner er funksjoner som forholder seg
til en rad og dens foreg&aring;ende og etterf&oslash;lgende rader p&aring;
en slik m&aring;te at vi kan lage beregninger som ellers er
vanskelige &aring; f&aring; til med SQL. To av de mest brukte er
<b>row_number()</b> for &aring; lage et l&oslash;penummer og <b>rank()</b>
for &aring; lage en rangering, men vi kan ogs&aring; bruke vanlige
aggregeringsfunksjoner som <b>sum()</b>, <b>avg() </b>og <b>count()</b>
for f.eks &aring; beregne et l&oslash;pende gjennomsnitt,   en
kumulativ sum osv. Med vindusfunksjoner kan vi aggregere uten &aring;
bruke GROUP BY og likevel ikke f&aring; redusert resultatet til kun 1
rad. 
</p>
<p class="western">Vindusfunksjonene har en felles syntaks som har
denne strukturen:</p>
<pre class="western">&lt;funksjon&gt;() <b>OVER</b> ([PARTITION BY &lt;felt&gt;, ORDER BY &lt;felt&gt;])</pre><p class="western">
N&oslash;kkelordene <b>PARTITION BY </b><span style="font-weight: normal">brukes
for &aring; angi at vi vil bruke funkjonen p&aring; grupperte data,
slik at  f.eks. et l&oslash;penummer eller rangering starter p&aring;
nytt for hver gruppe.</span></p>
<p class="western">Noen eksempler vil antagelig klargj&oslash;re
bruken av vindusfunksjoner bedre enn teoretiske definisjoner:</p>
<h2 class="western"><a name="__RefHeading___Toc14634_541183064"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Eksempel 1: Bruke en vindusfunksjon til &aring; lage et l&oslash;penummer</h2>
<h3 class="western"><a name="__RefHeading___Toc19093_2730267216"></a>Med
MariaDB / MySQL</h3>
<p class="western">MariaDB har st&oslash;tte for vindusfunksjoner fra
og med versjon 10.2, og MySQL fra versjon 8. Slik bruker vi
vindusfnksjonen row_number() til &aring; lage et l&oslash;penummer
som begynner p&aring; 1 og &oslash;ker med 1 for hver rad. Legg merke
til at vi m&aring; sortere to ganger, b&aring;de inne i parentesen og
til slutt i setningen:</p>
<pre class="western">SELECT first_name, last_name, row_number() OVER (ORDER BY last_name, first_name) as l&oslash;penummer FROM employees ORDER BY last_name, first_name limit 10;<br/>

+------------+-----------+------------+
| first_name | last_name | l&oslash;penummer |
+------------+-----------+------------+
| Abdelkader | Aamodt    |          1 |
| Adhemar    | Aamodt    |          2 |
| Aemilian   | Aamodt    |          3 |
| Alagu      | Aamodt    |          4 |
| Aleksander | Aamodt    |          5 |
| Alexius    | Aamodt    |          6 |
| Alois      | Aamodt    |          7 |
| Aluzio     | Aamodt    |          8 |
| Amabile    | Aamodt    |          9 |
| Anestis    | Aamodt    |         10 |
+------------+-----------+------------+
10 rows in set (0.386 sec)</pre><h3 class="western">
<a name="__RefHeading___Toc19095_2730267216"></a>Med PostgreSQL</h3>
<p class="western">Slik bruker vi  vindusfunksjonen <b>row_number()</b>
til &aring; lage et l&oslash;penummer som begynner p&aring; 1 og &oslash;ker
med 1 for hver rad i PostgreSQL:</p>
<pre class="western">select first_name, last_name, <b>row_number() OVER (ORDER BY last_name, first_name) as l&oslash;pe</b><b>n</b><b>ummer</b> from employees limit 10;

 first_name | last_name | l&oslash;penummer 
------------+-----------+-----------
 Abdelkader | Aamodt    |         1
 Adhemar    | Aamodt    |         2
 Aemilian   | Aamodt    |         3
 Alagu      | Aamodt    |         4
 Aleksander | Aamodt    |         5
 Alexius    | Aamodt    |         6
 Alois      | Aamodt    |         7
 Aluzio     | Aamodt    |         8
 Amabile    | Aamodt    |         9
 Anestis    | Aamodt    |        10
(10 rows)
</pre><p class="western">
Eller hvis vi vil ha etternavn sortert p&aring; norsk m&aring;te,
hvor Aa blir behandlet sammen med &Aring;, kan vi legge til <b>collate
&quot;nb_NO&quot; </b><span style="font-weight: normal">etter
last_name inne i parentesen slik:</span></p>
<pre class="western">select first_name, last_name, row_number() OVER (ORDER BY last_name collate &quot;nb_NO&quot;, first_name) as l&oslash;penummer from employees limit 10;

 first_name | last_name | l&oslash;penummer 
------------+-----------+-----------
 Abdulla    | Acton     |         1
 Adit       | Acton     |         2
 Aimee      | Acton     |         3
 Aimee      | Acton     |         4
 Alassane   | Acton     |         5
 Almudena   | Acton     |         6
 Aluzio     | Acton     |         7
 Amstein    | Acton     |         8
 Aral       | Acton     |         9
 Basim      | Acton     |        10
(10 rows)</pre><h3 class="western">
<a name="__RefHeading___Toc14636_541183064"></a>Med Oracle</h3>
<p class="western">Slik bruker vi <b>row_number()</b> for &aring;
lage et l&oslash;penummer med Oracle:</p>
<pre class="western">select first_name, last_name, <b>row_number()</b> <b>OVER (ORDER BY last_name, first_name)</b> l&oslash;penummer from employees where rownum&lt;11;

FIRST_NAME	LAST_NAME 	  L&Oslash;PENUMMER
----------	-------------- -----------
Rafail 	Beutelspacher	  1
Vishwani 	Linares 	  2
Aamod 	Michaels	  3
Charlene 	Miculan 	  4
Salvador 	Montresor 	  5
Siddarth 	Ratnakar 	  6
Ronghao 	Remmele 	  7
Bouchung 	Remmers	  8
Taegyun 	Seghrouchni 	  9
Shmuel 	Simmel		  10</pre><h3 class="western">
<a name="__RefHeading___Toc19097_2730267216"></a>Med Microsoft SQL
Server</h3>
<p class="western">Og slik bruker vi <b>row_number()</b> for &aring;
lage et l&oslash;penummer med MS SQL Server:</p>
<pre class="western">SELECT TOP 10 first_name, last_name, row_number() OVER (ORDER BY last_name, first_name) as l&oslash;penummer from employees;

first_name     last_name        l&oslash;penummer
-------------- ---------------- --------------------
Abdelkader     Aamodt           1
Adhemar        Aamodt           2
Aemilian       Aamodt           3
Alagu          Aamodt           4
Aleksander     Aamodt           5
Alexius        Aamodt           6
Alois          Aamodt           7
Aluzio         Aamodt           8
Amabile        Aamodt           9
Anestis        Aamodt           10

(10 rows affected)</pre><p class="western" style="margin-bottom: 0cm; line-height: 100%; page-break-before: auto">
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc14638_541183064"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Eksempel 2: Bruke en vindusfunksjon til &aring; lage en rangering 
</h2>
<p class="western">I eksemplet nedenfor bruker vi vindusfunksjonen
<b>rank()</b>  til &aring; lage en rangering basert p&aring; dagens
l&oslash;nn innenfor hver avdeling. For &aring; gj&oslash;re listen
kortere har vi bare tatt med de med l&oslash;nn h&oslash;yere en 140
000. Vi grupperer p&aring; avdelingsnavn ved &aring; rangere over
<span style="font-style: normal"><b>PARTITION BY dept_name</b></span><span style="font-style: normal"><span style="font-weight: normal">,</span></span><span style="font-style: normal"><b>
</b></span><span style="font-style: normal"><span style="font-weight: normal">og
lager rangeringen basert p&aring; l&oslash;nn sortert i synkende
rekkef&oslash;lge ved &aring; </span></span><span style="font-style: normal"><span style="font-weight: normal">sortere
med</span></span><span style="font-style: normal"><span style="font-weight: normal">
</span></span><span style="font-style: normal"><b>ORDER BY salary
desc. </b></span>
</p>
<h3 class="western" style="font-weight: normal"><a name="__RefHeading___Toc16230_413252541"></a>
<span style="font-style: normal">M</span><span style="font-style: normal">ed
</span><span style="font-style: normal">MySQL/</span><span style="font-style: normal">MariaDB,
</span><span style="font-style: normal">Oracle </span><span style="font-style: normal">og
PostgreSQL</span></h3>
<p class="western">Setningen i eksemplet nedenfor fungerer med
MariaDB 10.2, Oracle Express 11g og PostgreSQL 9.6. Siden Microsoft
SQL Server ikke st&oslash;tter funksjonen extract(), bytter vi denne
ut med year() for SQL Server (se neste eksempel)</p>
<p class="merk"><b>MERK:</b> Vindusfunksjoner ble f&oslash;rst
introdusert i MariaDB versjon 10.2.0, og i MySQL versjon 8.0, s&aring;
bruker du en eldre versjon enn disse vil ikke eksemplene nedenfor
fungere for MySQL/MariaDB</p>
<pre class="western">SELECT first_name, last_name, dept_name, salary, <b>rank() OVER (PARTITION BY dept_name ORDER BY salary desc) </b><b>AS</b><b> rank</b> FROM employees e  
INNER JOIN dept_emp de ON e.emp_no = de.emp_no  
INNER JOIN departments d ON d.dept_no = de.dept_no  
INNER JOIN salaries s ON s.emp_no = de.emp_no  
WHERE extract(year from s.to_date) = 9999  AND extract(year from de.to_date) = 9999 AND salary &gt; 140000 ORDER BY<span style="font-weight: normal"> dept_name, rank</span>;

+---------------+----------------+------------------+--------+------+
| first_name    | last_name      | dept_name        | salary | rank |
+---------------+----------------+------------------+--------+------+
| Vidya         | Hanabata       | Customer Service | 144866 |    1 |
| Odoardo       | Lindenbaum     | Customer Service | 143950 |    2 |
| Seongbin      | Mitsuhashi     | Customer Service | 143937 |    3 |
| Bedrich       | Luft           | Customer Service | 143832 |    4 |
| Yefim         | Taneja         | Customer Service | 141555 |    5 |

| Khosrow       | Sgarro         | Development      | 144434 |    1 |
| Jixiang       | Rindone        | Development      | 140784 |    2 |

| Lunjin        | Swick          | Finance          | 142395 |    1 |
| Uta           | Lowrie         | Finance          | 140742 |    2 |

| Yinlin        | Flowers        | Human Resources  | 141953 |    1 |

| Akemi         | Warwick        | Marketing        | 145128 |    1 |
| Ingmar        | Isard          | Marketing        | 143644 |    2 |
| Ortrud        | Diderrich      | Marketing        | 142506 |    3 |
| Chikako       | Jiang          | Marketing        | 142485 |    4 |
| Clyde         | Georgakopoulos | Marketing        | 141842 |    5 |
| Sungwon       | Vural          | Marketing        | 140974 |    6 |
| Minghong      | Siegrist       | Marketing        | 140077 |    7 |

| Tokuyasu      | Pesch          | Sales            | 158220 |    1 |
| Honesty       | Mukaidono      | Sales            | 156286 |    2 |
| Xiahua        | Whitcomb       | Sales            | 155709 |    3 |
| Sanjai        | Luders         | Sales            | 155513 |    4 |
| Tsutomu       | Alameldin      | Sales            | 155190 |    5 |
<span style="font-style: normal"><b>..... </b></span><span style="font-style: normal"><span style="font-weight: normal">osv ...</span></span></pre><p class="western">
Vi kan ogs&aring; bruke denne vindusfunksjonen til &aring; lage
&laquo;n-p&aring;-topp&raquo; lister, som f.eks liste over de 3
ansatte med lavest eller h&oslash;yest l&oslash;nn innenfor hver
avdeling, de 5 sist ansatte innen hver stillingskategori e.l. Dette
er vanskelig &aring; f&aring; til uten vindusfunksjoner, siden GROUP
BY fungerer d&aring;rlig sammen med LIMIT, som begrenser antall rader
i hele resultattabellen, og ikke innenfor hver gruppe.</p>
<p class="western">For &aring; f&aring; dette til legger vi en
SELECT-setning rundt setningen over (og fjerner betingelsen om at
l&oslash;nnen m&aring; v&aelig;re mer enn 140 000), og legger til en
begrensning om at feltet <b>rank</b><span style="font-weight: normal">
ikke m&aring; v&aelig;re st&oslash;rre enn s&aring; mange vi &oslash;nsker
fra hver gruppe. Setningen under henter f.eks. ut de 3 ansatte i hver
avdeling som har h&oslash;yest l&oslash;nn:</span></p>
<pre class="western"><font size="1" style="font-size: 8pt"><b>SELECT * from</b> (SELECT first_name, last_name, dept_name, salary, <b>rank() OVER (PARTITION BY dept_name ORDER BY salary desc) </b><b>AS</b><b> rank</b> FROM employees e  </font>
<font size="1" style="font-size: 8pt">INNER JOIN dept_emp de ON e.emp_no = de.emp_no  </font>
<font size="1" style="font-size: 8pt">INNER JOIN departments d ON d.dept_no = de.dept_no  </font>
<font size="1" style="font-size: 8pt">INNER JOIN salaries s ON s.emp_no = de.emp_no  </font>
<font size="1" style="font-size: 8pt">WHERE extract(year from s.to_date) = 9999  AND extract(year from de.to_date) = 9999 ORDER BY dept_name, rank</font>
<font size="1" style="font-size: 8pt">) <b>AS salary_rank where rank &lt; 4;</b></font>


first_name | last_name &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;dept_name &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| salary | rank &nbsp;<br/>
------------+------------+--------------------+--------+------ <br/>
Vidya &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Hanabata &nbsp;&nbsp;| Customer Service &nbsp;&nbsp;| 144866 | &nbsp;&nbsp;&nbsp;1 <br/>
Odoardo &nbsp;&nbsp;&nbsp;| Lindenbaum | Customer Service &nbsp;&nbsp;| 143950 | &nbsp;&nbsp;&nbsp;2 <br/>
Seongbin &nbsp;&nbsp;| Mitsuhashi | Customer Service &nbsp;&nbsp;| 143937 | &nbsp;&nbsp;&nbsp;3 <br/>
Khosrow &nbsp;&nbsp;&nbsp;| Sgarro &nbsp;&nbsp;&nbsp;&nbsp;| Development &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 144434 | &nbsp;&nbsp;&nbsp;1 <br/>
Jixiang &nbsp;&nbsp;&nbsp;| Rindone &nbsp;&nbsp;&nbsp;| Development &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 140784 | &nbsp;&nbsp;&nbsp;2 <br/>
Dayanand &nbsp;&nbsp;| Morrey &nbsp;&nbsp;&nbsp;&nbsp;| Development &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 136130 | &nbsp;&nbsp;&nbsp;3 <br/>
Lunjin &nbsp;&nbsp;&nbsp;&nbsp;| Swick &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Finance &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 142395 | &nbsp;&nbsp;&nbsp;1 <br/>
Uta &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Lowrie &nbsp;&nbsp;&nbsp;&nbsp;| Finance &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 140742 | &nbsp;&nbsp;&nbsp;2 <br/>
Genki &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Delaune &nbsp;&nbsp;&nbsp;| Finance &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 138775 | &nbsp;&nbsp;&nbsp;3 <br/>
Yinlin &nbsp;&nbsp;&nbsp;&nbsp;| Flowers &nbsp;&nbsp;&nbsp;| Human Resources &nbsp;&nbsp;&nbsp;| 141953 | &nbsp;&nbsp;&nbsp;1 <br/>
Kannan &nbsp;&nbsp;&nbsp;&nbsp;| Emiris &nbsp;&nbsp;&nbsp;&nbsp;| Human Resources &nbsp;&nbsp;&nbsp;| 128308 | &nbsp;&nbsp;&nbsp;2 <br/>
Yifei &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Gien &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Human Resources &nbsp;&nbsp;&nbsp;| 125263 | &nbsp;&nbsp;&nbsp;3 <br/>
Akemi &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Warwick &nbsp;&nbsp;&nbsp;| Marketing &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 145128 | &nbsp;&nbsp;&nbsp;1 <br/>
Ingmar &nbsp;&nbsp;&nbsp;&nbsp;| Isard &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Marketing &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 143644 | &nbsp;&nbsp;&nbsp;2 <br/>
Ortrud &nbsp;&nbsp;&nbsp;&nbsp;| Diderrich &nbsp;| Marketing &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 142506 | &nbsp;&nbsp;&nbsp;3 <br/>
Youjian &nbsp;&nbsp;&nbsp;| Cronau &nbsp;&nbsp;&nbsp;&nbsp;| Production &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 138273 | &nbsp;&nbsp;&nbsp;1 <br/>
Shimshon &nbsp;&nbsp;| Azuma &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Production &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 137563 | &nbsp;&nbsp;&nbsp;2 <br/>
Fumino &nbsp;&nbsp;&nbsp;&nbsp;| Schahn &nbsp;&nbsp;&nbsp;&nbsp;| Production &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 132552 | &nbsp;&nbsp;&nbsp;3 <br/>
Shin &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Luck &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Quality Management | 132103 | &nbsp;&nbsp;&nbsp;1 <br/>
Mandell &nbsp;&nbsp;&nbsp;| Alencar &nbsp;&nbsp;&nbsp;| Quality Management | 123225 | &nbsp;&nbsp;&nbsp;2 <br/>
Honglan &nbsp;&nbsp;&nbsp;| Petereit &nbsp;&nbsp;| Quality Management | 122965 | &nbsp;&nbsp;&nbsp;3 <br/>
Ramachenga | Soicher &nbsp;&nbsp;&nbsp;| Research &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 130211 | &nbsp;&nbsp;&nbsp;1 <br/>
Giap &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Pashtan &nbsp;&nbsp;&nbsp;| Research &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 127240 | &nbsp;&nbsp;&nbsp;2 <br/>
Shuji &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Felder &nbsp;&nbsp;&nbsp;&nbsp;| Research &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 124356 | &nbsp;&nbsp;&nbsp;3 <br/>
Tokuyasu &nbsp;&nbsp;| Pesch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Sales &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 158220 | &nbsp;&nbsp;&nbsp;1 <br/>
Honesty &nbsp;&nbsp;&nbsp;| Mukaidono &nbsp;| Sales &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 156286 | &nbsp;&nbsp;&nbsp;2 <br/>
Xiahua &nbsp;&nbsp;&nbsp;&nbsp;| Whitcomb &nbsp;&nbsp;| Sales &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 155709 | &nbsp;&nbsp;&nbsp;3 <br/>
(27 rows)</pre><p class="western">
Som vi ser f&aring;r vi kun ut 3 ansatte fra hver avdeling: De som er
rangert som 1, 2 eller 3 n&aring;r det gjelder st&oslash;rrelsen p&aring;
l&oslash;nnen.</p>
<p class="merk"><b>MERK: </b><span style="font-weight: normal">For at
setningen over skal fungere med Oracle, m&aring; du fjerne AS mellom
SQL-setningen i parentesen og aliaset salary_rank, slik: </span><span style="font-style: normal">....
 ) salary_rank where rank &lt; 4;  </span><span style="font-style: normal">Oracle
liker generelt ikke at vi bruker AS mellom en tabell og dens alias &ndash;
og SELECT-setningen inne i parentesen blir her behandlet som en
tabell som vi henter alle feltene fra.  </span>
</p>
<h3 class="western" style="font-weight: normal"><a name="__RefHeading___Toc16232_413252541"></a>
<span style="font-style: normal">M</span><span style="font-style: normal">ed
</span><span style="font-style: normal">Microsoft SQL-server</span></h3>
<p class="western" style="font-weight: normal"><span style="font-style: normal">M</span><span style="font-style: normal">ed
SQL-server m&aring; i bare bytte ut extract() med year() , s&aring;
fungerer den ellers samme SQL-setningen som for de andre RDBMSene,
mao slik: </span>
</p>
<pre class="western">SELECT first_name, last_name, dept_name, salary, <b>rank() OVER (PARTITION BY dept_name ORDER BY salary desc) </b><b>AS</b><b> rank</b> FROM employees e  
INNER JOIN dept_emp de ON e.emp_no = de.emp_no  
INNER JOIN departments d ON d.dept_no = de.dept_no  
INNER JOIN salaries s ON s.emp_no = de.emp_no  
WHERE year (s.to_date) = 9999  AND year(de.to_date) = 9999 AND salary &gt; 140000 ORDER BY dept_name, rank;

  first_name   |   last_name    |    dept_name     | salary | rank 
---------------+----------------+------------------+--------+------
 Vidya         | Hanabata       | Customer Service | 144866 |    1
 Odoardo       | Lindenbaum     | Customer Service | 143950 |    2
 Seongbin      | Mitsuhashi     | Customer Service | 143937 |    3
 Bedrich       | Luft           | Customer Service | 143832 |    4
 Yefim         | Taneja         | Customer Service | 141555 |    5
 
 Khosrow       | Sgarro         | Development      | 144434 |    1
 Jixiang       | Rindone        | Development      | 140784 |    2
 
 Lunjin        | Swick          | Finance          | 142395 |    1
 Uta           | Lowrie         | Finance          | 140742 |    2
 
 Yinlin        | Flowers        | Human Resources  | 141953 |    1
 
 Akemi         | Warwick        | Marketing        | 145128 |    1
 Ingmar        | Isard          | Marketing        | 143644 |    2
 Ortrud        | Diderrich      | Marketing        | 142506 |    3
 Chikako       | Jiang          | Marketing        | 142485 |    4
 Clyde         | Georgakopoulos | Marketing        | 141842 |    5
 Sungwon       | Vural          | Marketing        | 140974 |    6
 Minghong      | Siegrist       | Marketing        | 140077 |    7
 
 Tokuyasu      | Pesch          | Sales            | 158220 |    1
 Honesty       | Mukaidono      | Sales            | 156286 |    2
 Xiahua        | Whitcomb       | Sales            | 155709 |    3
 Sanjai        | Luders         | Sales            | 155513 |    4
 Tsutomu       | Alameldin      | Sales            | 155190 |    5

.... osv ...</pre><p class="western">
<br/>
<br/>

</p>
<p class="merk"><b>MERK:</b> <span style="font-weight: normal">Den
eneste forskjellen mellom </span><span style="font-weight: normal">MS
</span><span style="font-weight: normal">SQL Server og de andre
RDBMSene er at vi bruker funksjonen </span><b>year()</b><span style="font-weight: normal">
istedenfor funksjonen </span><b>extract()</b><span style="font-weight: normal">
til &aring; hente &aring;rstallet for de dataene vi vil ha rangert.
Selve rangeringsfunksjonen er lik for alle fire.</span></p>
<p class="western"><span style="font-weight: normal">For &aring;</span><span style="font-weight: normal">
hente ut de 3 ansatte i hver avdeling som har h&oslash;yest l&oslash;nn
</span><span style="font-weight: normal">kan vi ogs&aring; bruke den
samme setningen som for de andre RDBMSene (se over), men SQL-server
aksepterer ikke at  vi bruker ORDER BY inne i parentesen, s&aring; vi
m&aring; flytte sorteringen til slutt i hele setningen. I tillegg m&aring;
vi ogs&aring; her bruke year() istedenfor extract() til &aring; finne
&aring;rstallet for dagens l&oslash;nn og dagens
avdelingstilh&oslash;righet:</span></p>
<pre class="western">SELECT * FROM <br/>
(SELECT first_name, last_name, dept_name, salary, rank() OVER (PARTITION BY dept_name ORDER BY salary desc) as rank FROM employees e
INNER JOIN dept_emp de ON e.emp_no = de.emp_no INNER JOIN departments d ON d.dept_no = de.dept_no INNER JOIN salaries s ON s.emp_no = de.emp_no
WHERE year(s.to_date) = 9999 AND year(de.to_date) = 9999 ) AS salary_rank
where rank &lt; 4 ORDER BY dept_name, rank;

Vidya	Hanabata	Customer Service	144866	1
Odoardo	Lindenbaum	Customer Service	143950	2
Seongbin	Mitsuhashi	Customer Service	143937	3
Khosrow	Sgarro		Development		144434	1
Jixiang	Rindone	Development		140784	2
Dayanand	Morrey		Development		136130	3
Lunjin	Swick		Finance		142395	1
Uta		Lowrie		Finance		140742	2
Genki	Delaune	Finance		138775	3
Yinlin	Flowers	Human Resources	141953	1
Kannan	Emiris		Human Resources	128308	2
Yifei	Gien		Human Resources	125263	3
Akemi	Warwick	Marketing		145128	1
Ingmar	Isard		Marketing		143644	2
Ortrud	Diderrich	Marketing		142506	3
Youjian	Cronau		Production		138273	1
Shimshon	Azuma		Production		137563	2
Fumino	Schahn		Production		132552	3
Shin	Luck		Quality Management	132103	1
Mandell	Alencar	Quality Management	123225	2
Honglan	Petereit	Quality Management	122965	3
Ramachenga	Soicher	Research		130211	1
Giap	Pashtan	Research		127240	2
Shuji	Felder		Research		124356	3
Tokuyasu	Pesch		Sales			158220	1
Honesty	Mukaidono	Sales			156286	2
Xiahua	Whitcomb	Sales			155709	3</pre><p class="merk">
<b>MERK: </b><span style="font-weight: normal">Vi kunne ogs&aring; ha
flyttet ORDER BY til slutten av setningen for Oracle, PostgreSQL og
MySQL/MariaDB, s&aring; hadde vi f&aring;tt en mer portabel kode. </span>
</p>
<h2 class="western"><a name="__RefHeading___Toc16899_3466130985"></a><strong><font color="#1b75bc">&#61609;
</font></strong>Eksempel 3: Bruke vindusfunksjon til &aring; liste ut
forskjellen mellom de ansattes l&oslash;nn og snittl&oslash;nnen for
avdelingen de jobber i</h2>
<p class="western">I eksemplet nedenfor brukes vindusfunksjoner for &aring;
liste ut en tabell med alle ansatte med deres n&aring;v&aelig;rende
l&oslash;nn, gjennomsnittl&oslash;nnen for avdelingen de jobber i og
forskjellen mellom l&oslash;nn og snittl&oslash;nn.</p>
<h3 class="western"><a name="__RefHeading___Toc19099_2730267216"></a>Med
Oracle, MySQL/MariaDB og PostgreSQL</h3>
<pre class="western">SELECT dept_emp.emp_no, dept_no, salary, round(AVG(salary) OVER (PARTITION BY dept_no)) AS snitt, round((salary - AVG(salary) <b>OVER (PARTITION BY dept_no)</b>)) AS diff 
FROM dept_emp, salaries 
WHERE salaries.emp_no = dept_emp.emp_no 
AND extract(year from salaries.to_date) = 9999 AND extract(year from dept_emp.to_date) = 9999 ORDER BY dept_no, salary DESC; 

emp_no | dept_no | salary | snitt | &nbsp;diff &nbsp;&nbsp;<br/>
-------+---------+--------+-------+-------- <br/>
466852 | d001 &nbsp;&nbsp;&nbsp;| 145128 | 80059 | &nbsp;65069 <br/>
&nbsp;89825 | d001 &nbsp;&nbsp;&nbsp;| 143644 | 80059 | &nbsp;63585 <br/>
107140 | d001 &nbsp;&nbsp;&nbsp;| 142506 | 80059 | &nbsp;62447 <br/>
&nbsp;80937 | d001 &nbsp;&nbsp;&nbsp;| 142485 | 80059 | &nbsp;62426 <br/>
&nbsp;51531 | d001 &nbsp;&nbsp;&nbsp;| 141842 | 80059 | &nbsp;61783 <br/>
102078 | d001 &nbsp;&nbsp;&nbsp;| 140974 | 80059 | &nbsp;60915 <br/>
477358 | d001 &nbsp;&nbsp;&nbsp;| 140077 | 80059 | &nbsp;60018<br/>
.....
290305 | d001 &nbsp;&nbsp;&nbsp;| &nbsp;39926 | 80059 | -40133 <br/>
107931 | d001 &nbsp;&nbsp;&nbsp;| &nbsp;39871 | 80059 | -40188 <br/>
&nbsp;65337 | d001 &nbsp;&nbsp;&nbsp;| &nbsp;39821 | 80059 | -40238 <br/>

413137 | d002 &nbsp;&nbsp;&nbsp;| 142395 | 78560 | &nbsp;63835 <br/>
237069 | d002 &nbsp;&nbsp;&nbsp;| 140742 | 78560 | &nbsp;62182 <br/>
274371 | d002 &nbsp;&nbsp;&nbsp;| 138775 | 78560 | &nbsp;60215<br/>
.... osv<font face="monospace"><br/>
</font></pre><h3 class="western">
<a name="__RefHeading___Toc19101_2730267216"></a>Med Microsoft SQL
Server</h3>
<p class="western">Med SQL-server blir syntaksen litt annerledes,
selv om vindusfunksjonene er helt like, siden vi m&aring; konvertere
l&oslash;nnen til desimaltall med <span style="font-style: normal"><b>convert()
</b></span><span style="font-style: normal"><span style="font-weight: normal">f&oslash;r
vi kan regne ut gjennomsnittet, og siden vi m&aring; bruke funksjonen
</span></span><span style="font-style: normal"><b>year() </b></span><span style="font-style: normal"><span style="font-weight: normal">istedenfor</span></span><span style="font-style: normal"><b>
extract().</b></span></p>
<pre class="western">SELECT dept_emp.emp_no, dept_no, salary, round(AVG(convert(float,salary)) OVER (PARTITION BY dept_no),0) AS snitt, 
round((salary - AVG(convert(float,salary)) OVER (PARTITION BY dept_no)),0) AS diff 
FROM dept_emp, salaries 
WHERE salaries.emp_no = dept_emp.emp_no 
AND year(salaries.to_date) = 9999 AND year(dept_emp.to_date) = 9999 
ORDER BY dept_no asc, salary DESC; 

emp_no      dept_no salary      snitt                  diff
----------- ------- ----------- --------------------- -----------------
466852      d001    145128      80059                  65069
89825       d001    143644      80059                  63585
107140      d001    142506      80059                  62447
80937       d001    142485      80059                  62426
51531       d001    141842      80059                  61783
102078      d001    140974      80059                  60915
477358      d001    140077      80059                  60018
278498      d001    138755      80059                  58696
475041      d001    137413      80059                  57354
403062      d001    136327      80059                  56268
457372      d001    136105      80059                  56046
...<br/>
</pre><p class="western">
<br/>
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc20653_3962996256"></a><strong><font color="#1b75bc">&#61609;
</font></strong><strong><span style="font-weight: normal">Eksempel 4:
Beregne l&oslash;nns&oslash;kning for en ansatt i forhold til l&oslash;nnen
&aring;ret f&oslash;r med vindusfunksjonen </span></strong><strong><b>lag()</b></strong></h2>
<p class="western"><strong><span style="font-weight: normal">Vi kan
bruke vindusfunksjonen lag() til &aring; sammenligne en rad med den
foreg&aring;ende raden i resultatet fra en SQL-setning, og dermed
f.eks. beregne hvor mye en l&oslash;nn har g&aring;tt opp eller ned i
forhold til foreg&aring;ende &aring;r. </span></strong><strong><span style="font-weight: normal">Setningen
</span></strong><strong><span style="font-weight: normal">nedenfor</span></strong><strong><span style="font-weight: normal">
beregner l&oslash;nns&oslash;kningen </span></strong><strong><span style="font-weight: normal">for
ansatt nummer 10005 </span></strong><strong><span style="font-weight: normal">ved
&aring; trekke et &aring;rs l&oslash;nn fra fo</span></strong><strong><span style="font-weight: normal">r</span></strong><strong><span style="font-weight: normal">rige
&aring;rs l&oslash;nn (siden </span></strong><strong><span style="font-weight: normal">l&oslash;nnen
justeres hvert &aring;r) :</span></strong></p>
<h3 class="western"><a name="__RefHeading___Toc23697_3962996256"></a><strong><strong><span style="font-weight: normal">Med
</span></strong></strong><strong> </strong><strong><span style="font-weight: normal">Oracle,
PostgreSQL og MySQL/MariaDB</span></strong></h3>
<pre class="western">
SELECT EXTRACT(YEAR FROM from_date) AS &aring;r, salary AS l&oslash;nn, salary - <b>lag(salary) OVER (PARTITION BY emp_no </b><b>ORDER BY emp_no</b><b>)</b> AS &oslash;kning FROM salaries WHERE emp_no = 10005;


&aring;r  &nbsp;| l&oslash;nn &nbsp;| &oslash;kning &nbsp;<br/>
-----+-------+-------- <br/>
1989 | 78228 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
1990 | 82621 | &nbsp;&nbsp;4393 <br/>
1991 | 83735 | &nbsp;&nbsp;1114 <br/>
1992 | 85572 | &nbsp;&nbsp;1837 <br/>
1993 | 85076 | &nbsp;&nbsp;-496 <br/>
1994 | 86050 | &nbsp;&nbsp;&nbsp;974 <br/>
1995 | 88448 | &nbsp;&nbsp;2398 <br/>
1996 | 88063 | &nbsp;&nbsp;-385 <br/>
1997 | 89724 | &nbsp;&nbsp;1661 <br/>
1998 | 90392 | &nbsp;&nbsp;&nbsp;668 <br/>
1999 | 90531 | &nbsp;&nbsp;&nbsp;139 <br/>
2000 | 91453 | &nbsp;&nbsp;&nbsp;922 <br/>
2001 | 94692 | &nbsp;&nbsp;3239<font face="monospace"><br/>
</font></pre><h3 class="western">
<a name="__RefHeading___Toc23699_3962996256"></a>Med Microsoft
SQL-Server</h3>
<p class="western">Bytt ut extract() med year(), s&aring; fungerer
setningen for SQL-server:</p>
<pre class="western">SELECT year(from_date) AS &aring;r, salary AS l&oslash;nn, salary - <b>lag(salary) OVER (PARTITION BY emp_no </b><b>ORDER BY emp_no</b><b>)</b> AS &oslash;kning FROM salaries WHERE emp_no = 10005;

	   &aring;r &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	l&oslash;nn &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&oslash;kning <br/>
----------- ----------- ----------- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1989 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;78228 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1990 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;82621 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4393 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1991 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;83735 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1114 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1992 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;85572 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1837 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1993 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;85076 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-496 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1994 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;86050 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;974 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1995 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;88448 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2398 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1996 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;88063 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-385 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1997 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;89724 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1661 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1998 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;90392 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;668 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1999 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;90531 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;139 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;91453 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;922 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2001 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;94692 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3239</pre><p class="merk">
<b>MERK: </b><span style="font-weight: normal">Oracle og MS
SQL-Server tillater ikke en PARTITION som ikke er sortert med ORDER
BY. Det gj&oslash;r derimot MySQL/MariaDB og PostgreSQL, s&aring; for
disse kunne vi ha sl&oslash;yfet ORDER BY  og bare skrevet </span><b>OVER
(PARTITION BY emp_no) </b><span style="font-weight: normal">&ndash;</span><b>
</b><span style="font-weight: normal">men samtidig ville koden ha
blitt mindre portabel.</span></p>
<h2 class="western"><a name="__RefHeading___Toc24871_158302049"></a><strong><font color="#1b75bc">&#61609;
</font></strong><strong>Eksempel </strong><strong>5</strong><strong>:
Beregne l&oslash;nn </strong><strong>i kvantiler </strong>
</h2>
<p class="western"><strong><span style="font-weight: normal">En
</span></strong><strong><b>kvantil</b></strong><strong><span style="font-weight: normal">
er en gjennomsnittsverdi for en frekvensiell andel av et utval</span></strong><strong><span style="font-weight: normal">g.
Kvantiler brukes gjerne til &aring; lage frekvensfordelinger i et
datasett.</span></strong></p>
<p class="western"><strong><span style="font-weight: normal">Vi kan
enkelt dele inn e</span></strong><strong><span style="font-weight: normal">n
tabell</span></strong><strong><span style="font-weight: normal"> i
</span></strong><strong><span style="font-weight: normal">kvantiler &ndash;
dvs. i grupper av 4, 5, 10 , 100 osv basert p&aring; en sortering,
slik at vi for eksempel kan se hvilken gruppe l&oslash;nnen til en
ansatt h&oslash;rer hjemme i &ndash; er han/hun blant de 25% h&oslash;yest
l&oslash;nnede eller i den laveste </span></strong><strong><span style="font-weight: normal">prosent-gruppen.
Vi kan gj&oslash;re dette med vindusfunksjonen </span></strong><strong><b>NTILE(&lt;tall&gt;)</b></strong><strong><span style="font-weight: normal">,
f.eks. slik:</span></strong></p>
<h3 class="western"><a name="__RefHeading___Toc24873_158302049"></a><strong><span style="font-weight: normal">NTILE()
med </span></strong><strong><span style="font-weight: normal">MS SQL
Server, </span></strong><strong><span style="font-weight: normal">PostgreSQL,
</span></strong><strong><span style="font-weight: normal">MariaDB </span></strong><strong><span style="font-weight: normal">og
Oracle</span></strong></h3>
<pre class="western"><a name="__DdeLink__24812_158302049"></a><strong><span style="font-weight: normal">SELECT</span></strong><strong><span style="font-weight: normal"> s.emp_no, salary, dept_name,</span></strong>
<strong><b>NTILE(4) OVER (partition by de.dept_no order by salary)</b></strong>
<strong><span style="font-weight: normal">as </span></strong><strong><span style="font-weight: normal">kvartil</span></strong><strong><span style="font-weight: normal">,</span></strong>
<strong><b>NTILE(</b></strong><strong><b>10</b></strong><strong><b>) OVER (partition by de.dept_no order by salary)</b></strong>
<strong><span style="font-weight: normal">as </span></strong><strong><span style="font-weight: normal">desentil</span></strong><strong><span style="font-weight: normal">,</span></strong>
<strong><b>NTILE(10</b></strong><strong><b>0</b></strong><strong><b>) OVER (partition by de.dept_no order by salary)</b></strong>
<strong><span style="font-weight: normal">as p</span></strong><strong><span style="font-weight: normal">rosen</span></strong><strong><span style="font-weight: normal">til</span></strong>
<strong><span style="font-weight: normal">from salaries s</span></strong>
<strong><span style="font-weight: normal">inner join dept_emp de on s.emp_no = de.emp_no </span></strong>
<strong><span style="font-weight: normal">inner join departments d on d.dept_no = de.dept_no</span></strong>
<strong><span style="font-weight: normal">where s.to_date = '9999-01-01' and de.to_date = '9999-01-01';</span></strong>


<strong><span style="font-weight: normal">EMP_NO &nbsp;&nbsp;SALARY  DEPT_NAME &nbsp; </span></strong><strong><span style="font-weight: normal">KVARTIL </span></strong><strong><span style="font-weight: normal"> </span></strong><strong><span style="font-weight: normal">DESENTIL</span></strong><strong><span style="font-weight: normal">  PR</span></strong><strong><span style="font-weight: normal">OS</span></strong><strong><span style="font-weight: normal">ENTIL <br/>
--------------------------------------------------------- </span></strong><strong><font face="monospace"><span style="font-weight: normal"><br/>
....... .......  ..........  ........  .........  .........</span></font></strong>
<strong><span style="font-weight: normal">80937  | 142485 | Marketing | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100 <br/>
107140 | 142506 | Marketing | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100 <br/>
&nbsp;89825 | 143644 | Marketing | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100 <br/>
466852 | 145128 | Marketing | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100 <br/>
&nbsp;15830 | &nbsp;39012 | Finance &nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 <br/>
&nbsp;52559 | &nbsp;39346 | Finance &nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 <br/>
451706 | &nbsp;39794 | Finance &nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 <br/>
291552 | &nbsp;39949 | Finance &nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br/>
</span></strong><strong><font face="monospace"><span style="font-weight: normal">....... .......  ..........  ........  .........   ........</span></font></strong></pre><p class="merk">
<strong>MERK: </strong><strong><span style="font-weight: normal">Bytt
ut datoformatet til 01.01.9999 for at setinngen over skal fungere med
Oracle. </span></strong>
</p>
<h2 class="western"><a name="__RefHeading___Toc23701_3962996256"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Aggregering med vindusfunksjoner</h2>
<p class="western">En vanlig bruk av vindusfunksjoner er for &aring;
beregne diverse aggregeringer, f.eks. en kumulativ sum eller et
l&oslash;pende gjennomsnitt. Som med alle vindusfunksjoner bruker vi
aggregeringen sammen med n&oslash;kkelordet OVER etterfulgt av en
parentes som inneholder informasjon om hvordan vi vil lage den
kumulative aggregeringen, f.eks. slike <b>SELECT SUM(kostnad) OVER
(ORDER BY dato) FROM ... </b><span style="font-weight: normal">Denne
setningen vil gi oss et felt som inneholder den kumulative summen av
kostnadene etter dato (gitt at vi har et felt som heter </span><i><span style="font-weight: normal">kostnad</span></i><span style="font-weight: normal">
og et annet som heter </span><i><span style="font-weight: normal">dato</span></i><span style="font-weight: normal">).
Et </span><span style="font-weight: normal">par </span><span style="font-weight: normal">eksempl</span><span style="font-weight: normal">er</span><span style="font-weight: normal">
vil forh&aring;pentlig klargj&oslash;re hvordan dette fungerer i
praksis:</span></p>
<h2 class="western"><a name="__RefHeading___Toc23703_3962996256"></a><strong><font color="#1b75bc">&#61609;
</font></strong>Eksempel 5: L&oslash;nnshistorikk med kumulativ sum</h2>
<p class="western">Setningen nedenfor lister opp de ansattes
l&oslash;nnshistorikk &aring;r for &aring;r og beregner en kumulativ
sum av l&oslash;nnsutbetalinger og en kumulativ gjennomsnittsl&oslash;nn
over perioden for den ansatte. Det er kanskje en relativt lite
anvendelig tabell, men det illustrerer godt hvordan vindusfunksjoner
kan brukes til &aring; aggregere felt ut fra verdiene til foreg&aring;ende
rader. 
</p>
<h3 class="western"><a name="__RefHeading___Toc23705_3962996256"></a>Med
Microsoft SQL Server</h3>
<pre class="western">SELECT emp_no, year(from_date) AS &quot;&aring;r&quot;, salary AS &quot;l&oslash;nn&quot;, 
<b>sum(salary) OVER (PARTITION BY emp_no order by salary asc) AS sum, </b>
<b>round(avg(convert(float,salary)) OVER (PARTITION BY emp_no order by salary asc),2) as avg </b>
FROM salaries WHERE emp_no = 10001;

emp_no	&aring;r	l&oslash;nn	sum		avg

10001	1986	60117	60117		60117
10001	1987	62102	122219		61109,5
10001	1988	66074	188293		62764,33
10001	1989	66596	254889		63722,25
10001	1990	66961	321850		64370
10001	1991	71046	392896		65482,67
10001	1992	74333	467229		66747
10001	1993	75286	542515		67814,38
10001	1994	75994	618509		68723,22
10001	1995	76884	695393		69539,3
10001	1996	80013	775406		70491,45
10001	1997	81025	856431		71369,25
10001	1998	81097	937528		72117,54
10001	1999	84917	1022445	73031,79
10001	2001	85097	1107542	73836,13
10001	2000	85112	1192654	74540,88
10001	2002	88958	1281612	75388,94</pre><p class="merk">
<b>MERK: </b><span style="font-weight: normal">Legg merke til at vi
m&aring; konvertere feltet &laquo;salary&raquo; fra heltall til
desimaltall med funksjonen </span><b>convert()</b><span style="font-weight: normal">
for &aring; f&aring; </span><span style="font-weight: normal">ut
</span><span style="font-weight: normal">gjennomsnittet med to
desimaler</span></p>
<h3 class="western"><a name="__RefHeading___Toc23707_3962996256"></a><strong><span style="font-weight: normal">Med
</span></strong><strong><span style="font-weight: normal">Oracle,
</span></strong><strong><span style="font-weight: normal">PostgreSQL
og MySQL/MariaDB</span></strong></h3>
<pre class="western"><strong><span style="font-weight: normal">SELECT emp_no, extract(year from from_date) &quot;&aring;r&quot;, salary &quot;l&oslash;nn&quot;, </span></strong>
<strong><b>sum(salary) OVER (PARTITION BY emp_no order by salary asc) sum, </b></strong>
<strong><b>round(avg(salary) OVER (PARTITION BY emp_no order by salary),2) avg</b></strong><strong><span style="font-weight: normal"> </span></strong>
<strong><span style="font-weight: normal">FROM salaries WHERE emp_no = 10001; </span></strong>

<strong><span style="font-weight: normal">emp_no | &nbsp;&Aring;r &nbsp;| l&oslash;nn &nbsp;| &nbsp;&nbsp;sum &nbsp;&nbsp;| &nbsp;&nbsp;avg &nbsp;&nbsp;&nbsp;&nbsp;<br/>
--------+------+-------+---------+---------- <br/>
&nbsp;10001 | 1986 | 60117 | &nbsp;&nbsp;60117 | 60117.00 <br/>
&nbsp;10001 | 1987 | 62102 | &nbsp;122219 | 61109.50 <br/>
&nbsp;10001 | 1988 | 66074 | &nbsp;188293 | 62764.33 <br/>
&nbsp;10001 | 1989 | 66596 | &nbsp;254889 | 63722.25 <br/>
&nbsp;10001 | 1990 | 66961 | &nbsp;321850 | 64370.00 <br/>
&nbsp;10001 | 1991 | 71046 | &nbsp;392896 | 65482.67 <br/>
&nbsp;10001 | 1992 | 74333 | &nbsp;467229 | 66747.00 <br/>
&nbsp;10001 | 1993 | 75286 | &nbsp;542515 | 67814.38 <br/>
&nbsp;10001 | 1994 | 75994 | &nbsp;618509 | 68723.22 <br/>
&nbsp;10001 | 1995 | 76884 | &nbsp;695393 | 69539.30 <br/>
&nbsp;10001 | 1996 | 80013 | &nbsp;775406 | 70491.45 <br/>
&nbsp;10001 | 1997 | 81025 | &nbsp;856431 | 71369.25 <br/>
&nbsp;10001 | 1998 | 81097 | &nbsp;937528 | 72117.54 <br/>
&nbsp;10001 | 1999 | 84917 | 1022445 | 73031.79 <br/>
&nbsp;10001 | 2001 | 85097 | 1107542 | 73836.13 <br/>
&nbsp;10001 | 2000 | 85112 | 1192654 | 74540.88 <br/>
&nbsp;10001 | 2002 | 88958 | 1281612 | 75388.94</span></strong></pre><h2 class="western">
<a name="__RefHeading___Toc16409_3466130985"></a><strong><font color="#1b75bc">&#61609;
 </font></strong>Eksempel 6: En overforenklet bank-applikasjon</h2>
<p class="western">Vi skal vise et eksempel hvor vi opprette en liten
bank og etabler en database med <b>to tabeller &ndash; en for kunder
og en for konto-transaksjoner</b>. I dette eksemplet bruker vi
PostgreSQL, men aggregeringene fungerer helt likt med de andre tre
RDBMSene.</p>
<p class="western">F&oslash;rst oppretter vi de to tabellene <b>kunde</b>
og <b>konto. </b>
</p>
<p class="western"><b>Tabellen kunde</b><span style="font-weight: normal">
inneholder et felt </span><b>id, </b><span style="font-weight: normal">som
er et l&oslash;penummer som genereres automatisk og vil v&aelig;re
prim&aelig;rn&oslash;kkel i tabellen. Med PostgreSQL skjer dette
automatisk hvis vi setter datatypen for feltet til </span><b>serial</b><span style="font-weight: normal">
eller </span><b>bigserial </b><span style="font-weight: normal">(anbefales)</span><b>.
</b><span style="font-weight: normal">Videre er det et felt </span><b>konto
</b><span style="font-weight: normal">som er av typen </span><b>uuid</b><span style="font-weight: normal">
(</span><span style="font-weight: normal">universally unique
identifier) og i tillegg er satt til &aring; inneholde unike verdier
med n&oslash;kkelordet </span><i><span style="font-weight: normal">unique</span></i><span style="font-weight: normal">.
Vi kan angi at det skal settes en default-verdi for feltet, og den
kan lages med funksjonen </span><i><span style="font-weight: normal">uuid_generate_v4(),
</span></i><span style="font-style: normal"><span style="font-weight: normal">som
automatisk lager en uuid og setter den inn i feltet. S&aring; kommer
feltet </span></span><span style="font-style: normal"><b>epost</b></span><span style="font-style: normal"><span style="font-weight: normal">,</span></span><span style="font-style: normal"><b>
</b></span><span style="font-style: normal"><span style="font-weight: normal">som
ogs&aring; er satt til &aring; inneholde unike verdier, og vil
inneholde kundens epostadresse. Til sist er det et felt </span></span><span style="font-style: normal"><b>registrert</b></span><span style="font-style: normal"><span style="font-weight: normal">
som er av datatypen </span></span><span style="font-style: normal"><b>timestamptz</b></span><span style="font-style: normal"><span style="font-weight: normal">,
dvs. feltet vil inneholde dato og tid og ta hensyn til tidssone (tz
st&aring;r for time zone), og setter default-verdien til funksjonen
</span></span><i><span style="font-weight: normal">now()</span></i><span style="font-style: normal"><span style="font-weight: normal">,
slik at tidspunktet for registreringen av kontoen legges inn
automatisk. Vi trenger mao bare &aring; legge inn kundens
epostadresse, s&aring; opprettes en id og et kontonummer og et
registreringstidspunkt automatisk.</span></span></p>
<p class="western"><b><span style="font-style: normal">Tabellen konto
</span></b><span style="font-style: normal"><span style="font-weight: normal">inneholder
ogs&aring; et felt </span></span><b><span style="font-style: normal">id
</span></b><span style="font-style: normal"><span style="font-weight: normal">som
er prim&aelig;rn&oslash;kkel og selv-&oslash;kende, og i tillegg et
felt </span></span><b><span style="font-style: normal">konto </span></b><span style="font-style: normal"><span style="font-weight: normal">som
er av typen uuid og vil angi hvilken konto vi skal registrere
transaksjoner p&aring;. Bel&oslash;pet som settes inn eller tas ut av
konto angis i feltet </span></span><b><span style="font-style: normal">transaksjon
</span></b><span style="font-style: normal"><span style="font-weight: normal">som
er av typen </span></span><b><span style="font-style: normal">numeric</span></b><span style="font-style: normal"><span style="font-weight: normal">,
det vil si et tallfelt. </span></span><span style="font-style: normal"><span style="font-weight: normal">Vi
legger ogs&aring; til et felt </span></span><b><span style="font-style: normal">reg
</span></b><span style="font-style: normal"><span style="font-weight: normal">som
er likt </span></span><b><span style="font-style: normal">registrert
</span></b><span style="font-style: normal"><span style="font-weight: normal">i
kunde-tabellen, og hvor tidspunktet for registrering av transaksjonen
blir satt inn automatisk. Vi trenger mao bare sette inn kontonummer
og bel&oslash;p for hver transaksjon.</span></span></p>
<h3 class="western"><a name="__RefHeading___Toc19103_2730267216"></a>Med
PostgreSQL</h3>
<p class="western">Her er SQL-setningene som oppretter de to
tabellene:</p>
<pre class="western"><b>create table kunde</b> (id bigserial primary key, konto uuid unique default uuid_generate_v4(),epost text unique,registrert timestamptz default now());<br/>
<br/>
<b>create table konto</b> (id bigserial primary key, konto uuid, transaksjon numeric, registrert timestamptz default now());</pre><p class="merk">
<b>MERK:</b> For &aring; bruke funksjonen uuid_generate_v4() m&aring;
vi f&oslash;rst installere utvidelsen &laquo;uuid-ossp&raquo;, som vi
gj&oslash;r med denne kommandoen: <span style="font-weight: normal">CREATE
EXTENSION &quot;uuid-ossp&quot; </span>
</p>
<p class="western">Vi kan beskrive de to tabellene med komandoen <b>\d
&lt;tabellnavn&gt; </b><span style="font-weight: normal">i
PostgreSQLs terminaklient. (\ angir en kommando og d st&aring;r for
describe): </span>
</p>
<pre class="western">\d kunde <br/>
<font size="1" style="font-size: 7pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Table &quot;kunde&quot; <br/>
&nbsp;&nbsp;Column &nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifiers &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
------------+--------------------------+---------------------------------------------------- <br/>
id &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| bigint &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| not null default nextval('kunde_id_seq'::regclass) <br/>
konto &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| uuid &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| default uuid_generate_v4() <br/>
epost &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| text &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;<br/>
registrert | timestamp with time zone | default now() <br/>
Indexes: <br/>
&nbsp;&nbsp;&nbsp;&quot;kunde_pkey&quot; PRIMARY KEY, btree (id) <br/>
&nbsp;&nbsp;&nbsp;&quot;kunde_epost_key&quot; UNIQUE CONSTRAINT, btree (epost) <br/>
&nbsp;&nbsp;&nbsp;&quot;kunde_konto_key&quot; UNIQUE CONSTRAINT, btree (konto) <br/>
</font><br/>
\d konto <br/>
<font size="1" style="font-size: 7pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Table &quot;konto&quot; <br/>
&nbsp;&nbsp;Column &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifiers &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
-------------+--------------------------+---------------------------------------------------- <br/>
id &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| bigint &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| not null default nextval('konto_id_seq'::regclass) <br/>
konto &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| uuid &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;<br/>
transaksjon | numeric &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;<br/>
reg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| timestamp with time zone | default now() <br/>
Indexes: <br/>
&nbsp;&nbsp;&nbsp;&quot;konto_pkey&quot; PRIMARY KEY, btree (id)</font></pre><p class="merk">
<b>MERK:</b> <span style="font-weight: normal">Vi ser at PostgreSQL
har opprettet indekser for prim&aelig;rn&oslash;kkel og de unike
feltene, og to sekvenser </span><span style="font-weight: normal">(kunde_id_seq
og konto_id_seq) </span><span style="font-weight: normal">som de
selv-&oslash;kende id-feltene bruker til &aring; hente neste tall
fra. </span>
</p>
<p class="western">S&aring; kan vi legge inn noen <b>testdata</b> i
tabellene. PostgreSQL har en fin funksjon som vi kan dra nytte av
her:  <b>generate_series(). </b><span style="font-weight: normal">Den
kan vi bruke til &aring; generere epostadresser vi kan sette inn i
kundetabellen, slik:</span></p>
<pre class="western">INSERT INTO kunde (epost) 
VALUES ('kunde' || generate_series(1,1000) || '@example.com');</pre><p class="western" style="font-weight: normal">
Denne setningen vil sette inn 1000 rader i kunde-tabellen med unike
epostadresser. Slik vil de f&oslash;rste radene av tabellen se ut:</p>
<pre class="western">select * from kunde limit 5;

<font size="1" style="font-size: 6pt">id | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;konto &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;epost &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;registrert &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
----+--------------------------------------+-----------------------+------------------------------- <br/>
&nbsp;1 | 2884c053-148b-4395-a40e-cec393b2ec8d | kunde1@example.com &nbsp;&nbsp;&nbsp;| 2017-07-14 13:51:51.568805+02 <br/>
&nbsp;2 | dc02b4b5-fd20-477f-aa56-d9eed4d1fb1f | kunde2@example.com &nbsp;&nbsp;&nbsp;| 2017-07-14 13:51:51.568805+02 <br/>
&nbsp;3 | 2c27ab28-67c9-4190-8f4b-f5c18a35307b | kunde3@example.com &nbsp;&nbsp;&nbsp;| 2017-07-14 13:51:51.568805+02 <br/>
&nbsp;4 | f455abad-4a8a-4778-ba4d-f85f6e613574 | kunde4@example.com &nbsp;&nbsp;&nbsp;| 2017-07-14 13:51:51.568805+02 <br/>
&nbsp;5 | 89e0ce44-1357-4ab3-af9f-fb2ac44f0ecf | kunde5@example.com &nbsp;&nbsp;&nbsp;| 2017-07-14 13:51:51.568805+02 </font></pre><p class="western" style="font-weight: normal">
S&aring; kan vi legge inn noen transaksjoner for kundene. Siden
kontonumrene er lange og vanskelige &aring; huske, kan vi sl&aring;
dem opp via epostadressen med en undersp&oslash;rring (se senere
kapittel), slik:</p>
<pre class="western">INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde1@example.com'),7000);</pre><p class="western">
Setningen over setter inn 7000 p&aring; kontoen til kunden med epost
kunde1@example.com. Vi kan gjenbruke setningen og bytte ut bel&oslash;pet
og legge inn flere transaksjoner, slik:</p>
<pre class="western">INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde1@example.com'),4000); <br/>

INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde1@example.com'),-600); <br/>

INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde1@example.com'),-700); <br/>

terje=# INSERT INTO konto (konto,transaksjon) VALUES ((select konto from 
kunde where epost ='kunde1@example.com'),4000);</pre><p class="western">
Vi kan f&aring; en oversikt over kontotransaksjonene til
kunde1@example.com med denne setningen:</p>
<pre class="western">select * from konto where konto= (select konto from kunde where epost='kunde1@example.com'); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>

<font size="1" style="font-size: 7pt">id | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;konto &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| transaksjon | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
----+--------------------------------------+-------------+------------------------------- <br/>
13 | 2884c053-148b-4395-a40e-cec393b2ec8d | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7000 | 2017-07-14 16:52:20.015053+02 <br/>
14 | 2884c053-148b-4395-a40e-cec393b2ec8d | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4000 | 2017-07-14 16:52:28.332063+02 <br/>
15 | 2884c053-148b-4395-a40e-cec393b2ec8d | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-600 | 2017-07-14 16:52:33.830643+02 <br/>
16 | 2884c053-148b-4395-a40e-cec393b2ec8d | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-700 | 2017-07-14 16:52:36.613939+02 <br/>
17 | 2884c053-148b-4395-a40e-cec393b2ec8d | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4000 | 2017-07-14 16:52:42.660808+02</font></pre><p class="western">
Vi kan pynte litt p&aring; resultatet og legge til en <b>saldo ved
hjelp av en vindusfunksjon</b>, slik:</p>
<pre class="western">SELECT DATE(reg), transaksjon, <b>sum(transaksjon) OVER (order by reg)</b> as saldo from konto where konto = (SELECT konto from kunde<br/>
where epost='kunde1@example.com'); <br/>

&nbsp;&nbsp;&nbsp;date &nbsp;&nbsp;&nbsp;| transaksjon | saldo &nbsp;<br/>
------------+-------------+------- <br/>
2017-07-14 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7000 | &nbsp;7000 <br/>
2017-07-14 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4000 | 11000 <br/>
2017-07-14 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-600 | 10400 <br/>
2017-07-14 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-700 | &nbsp;9700 <br/>
2017-07-14 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4000 | 13700</pre><p class="western">
S&aring; kan vi legge inn noen transaksjoner for kunde2@example.com: 
</p>
<pre class="western">INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde2@example.com'),3000); <br/>
INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde2@example.com'),12000); <br/>
INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde2@example.com'),-4000); <br/>
INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde2@example.com'),-670); &nbsp;<br/>
INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde2@example.com'),-3000); <br/>
INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde2@example.com'),12000);</pre><p class="western">
Vi kan n&aring; liste ut en tabell med alle transaksjonene til de to
kontoinnehaverne med saldo som justeres for hver konto (og
epostadressen istedenfor kontonummeret) , slik:</p>
<pre class="western">SELECT date(reg), epost,transaksjon, 
<b>sum(transaksjon) OVER (partition by k.konto order by reg) as saldo</b> 
FROM konto k INNER JOIN kunde k2 ON k.konto=k2.konto; 
<br/>
&nbsp;&nbsp;&nbsp;date &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;epost &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| transaksjon | saldo &nbsp;<br/>
------------+-----------------------+-------------+------- <br/>
2017-07-14 | kunde1@example.com &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7000 | &nbsp;7000 <br/>
2017-07-14 | kunde1@example.com &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4000 | 11000 <br/>
2017-07-14 | kunde1@example.com &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-600 | 10400 <br/>
2017-07-14 | kunde1@example.com &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-700 | &nbsp;9700 <br/>
2017-07-14 | kunde1@example.com &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4000 | 13700
 <br/>
2017-07-14 | kunde2@example.com &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3000 | &nbsp;3000 <br/>
2017-07-14 | kunde2@example.com &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12000 | 15000 <br/>
2017-07-14 | kunde2@example.com &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-4000 | 11000 <br/>
2017-07-14 | kunde2@example.com &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-670 | 10330 <br/>
2017-07-14 | kunde2@example.com &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-3000 | &nbsp;7330 <br/>
2017-07-14 | kunde2@example.com &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12000 | 19330</pre><h3 class="western">
<a name="__RefHeading___Toc19105_2730267216"></a>Med MySQL/MariaDB</h3>
<p class="western">F&oslash;rst oppretter vi de to tabellene vi skal
bruke i eksemplet:</p>
<pre class="western">CREATE TABLE kunde (<br/>
id bigint primary key auto_increment, <br/>
konto VARCHAR(36) unique default UUID(),<br/>
epost VARCHAR(299) unique,<br/>
registrert datetime default now()<br/>
);<br/>
<br/>
CREATE TABLE konto (<br/>
id bigint primary key auto_increment, <br/>
konto  VARCHAR(36), <br/>
transaksjon decimal, <br/>
registrert datetime default now());</pre><p class="western">
S&aring; legger vi inn test-data i tabellene:</p>
<pre class="western">INSERT INTO kunde (epost) VALUES ('kunde1@example.com');<br/>
INSERT INTO kunde (epost) VALUES ('kunde2@example.com');<br/>
INSERT INTO kunde (epost) VALUES ('kunde3@example.com');<br/>
INSERT INTO kunde (epost) VALUES ('kunde4@example.com');<br/>
INSERT INTO kunde (epost) VALUES ('kunde5@example.com');</pre><p class="western">
Siden feltene id, konto og registrert blir lagt inn automatisk med
default-verdiene, vil kunde-tabellen n&aring; se slik ut:</p>
<pre class="western"><font size="2" style="font-size: 9pt">select * from kunde;</font>
<font size="1" style="font-size: 7pt">+----+--------------------------------------+--------------------+---------------------+</font>
<font size="1" style="font-size: 7pt">| id | konto                                | epost              | registrert          |</font>
<font size="1" style="font-size: 7pt">+----+--------------------------------------+--------------------+---------------------+</font>
<font size="1" style="font-size: 7pt">|  1 | d3e6b3a7-0129-11e8-8443-002324cb441a | kunde1@example.com | 2018-01-24 18:12:59 |</font>
<font size="1" style="font-size: 7pt">|  2 | d57ba2cf-0129-11e8-8443-002324cb441a | kunde2@example.com | 2018-01-24 18:13:02 |</font>
<font size="1" style="font-size: 7pt">|  3 | d79db1f2-0129-11e8-8443-002324cb441a | kunde3@example.com | 2018-01-24 18:13:05 |</font>
<font size="1" style="font-size: 7pt">|  4 | d9cb1736-0129-11e8-8443-002324cb441a | kunde4@example.com | 2018-01-24 18:13:09 |</font>
<font size="1" style="font-size: 7pt">|  5 | dc00d9c5-0129-11e8-8443-002324cb441a | kunde5@example.com | 2018-01-24 18:13:13 |</font>
<font size="1" style="font-size: 7pt">+----+--------------------------------------+--------------------+---------------------+</font>
<font size="1" style="font-size: 7pt">5 rows in set (0.000 sec)</font></pre><p class="western" style="font-weight: normal">
S&aring; kan vi legge inn noen transaksjoner for kundene. Siden
kontonumrene er lange og vanskelige &aring; huske, kan vi sl&aring;
dem opp via epostadressen med en undersp&oslash;rring (se senere
kapittel), slik:</p>
<pre class="western">INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde1@example.com'),7000);</pre><p class="western">
Setningen over setter inn 7000 p&aring; kontoen til kunden med epost
kunde1@example.com. Vi kan gjenbruke setningen og bytte ut bel&oslash;pet
og legge inn flere transaksjoner, slik:</p>
<pre class="western">INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde1@example.com'),4000); <br/>

INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde1@example.com'),-600); <br/>

INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde1@example.com'),-700); <br/>

INSERT INTO konto (konto,transaksjon) VALUES ((select konto from 
kunde where epost ='kunde1@example.com'),4000);</pre><p class="western">
Vi kan f&aring; en oversikt over kontotransaksjonene til
kunde1@example.com med denne setningen:</p>
<pre class="western">select * from konto where konto= (select konto from kunde where epost='kunde1@example.com'); 
<font size="1" style="font-size: 7pt">+----+--------------------------------------+-------------+---------------------+ </font>
<font size="1" style="font-size: 7pt">| id | konto                                | transaksjon | registrert          |</font>
<font size="1" style="font-size: 7pt">+----+--------------------------------------+-------------+---------------------+</font>
<font size="1" style="font-size: 7pt">|  7 | d3e6b3a7-0129-11e8-8443-002324cb441a | 7000        | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">|  8 | d3e6b3a7-0129-11e8-8443-002324cb441a | 4000        | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">|  9 | d3e6b3a7-0129-11e8-8443-002324cb441a | -600        | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">| 10 | d3e6b3a7-0129-11e8-8443-002324cb441a | -700        | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">| 11 | d3e6b3a7-0129-11e8-8443-002324cb441a | 4000        | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">+----+--------------------------------------+-------------+---------------------+</font>
<font size="1" style="font-size: 7pt">5 rows in set (0.000 sec</font>)</pre><p class="western">
S&aring; kan vi legge inn noen transaksjoner for kunde2@example.com: 
</p>
<pre class="western"><font size="2" style="font-size: 9pt">INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde2@example.com'),3000); <br/>
INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde2@example.com'),12000); <br/>
INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde2@example.com'),-4000); <br/>
INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde2@example.com'),-670); &nbsp;<br/>
INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde2@example.com'),-3000); <br/>
INSERT INTO konto (konto,transaksjon) VALUES ((select konto from kunde where epost ='kunde2@example.com'),12000);</font></pre><p class="western">
Etter insetting av default-verdier for registrert-feltet ser da
konto-tabellen slik ut:</p>
<pre class="western"> select * from konto; 
<font size="1" style="font-size: 7pt">+----+--------------------------------------+-------------+---------------------+</font>
<font size="1" style="font-size: 7pt">| id | konto                                | transaksjon | registrert          |</font>
<font size="1" style="font-size: 7pt">+----+--------------------------------------+-------------+---------------------+</font>
<font size="1" style="font-size: 7pt">|  1 | d57ba2cf-0129-11e8-8443-002324cb441a | 3000        | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">|  2 | d57ba2cf-0129-11e8-8443-002324cb441a | 12000       | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">|  3 | d57ba2cf-0129-11e8-8443-002324cb441a | -4000       | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">|  4 | d57ba2cf-0129-11e8-8443-002324cb441a | -670        | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">|  5 | d57ba2cf-0129-11e8-8443-002324cb441a | -3000       | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">|  6 | d57ba2cf-0129-11e8-8443-002324cb441a | 12000       | 2018-01-24 18:17:38 |</font>

<font size="1" style="font-size: 7pt">|  7 | d3e6b3a7-0129-11e8-8443-002324cb441a | 7000        | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">|  8 | d3e6b3a7-0129-11e8-8443-002324cb441a | 4000        | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">|  9 | d3e6b3a7-0129-11e8-8443-002324cb441a | -600        | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">| 10 | d3e6b3a7-0129-11e8-8443-002324cb441a | -700        | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">| 11 | d3e6b3a7-0129-11e8-8443-002324cb441a | 4000        | 2018-01-24 18:17:38 |</font>
<font size="1" style="font-size: 7pt">+----+--------------------------------------+-------------+---------------------+</font>
<font size="1" style="font-size: 7pt">11 rows in set (0.001 sec)</font></pre><p class="western">
Vi kan n&aring; liste ut en tabell med alle transaksjonene til de to
kontoinnehaverne med saldo som justeres for hver konto (og
epostadressen istedenfor kontonummeret) , slik:</p>
<pre class="western">SELECT date(k.registrert), epost,transaksjon, 
<b>sum(transaksjon) OVER (partition by k.konto order by </b><b>k.</b><b>reg</b><b>istrert</b><b>) saldo</b> 
<font size="2" style="font-size: 9pt">FROM konto k INNER JOIN kunde k2 ON k.konto=k2.konto; </font>

<font size="2" style="font-size: 9pt">+--------------------+--------------------+-------------+-------+</font>
<font size="2" style="font-size: 9pt">| date(k.registrert) | epost              | transaksjon | saldo |</font>
<font size="2" style="font-size: 9pt">+--------------------+--------------------+-------------+-------+</font>
<font size="2" style="font-size: 9pt">| 2018-01-24         | kunde2@example.com | 3000        | 3000  |</font>
<font size="2" style="font-size: 9pt">| 2018-01-24         | kunde2@example.com | 12000       | 15000 |</font>
<font size="2" style="font-size: 9pt">| 2018-01-24         | kunde2@example.com | -4000       | 11000 |</font>
<font size="2" style="font-size: 9pt">| 2018-01-24         | kunde2@example.com | -670        | 10330 |</font>
<font size="2" style="font-size: 9pt">| 2018-01-24         | kunde2@example.com | -3000       | 7330  |</font>
<font size="2" style="font-size: 9pt">| 2018-01-24         | kunde2@example.com | 12000       | 19330 |</font>

<font size="2" style="font-size: 9pt">| 2018-01-24         | kunde1@example.com | 7000        | 7000  |</font>
<font size="2" style="font-size: 9pt">| 2018-01-24         | kunde1@example.com | 4000        | 11000 |</font>
<font size="2" style="font-size: 9pt">| 2018-01-24         | kunde1@example.com | -600        | 10400 |</font>
<font size="2" style="font-size: 9pt">| 2018-01-24         | kunde1@example.com | -700        | 9700  |</font>
<font size="2" style="font-size: 9pt">| 2018-01-24         | kunde1@example.com | 4000        | 13700 |</font>
<font size="2" style="font-size: 9pt">+--------------------+--------------------+-------------+-------+</font></pre><h2 class="western">
<a name="__RefHeading___Toc18240_15578344861"></a><br/>
<br/>

</h2>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc18246_1557834486"></a>
<font size="6" style="font-size: 24pt">Kapittel </font><font size="6" style="font-size: 24pt">10</font><font size="6" style="font-size: 24pt"><br/>
</font>Views
og <br/>
Materialized Views</h1>
<h2 class="western"><a name="__RefHeading___Toc18248_1557834486"></a><strong><font color="#1b75bc">&#61609;</font></strong><strong>
</strong><strong><span style="font-weight: normal">Bruk av Views</span></strong></h2>
<p class="western"><strong><b>Views </b></strong><strong><span style="font-weight: normal">er
virtuelle tabeller - dvs. tabeller som ikke inneholder data, men
sp&oslash;rresetninger som dynamisk henter data til en visning. En
komplisert sp&oslash;rresetning kan lagres som et View med et nytt
navn og deretter brukes som en ordin&aelig;r tabell. &quot;Select *
from </span></strong><strong><span style="font-weight: normal">&lt;</span></strong><strong><span style="font-weight: normal">navn-p&aring;-view</span></strong><strong><span style="font-weight: normal">&gt;</span></strong><strong><span style="font-weight: normal">&quot;
vil gi samme resultat som den opprinnelige sp&oslash;rresetningen.</span></strong></p>
<p class="western">Slik slipper man &aring; skrive den kompliserte
sp&oslash;rringen om igjen, og man kan lage enda mer kompliserte
sp&oslash;rringer ved &aring; legge til filtreringskriterier til
sp&oslash;rringen mot view'et - og man slipper &aring; lagre noe i en
ny tabell for &aring; f&aring; dette til - View'et er bare et vindu
inn til data som er lagret i eksisterende tabeller.</p>
<p class="western">En vanlig grunn til &aring; opprette views er ogs&aring;
at man kan gi tilgangsrettigheter til &aring; kj&oslash;re SELECT p&aring;
et view uten &aring; gi tilgangsrettigheter til &aring; kj&oslash;re
SELECT p&aring; de underliggende tabellene. Slik kan en bruker f.eks.
f&aring; tilgang til summerte l&oslash;nnsoversikter uten &aring; f&aring;
tilgang til individuelle l&oslash;nnsdata.</p>
<p class="western"><strong>Views lages enkelt med denne syntaksen:</strong></p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">CREATE VIEW &lt;navn&gt; AS &lt;SQL-sp&oslash;rresetning&gt;</span></strong></pre><p class="western">
Man kan lage nye views basert p&aring; eksisterende views, men det er
viktig &aring; ha et blikk for hvor kompliserte joins som m&aring;
utf&oslash;res (av hastighetshensyn) og hvor &quot;obfuskerte&quot;
data blir  - det blir vanskelig &aring; vite hvilke tabeller de ulike
dataene opprinnelig kommer fra.</p>
<p class="merk"><strong>MERK:</strong> Et view gir oppdaterte data,
og tar derfor like lang tid &aring; utf&oslash;re som de originale
SQL-sp&oslash;rringene Viewet er basert p&aring;. Dersom du &oslash;nsker
en rask tabell kan du lage en ny tabell av sp&oslash;rringen
istedenfor et view. Tabellen vil derimot v&aelig;re statisk og ikke
reflektere endringer i de underliggende data.</p>
<p class="western">For eksempel kan denne sp&oslash;rringen lagres
som et view med navn <strong>avdelingsoversikt</strong>:</p>
<h3 class="western"><a name="__RefHeading___Toc4451_762629072"></a>Views
med MySQL / MariaDB</h3>
<pre class="western"><strong><span style="font-weight: normal">CREATE VIEW avdelingsoversikt AS</span></strong>
<strong><span style="font-weight: normal">SELECT </span></strong>
<strong>        <span style="font-weight: normal">d.dept_name AS Avdeling,</span></strong>
<strong>        <span style="font-weight: normal">COUNT(de.emp_no) AS Ansatte,</span></strong>
<strong>        <span style="font-weight: normal">CONCAT(e.first_name, ' ', e.last_name) AS Leder,</span></strong>
<strong>        <span style="font-weight: normal">e.gender AS Kj&oslash;nn,</span></strong>
<strong>        <span style="font-weight: normal">TIMESTAMPDIFF(YEAR,e.birth_date,CURDATE()) AS Alder</span></strong>
<strong>    <span style="font-weight: normal">FROM</span></strong>
<strong>        <span style="font-weight: normal">departments AS d, employees AS e, dept_manager AS dm, dept_emp AS de</span></strong>
<strong>    <span style="font-weight: normal">WHERE</span></strong>
<strong>        <span style="font-weight: normal">d.dept_no = dm.dept_no</span></strong>
<strong>            <span style="font-weight: normal">AND e.emp_no = dm.emp_no</span></strong>
<strong>            <span style="font-weight: normal">AND de.dept_no = d.dept_no</span></strong>
<strong>            <span style="font-weight: normal">AND YEAR(dm.to_date) = 9999</span></strong>
<strong>            <span style="font-weight: normal">AND YEAR(de.to_date) = 9999</span></strong>
<strong>    <span style="font-weight: normal">GROUP BY d.dept_name</span></strong>
<strong>    <span style="font-weight: normal">ORDER BY Ansatte DESC;</span></strong></pre><p class="western">
S&aring; kan vi bruke SELECT p&aring; avdelingsoversikt og f&aring;
samme resultatet som den mye lengre setningen ovenfor:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">SELECT * FROM avdelingsoversikt;</span></strong>
<strong><span style="font-weight: normal">+--------------------+---------+-------------------+--------+-------+ <br/>
| Avdeling &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Ansatte | Leder &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Kj&oslash;nn &nbsp;| Alder | <br/>
+--------------------+---------+-------------------+--------+-------+ <br/>
| Development &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;61386 | Leon DasSarma &nbsp;&nbsp;&nbsp;&nbsp;| F &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;52 | <br/>
| Production &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;53304 | Oscar Ghazalie &nbsp;&nbsp;&nbsp;| M &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;53 | <br/>
| Sales &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;37701 | Hauke Zhang &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| M &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;61 | <br/>
| Customer Service &nbsp;&nbsp;| &nbsp;&nbsp;17569 | Yuchang Weedman &nbsp;&nbsp;| M &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;56 | <br/>
| Research &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;15441 | Hilary Kambil &nbsp;&nbsp;&nbsp;&nbsp;| F &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;64 | <br/>
| Marketing &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;14842 | Vishwani Minakawa | M &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;53 | <br/>
| Quality Management | &nbsp;&nbsp;14546 | Dung Pesch &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| M &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;56 | <br/>
| Human Resources &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;12898 | Karsten Sigstam &nbsp;&nbsp;| F &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;58 | <br/>
| Finance &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;12437 | Isamu Legleitner &nbsp;| F &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;59 | <br/>
+--------------------+---------+-------------------+--------+-------+</span></strong></pre><h3 class="western">
<a name="__RefHeading___Toc4453_762629072"></a>Views med PostgreSQL</h3>
<p class="western">Med PostgreSQL blir SQL-setningen litt annerledes.
PostgreSQL har f.eks. funksjonen <b>age()</b> som kan settes rundt et
datofelt og beregner alder med &aring;r, m&aring;ned og dag. Vi m&aring;
ogs&aring; sette alle uttrykk/feltnavn som ikke er aggregeringer, dvs
alt utenom count()-funksjonen inn i GROUP BY, slik man ogs&aring; m&aring;
med ORACLE og Microsoft SQL Server.</p>
<pre class="western"><strong><span style="font-weight: normal">CREATE VIEW avdelingsoversikt AS</span></strong>
<strong><span style="font-weight: normal">SELECT </span></strong>
<strong>&nbsp;&nbsp;&nbsp;<span style="font-weight: normal">d.dept_name AS Avdeling,</span></strong>
<strong>&nbsp;&nbsp;&nbsp;<span style="font-weight: normal">COUNT(de.emp_no) AS Ansatte,</span></strong>
<strong>&nbsp;&nbsp;&nbsp;<span style="font-weight: normal">CONCAT(e.first_name, ' ', e.last_name) AS Leder,</span></strong>
<strong>&nbsp;&nbsp;&nbsp;<span style="font-weight: normal">e.gender AS Kj&oslash;nn,</span></strong>
<strong>&nbsp;&nbsp;&nbsp;<span style="font-weight: normal">age(birth_date) AS Alder</span></strong>
<strong><span style="font-weight: normal">FROM</span></strong>
<strong>&nbsp;&nbsp;&nbsp;<span style="font-weight: normal">departments AS d, employees AS e, dept_manager AS dm, dept_emp AS de</span></strong>
<strong><span style="font-weight: normal">WHERE</span></strong>
<strong>&nbsp;&nbsp;&nbsp;<span style="font-weight: normal">d.dept_no = dm.dept_no</span></strong>
<strong>&nbsp;&nbsp;&nbsp;<span style="font-weight: normal">AND e.emp_no = dm.emp_no</span></strong>
<strong>&nbsp;&nbsp;&nbsp;<span style="font-weight: normal">AND de.dept_no = d.dept_no</span></strong>
<strong>&nbsp;&nbsp;&nbsp;<span style="font-weight: normal">AND extract(year from dm.to_date) = 9999</span></strong>
<strong>&nbsp;&nbsp;&nbsp;<span style="font-weight: normal">AND extract(year from de.to_date) = 9999</span></strong>
<strong><span style="font-weight: normal">GROUP BY d.dept_name, Leder, e.gender, birth_date</span></strong>
<strong><span style="font-weight: normal">ORDER BY Ansatte DESC;</span></strong></pre><p class="western">
Vi kan sp&oslash;rre direkte i view-et slik:</p>
<pre class="western"><strong>select * from avdelingsoversikt;</strong>
     <font size="1" style="font-size: 8pt">avdeling      | ansatte |       leder       | kj&oslash;nn |          alder          </font>
<font size="1" style="font-size: 8pt">-------------------+---------+-------------------+-------+-------------------------</font>
<font size="1" style="font-size: 8pt">Development        |   61386 | Leon DasSarma     | F     | 52 years 5 mons 1 day</font>
<font size="1" style="font-size: 8pt">Production         |   53304 | Oscar Ghazalie    | M     | 53 years 1 mon 30 days</font>
<font size="1" style="font-size: 8pt">Sales              |   37701 | Hauke Zhang       | M     | 61 years 6 mons 10 days</font>
<font size="1" style="font-size: 8pt">Customer Service   |   17569 | Yuchang Weedman   | M     | 56 years 6 mons 1 day</font>
<font size="1" style="font-size: 8pt">Research           |   15441 | Hilary Kambil     | F     | 64 years 2 mons 29 days</font>
<font size="1" style="font-size: 8pt">Marketing          |   14842 | Vishwani Minakawa | M     | 53 years 3 mons 5 days</font>
<font size="1" style="font-size: 8pt">Quality Management |   14546 | Dung Pesch        | M     | 56 years 1 mon 7 days</font>
<font size="1" style="font-size: 8pt">Human Resources    |   12898 | Karsten Sigstam   | F     | 57 years 9 mons 24 days Finance            |   12437 | Isamu Legleitner  | F     | 59 years 5 mons 29 days</font></pre><h3 class="western">
<a name="__RefHeading___Toc23709_3962996256"></a>VIEWS med Oracle</h3>
<p class="western">Med Oracle blir SQL-setningen som danner
grunnlaget for Viewet litt annerledes:</p>
<pre class="western">CREATE VIEW avdelingsoversikt AS
SELECT 
   d.dept_name AS Avdeling,
   COUNT(de.emp_no) AS Ansatte,
   e.first_name || <b>' ' </b><span style="font-weight: normal">|| </span>e.last_name AS Leder,
   e.gender AS &quot;Kj&oslash;nn&quot;,
   trunc((to_number(to_char(sysdate,'YYYYMMDD'))-              to_number(to_char(birth_date,'YYYYMMDD')))/10000) AS Alder
FROM
   departments d, employees e, dept_manager dm, dept_emp de
WHERE
   d.dept_no = dm.dept_no
   AND e.emp_no = dm.emp_no
   AND de.dept_no = d.dept_no
   AND extract(year from dm.to_date) = 9999
   AND extract(year from de.to_date) = 9999
GROUP BY d.dept_name, e.first_name || <b>' ' </b><span style="font-weight: normal">|| </span>e.last_name, e.gender, birth_date
ORDER BY Ansatte DESC;</pre><p class="merk">
<b>MERK: </b><span style="font-weight: normal">For &aring; beregne
alder fra f&oslash;dselsdato kan vi bruke denne konstruksjonen med
Oracle (anbefalt ev Oracles &laquo;Tom&raquo;:
</span><b>to_number(to_char(birth_date,'YYYYMMDD')))/10000). </b><span style="font-weight: normal">Legg
ogs&aring; merke til at vi m&aring; gruppere p&aring; det samme
uttrykket vi bruker for &aring; sl&aring; sammen fornavn og etternavn
til &eacute;n kolonne.</span></p>
<p class="western">Vi kan n&aring; s&oslash;ke i viewet som i en
regul&aelig;r tabell:</p>
<pre class="western">SELECT * from avdelingsoversikt;

AVDELING                ANSATTE LEDER             Kj      ALDER
-------------------- ---------- ----------------- -- ----------
Development               61386 Leon DasSarma     F          54
Production                53304 Oscar Ghazalie    M          54
Sales                     37701 Hauke Zhang       M          63
Customer Service          17569 Yuchang Weedman   M          58
Research                  15441 Hilary Kambil     F          65
Marketing                 14842 Vishwani Minakawa M          55
Quality Management        14546 Dung Pesch        M          57
Human Resources           12898 Karsten Sigstam   F          59
Finance                   12437 Isamu Legleitner  F          61</pre><h3 class="western">
<a name="__RefHeading___Toc26001_2626130113"></a>Views med MS SQL
Server 
</h3>
<p class="western">Vi kan opprette views i SQL Server p&aring; samme
m&aring;te som for de andre RDBMSene, men syntaksen for SQL-setningen
m&aring; v&aelig;re gyldig T-SQL, som f.eks. denne:</p>
<pre class="western">CREATE VIEW avdelingsoversikt AS
SELECT 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.dept_name AS Avdeling,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COUNT(de.emp_no) AS Ansatte,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONCAT(e.first_name, ' ', e.last_name) AS Leder,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.gender AS Kj&oslash;nn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DATEDIFF(YEAR,e.birth_date,GETDATE()) AS Alder
&nbsp;&nbsp;&nbsp; FROM
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;departments AS d, employees AS e, dept_manager AS dm, dept_emp AS de
&nbsp;&nbsp;&nbsp; WHERE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.dept_no = dm.dept_no
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND e.emp_no = dm.emp_no
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND de.dept_no = d.dept_no
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND YEAR(dm.to_date) = 9999
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND YEAR(de.to_date) = 9999
&nbsp;&nbsp;&nbsp; GROUP BY d.dept_name, CONCAT(e.first_name,' ',e.last_name), e.gender, e.birth_date;</pre><p class="western">
Vi kan vise innholdet i view'et med en enkel select-setning:</p>
<pre class="western"><strong>SELECT * FROM Avdelingsoversikt;</strong>

<font size="1" style="font-size: 6pt">Avdeling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ansatte&nbsp;&nbsp;&nbsp;&nbsp; Leder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Kj&oslash;nn Alder</font>
<font size="1" style="font-size: 6pt">---------------------------------------- ----------- ------------------------------- ----- -----------</font>
<font size="1" style="font-size: 6pt">Customer Service&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 17569&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yuchang Weedman&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M&nbsp;&nbsp;&nbsp;&nbsp; 59</font>
<font size="1" style="font-size: 6pt">Development&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 61386&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leon DasSarma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F&nbsp;&nbsp;&nbsp;&nbsp; 55</font>
<font size="1" style="font-size: 6pt">Finance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12437&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Isamu Legleitner&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F&nbsp;&nbsp;&nbsp;&nbsp; 62</font>
<font size="1" style="font-size: 6pt">Human Resources&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12898&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Karsten Sigstam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F&nbsp;&nbsp;&nbsp;&nbsp; 61</font>
<font size="1" style="font-size: 6pt">Marketing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14842&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vishwani Minakawa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M&nbsp;&nbsp;&nbsp;&nbsp; 56</font>
<font size="1" style="font-size: 6pt">Production&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 53304&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Oscar Ghazalie&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M&nbsp;&nbsp;&nbsp;&nbsp; 56</font>
<font size="1" style="font-size: 6pt">Quality Management&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14546&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dung Pesch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M&nbsp;&nbsp;&nbsp;&nbsp; 59</font>
<font size="1" style="font-size: 6pt">Research&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15441&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hilary Kambil&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F&nbsp;&nbsp;&nbsp;&nbsp; 67</font>
<font size="1" style="font-size: 6pt">Sales&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 37701&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hauke Zhang&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M&nbsp;&nbsp;&nbsp;&nbsp; 64</font></pre><p class="western">
<br/>
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc4455_762629072"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Hvordan vise alle views i en database</h2>
<h3 class="western"><a name="__RefHeading___Toc4457_762629072"></a><strong><span style="font-weight: normal">MySQL
/ MariaDB</span></strong></h3>
<p class="western">Denne setningen vil vise alle views i en database:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">SHOW FULL TABLES WHERE TABLE_TYPE LIKE 'VIEW';</span></strong></pre><p class="western">
Og denne setningen viser alle tabeller med indikasjon p&aring; om de
er tabeller eller views:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">SHOW FULL TABLES;</span></strong><b> </b></pre><h3 class="western">
<a name="__RefHeading___Toc4459_762629072"></a><strong><span style="font-weight: normal">Oracle</span></strong></h3>
<p class="western">Denne setningen viser alle views brukeren har
tilgang til:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">SELECT</span></strong><strong><span style="font-weight: normal"> view_name </span></strong><strong><span style="font-weight: normal">FROM</span></strong><strong><span style="font-weight: normal"> all_views</span></strong></pre><p class="western">
Og denne setningen viser brukerens egne views:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">SELECT</span></strong><strong><span style="font-weight: normal"> view_name </span></strong><strong><span style="font-weight: normal">FROM</span></strong><strong><span style="font-weight: normal"> user_views</span></strong></pre><h3 class="western">
<a name="__RefHeading___Toc4461_762629072"></a>PostgreSQL</h3>
<p class="western">Med PostgreSQL kan man vise alle views i en
database med komandoen <strong>\dv (describe views)</strong>, slik:</p>
<pre class="western"><strong>\dv</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List of relations
&nbsp;Schema |&nbsp;&nbsp;&nbsp; Name&nbsp;&nbsp;&nbsp;        | Type | Owner 
--------+-------------------+------+-------
&nbsp;public | avdelingsoversikt | view | kurs</pre><p class="western">
Et par relativt nye funksjoner i terminalklienten til PostgreSQL er
at man kan vise hvilken opprinnelig SQL-setning et view er basert p&aring;,
og man kan ogs&aring; redigere et view direkte fra terminalklienten.
For &aring; vise et view bruker man kommandoen <b>\sv</b>  (kort for
<b>s</b>how <b>v</b>iew) etterfulgt av navnet til viewet man vil
vise, f.eks. slik:</p>
<pre class="western">\sv avdelingsoversikt &nbsp;<br/>

CREATE OR REPLACE VIEW public.avdelingsoversikt AS <br/>
SELECT d.dept_name AS avdeling, <br/>
&nbsp;&nbsp;&nbsp;concat(e.first_name, ' ', e.last_name) AS leder, <br/>
&nbsp;&nbsp;&nbsp;e.gender AS &quot;kj&oslash;nn&quot;, <br/>
&nbsp;&nbsp;&nbsp;age(e.birth_date) AS alder, <br/>
&nbsp;&nbsp;&nbsp;round(avg(s.salary)) AS &quot;snittl&oslash;nn&quot;, <br/>
&nbsp;&nbsp;&nbsp;sum(s.salary) AS &quot;l&oslash;nnskostnad&quot;, <br/>
&nbsp;&nbsp;&nbsp;count(*) AS ansatte <br/>
&nbsp;&nbsp;FROM departments d <br/>
&nbsp;&nbsp;&nbsp;&nbsp;JOIN dept_emp de ON d.dept_no::text = de.dept_no::text <br/>
&nbsp;&nbsp;&nbsp;&nbsp;JOIN salaries s ON s.emp_no = de.emp_no <br/>
&nbsp;&nbsp;&nbsp;&nbsp;JOIN dept_manager dm ON dm.dept_no::text = d.dept_no::text <br/>
&nbsp;&nbsp;&nbsp;&nbsp;JOIN employees e ON e.emp_no = dm.emp_no <br/>
&nbsp;WHERE date_part('year'::text, s.to_date) = 9999::double precision AND date_part('year'::text, de.to_date) = 9999::double precision A<br/>
ND date_part('year'::text, dm.to_date) = 9999::double precision <br/>
&nbsp;GROUP BY d.dept_name, (concat(e.first_name, ' ', e.last_name)), e.gender, (age(e.birth_date)) <br/>
&nbsp;ORDER BY d.dept_name</pre><p class="western">
Man kan ogs&aring; redigere et view med kommandoen <b>\ev</b><span style="font-weight: normal">,
</span><span style="font-weight: normal">f.eks slik:</span> 
</p>
<pre class="western">\ev avdelingsoversikt</pre><h3 class="western">
<a name="__RefHeading___Toc26003_2626130113"></a>MS SQL Server</h3>
<p class="western">Vis alle views i databasen:</p>
<pre class="western"><a name="yui_3_17_2_1_1557126075174_119"></a><strong>SELECT name from sys.views;</strong>

name&nbsp; 
----------------------------------------------------------------
avdelingsoversikt</pre><p class="western">
<br/>
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc23711_3962996256"></a><strong><font color="#1b75bc">&#61609;
</font></strong>Materialized Views</h2>
<p class="western">En ulempe med views er at det tar like lang tid &aring;
s&oslash;ke i dem som i den opprinnelige SQL-setningen viewet er
laget p&aring; grunnlag av. En annen tiln&aelig;rming er &aring; lage
en tabell med sumtall istedenfor et view (med CREATE TABLE AS eller
SELECT * INTO ... istedenfor CREATE VIEW AS ...), men da blir data
statiske og reflekterer ikke endringer i de underliggende tabellene.
S&aring; behovet for en l&oslash;sning som gir rimelig oppdaterte
data og er rask &aring; s&oslash;ke i f&oslash;rte til at man laget
et system for &aring; lage sumtabeller som kan &laquo;refreshes&raquo;
med jevne mellomrum &ndash; og det er akkurat det Materialized Views
er.  
</p>
<h3 class="western"><a name="__RefHeading___Toc23713_3962996256"></a>For
Oracle, PostgreSQL, MS SQL Server og MySQL/MariaDB</h3>
<p class="western">For RDBMSer som har st&oslash;tte for det kan
materialized view opprettes med denne syntaksen:</p>
<pre class="western">CREATE MATERIALIZED VIEW &lt;navn&gt; AS &lt;SELECT&ndash;setning &gt;;</pre><p class="western">
N&aring;r den er lagret, vil et Materialized View oppf&oslash;re seg
som en statisk tabell, men den kan hente inn oppdaterte data fra
underliggende tabeller med denne syntaksen:</p>
<pre class="western">REFRESH MATERIALIZED VIEW &lt;navn&gt;;</pre><p class="western">
<br/>
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc23715_3962996256"></a><strong><font color="#1b75bc">&#61609;
</font></strong>Ulike typer Materialized Views</h2>
<p class="western"><b>Oracle</b> skiller mellom disse variantene av
Materialized Views:</p>
<ol>
	<li><p class="western">Read-Only &ndash; Materialized Views som man
	ikke kan skrive til, kan kun brukes med SELECT 
	</p>
	<li><p class="western">Updatable -  Materialized Views som kan
	brukes med INSERT/UPDATE/DELETE, og hvor endringene kan oppdatere de
	underliggende tabellene. 
	</p>
	<li><p class="western">Writeable &ndash; Materialized Views som kan
	brukes med INSERT/UPDATE/DELETE, men endringene tilbakef&oslash;res
	ikke til de underliggende tabellene &ndash; det er kun dataene i
	viewet som endres. 
	</p>
</ol>
<p class="western">Hvilken type materialized view man vil lage, angis
ved opprettelsen. Vil man lage et Updatable eller Writable view legge
man til n&oslash;kkelordene FOR UPDATE, slik:</p>
<ol start="3">
	<pre class="western">CREATE MATERIALIZED VIEW &lt;navn&gt; <b>FOR UPDATE</b> AS
<a name="51136"></a>  SELECT &lt;...&gt; ;</pre>
</ol>
<p class="western">For at viewet skal v&aelig;re Writable er dette
nok, men skal det i tillegg v&aelig;re Updatable m&aring; viewet v&aelig;re
medlem av en <i><b>materialized view group. </b></i><span style="font-style: normal"><span style="font-weight: normal">Dette
har med replikering &aring; gj&oslash;re og ligger utenfor denne
bokens omr&aring;de, men Oracle har god dokumentasjon p&aring; hva
dette inneb&aelig;rer og hvordan det gj&oslash;res.</span></span></p>
<p class="western" style="font-style: normal; font-weight: normal"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc23717_3962996256"></a>
<font size="6" style="font-size: 24pt">Kapittel </font><font size="6" style="font-size: 24pt">1</font><font size="6" style="font-size: 24pt">1</font><font size="6" style="font-size: 24pt"><br/>
</font><font size="6" style="font-size: 24pt">Common
Table Ex</font><font size="6" style="font-size: 24pt">p</font><font size="6" style="font-size: 24pt">ressions
(CTE)</font></h1>
<p class="western">Common Table Expressions, gjerne forkortet til
CTEs er en egen m&aring;te &aring; skrive SQL-setninger p&aring; som
ogs&aring; blir kalt WITH-setninger, siden id&eacute;en er &aring;
starte setningen med WITH etterfulgt av en SQL-setning som man s&aring;
gir et alias og kan bruke senere i setningen. 
</p>
<h2 class="western"><a name="__RefHeading___Toc23719_3962996256"></a><strong><font color="#1b75bc">&#61609;
</font></strong>CTE med PostgreSQL 
</h2>
<p class="western">PostgreSQL har st&oslash;tte for CTEs med SELECT,
DELETE, UPDATE og INSERT. Her er noen eksempler hvor vi kan se nytten
av disse.</p>
<h3 class="western"><a name="__RefHeading___Toc23721_3962996256"></a>Eksempel
1: CTE med SELECT</h3>
<p class="western">I eksemplet under oppretter vi en tabell &laquo;ansatte&raquo;
med et l&oslash;penummer - &laquo;id&raquo; - som prim&aelig;rn&oslash;kkel,
samt feltene &laquo;fornavn&raquo;, &laquo;etternavn&raquo; og &laquo;lonn&raquo;
(for &aring; unng&aring; en &oslash; i feltnavnet &ndash; for
sikkerhets skyld) og feltet &laquo;leder_id&raquo;, som vil v&aelig;re
id&rsquo;en til den som er vedkommendes leder. S&aring; setter vi inn
noen rader i tabellen, noe som i PostgreSQL kan gj&oslash;res med
samme INSERT INTO-setning ved &aring; sette komma mellom
VALUE-parentesene. 
</p>
<pre class="western">create table ansatte (
id int primary key generated by default as identity,
fornavn text, etternavn text, lonn int, leder_id int 	
);

insert into ansatte (fornavn,etternavn,lonn,leder_id) values 
('Jo','Li',450000,null),
('Lykke','Li',570000,1),
('Hans','Jensen',460000,1),
('Olga','Lifjell',670000,1),
('Ola','Hansen',435000,8),
('Lise','Nielsen',360000,8),
('Henrik','Abel',840000,3),
('Petter','Olsen',1280000,null);</pre><p class="western">
Vi vil gjerne hente ut en tabell som viser navnet p&aring; de
ansatte, navnet p&aring; lederen deres og for de som er ledere: hvor
mange ansatte de har under seg (alt unders&aring;tter i sp&oslash;rringen
under). Vi kan bruke en CTE til &aring; gj&oslash;re dette i &eacute;n
setning, slik: 
</p>
<pre class="western"><b>WITH</b><b> leder</b> AS 

(SELECT a.leder_id AS leder_id, a.id AS id, a.fornavn || ' ' || a.etternavn AS ansatt, l.fornavn || ' ' || l.etternavn AS leder 
FROM ansatte a LEFT OUTER JOIN ansatte l ON a.leder_id = l.id) 

<b>SELECT ansatt, leder, (SELECT count(*) FROM ansatte WHERE leder_id = leder.id) AS unders&aring;tter </b>

<b>FROM leder</b>

<b>ORDER BY leder, ansatt;</b>


&nbsp;&nbsp;&nbsp;ansatt &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;leder &nbsp;&nbsp;&nbsp;&nbsp;| unders&aring;tter &nbsp;<br/>
-------------+--------------+------------- <br/>
Henrik Abel &nbsp;| Hans Jensen &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 <br/>
Hans Jensen &nbsp;| Jo Li &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 <br/>
Lykke Li &nbsp;&nbsp;&nbsp;&nbsp;| Jo Li &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 <br/>
Olga Lifjell | Jo Li &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 <br/>
Lise Nielsen | Petter Olsen | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 <br/>
Ola Hansen &nbsp;&nbsp;| Petter Olsen | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 <br/>
Jo Li &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 <br/>
Petter Olsen | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br/>
<br/>
(8 rows)</pre><h3 class="western">
<a name="__RefHeading___Toc23723_3962996256"></a>Eksempel 2: CTE med
DELETE</h3>
<p class="western">For &aring; lage et eksempel p&aring; en CTE med
DELETE, oppretter vi en tabell til, &laquo;ansatte2&raquo; som en
kopi av ansatte, men uten data (siden betingelsen 1=2 alltid er
falsk).  
</p>
<p class="western">Oppgaven v&aring;r er &aring; flytte ansatte med
l&oslash;nn over 500 000 fra &laquo;ansatte&raquo; til &laquo;ansatte2&raquo;.
Vi kan l&oslash;se dette enkelt med en CTE, som f&oslash;rst sletter
radene i &laquo;ansatte&raquo;, tar vare p&aring; resultatet i en
midlertidig tabell  - &laquo;flyttede&raquo; - og lagrer disse i
tabellen &laquo;ansatte2&raquo;. Slik ser dette ut i gyldig SQL-kode:</p>
<pre class="western">create table ansatte2 as select * from ansatte where 1=2;</pre><p class="western">
<br/>
<br/>

</p>
<p class="western">Her er en CTE-setning som f&oslash;rst sletter
ansatte med l&oslash;nn over 500 000, tar vare p&aring; resultatet og
setter disse inn i tabellen ansatte2:</p>
<pre class="western">
<b>WITH flyttede AS (</b>
   <b>DELETE FROM ansatte</b>
   <b>WHERE</b>
      <b>lonn &gt; 500000</b>
   <b>RETURNING *</b>
<b>)</b>
<b>INSERT INTO ansatte2 (SELECT * FROM flyttede);</b>
</pre><p class="western">
S&aring; kan vi sjekke at dette har g&aring;tt bra med en <b>select *</b>
fra de to tabellene:</p>
<pre class="western">
<b>select * from ansatte;</b>

id | fornavn | etternavn | &nbsp;lonn &nbsp;| leder_id &nbsp;<br/>
----+---------+-----------+--------+---------- <br/>
&nbsp;1 | Jo &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Li &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 450000 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;3 | Hans &nbsp;&nbsp;&nbsp;| Jensen &nbsp;&nbsp;&nbsp;| 460000 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 <br/>
&nbsp;5 | Ola &nbsp;&nbsp;&nbsp;&nbsp;| Hansen &nbsp;&nbsp;&nbsp;| 435000 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 <br/>
&nbsp;6 | Lise &nbsp;&nbsp;&nbsp;| Nielsen &nbsp;&nbsp;| 360000 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 <br/>
(4 rows)<br/>
<font face="monospace"><br/>
</font>
<b>select * from ansatte2;</b>

id | fornavn | etternavn | &nbsp;lonn &nbsp;&nbsp;| leder_id &nbsp;<br/>
----+---------+-----------+---------+---------- <br/>
&nbsp;2 | Lykke &nbsp;&nbsp;| Li &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;570000 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 <br/>
&nbsp;4 | Olga &nbsp;&nbsp;&nbsp;| Lifjell &nbsp;&nbsp;| &nbsp;670000 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 <br/>
&nbsp;7 | Henrik &nbsp;| Abel &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;840000 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 <br/>
&nbsp;8 | Petter &nbsp;| Olsen &nbsp;&nbsp;&nbsp;&nbsp;| 1280000 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
(4 rows)<br/>
</pre><p class="western">
Som vi ser er ansatte med l&oslash;nn over 500 000 flyttet til
tabellen ansatte2. 
</p>
<p class="merk"><b>MERK: </b>PostgreSQL bruker n&oslash;kkelordet
<b>RETURN</b> til &aring; gi oss en tabell med de radene vi har
slettet &ndash; og <b>RETURN *</b> angir at vi vil ha alle. RETURN
kan ogs&aring; brukes med UPDATE og INSERT. 
</p>
<h3 class="western"><a name="__RefHeading___Toc26740_1534934292"></a>Eksempel
3: CTE med Undersp&oslash;rring</h3>
<p class="western">I dette eksemplet bruker vi en C<font size="2" style="font-size: 10pt">TE
for &aring; lage en SQL-setning som teller opp antall ansatte som har
byttet tittel. Vi lister f&oslash;rst opp disse med en undersp&oslash;rring,
og teller dem s&aring; med en count(*). Slik kan dette se ut:</font></p>
<pre class="western">WITH ansatte_som_har_byttet_tittel as 
(select emp_no, count(*) from titles group by emp_no having count(*)&gt;1) 
SELECT count(*) as &quot;Byttet tittel&quot; from ansatte_som_har_byttet_tittel;  

Byttet tittel 
---------------
        140270</pre><h2 class="western">
<a name="__RefHeading___Toc25488_2464819632"></a><strong><font color="#1b75bc">&#61609;
</font></strong>CTE med MS SQL Server</h2>
<p class="western">Microsoft SQL-server har st&oslash;tte for to
typer av Common Table Expressions: rekursive og ikke-rekursive CTE.
Her er noen av reglene for bruk av CTE med SQL Server</p>
<ul>
	<li><p class="western">En CTE m&aring; etterf&oslash;lges av en
	enkelt <code class="western">SELECT</code>, <code class="western">INSERT</code>,
	<code class="western">UPDATE</code>, eller <code class="western">DELETE</code>
	-setning som refererer til noen eller alle feltene som er definert
	av CTEen. Man kan ogs&aring; bruke en  CTE n&aring;r man lager et
	VIEW med  <code class="western">CREATE VIEW</code>.</p>
</ul>
<ul>
	<li><p class="western">En CTE kan referere til seg selv og tidligere
	definerte CTE i den samme <code class="western"><font face="Liberation Serif, serif">WITH-</font></code><code class="western"><font face="Liberation Serif, serif">setningen</font></code>.
	Men ikke til p&aring;f&oslash;lgende definerte CTE .</p>
	<li><p class="western">Man kan bare ha &eacute;n WITH-setning med en
	CTE.</p>
	<li><p class="western">Disse n&oslash;kkelordene kan <b>ikke</b>
	brukes n&aring;r man definerer en  <em><span style="font-style: normal">CTE</span></em>:</p>
	<ul>
		<li><p class="western"><code class="western">ORDER BY</code>
		(bortsett fra sammen med <code class="western">TOP</code>)</p>
		<li><p class="western"><code class="western">INTO</code></p>
		<li><p class="western"><code class="western">OPTION</code> 
		</p>
		<li><p class="western"><code class="western">FOR BROWSE</code></p>
	</ul>
	<li><p class="western">Tabeller p&aring; eksterne servere kan brukes
	i en CTE.</p>
</ul>
<h3 class="western"><a name="__RefHeading___Toc25490_2464819632"></a>Eksempel
1: Rekursiv CTE 
</h3>
<p class="western">Dette eksemplet er identisk med Eksempel 1 for
PostgreSQL, og fungerer helt likt med SQL Server hvis vi gj&oslash;r
om datatypene fra text til nvarchar, fjerner <i><span style="font-weight: normal">generated
by default as</span></i> n&aring;r vi lager prim&aelig;rn&oslash;kkelen,
og endrer sammenskj&oslash;tings-tegnet for navn fra | til +.</p>
<pre class="western">CREATE TABLE ansatte (
id int primary key identity,
fornavn NVARCHAR(10), 
etternavn NVARCHAR(10), 
lonn int, 
leder_id int
);

INSERT INTO ansatte
(fornavn,etternavn,lonn,leder_id)
VALUES
('Jo', 'Li', 450000, null),
('Lykke', 'Li', 570000, 1),
('Hans', 'Jensen', 460000, 1),
('Olga', 'Lifjell', 670000, 1),
('Ola', 'Hansen', 435000, 8),
('Lise', 'Nielsen', 360000, 8),
('Henrik', 'Abel', 840000, 3),
('Petter', 'Olsen', 1280000, null);

WITH leder AS
(
SELECT a.leder_id AS leder_id, a.id AS id, a.fornavn + ' ' + a.etternavn AS ansatt, l.fornavn + ' ' + l.etternavn AS leder
FROM ansatte a LEFT OUTER JOIN ansatte l ON a.leder_id = l.id
)
SELECT ansatt, leder, 
(SELECT count(*) FROM ansatte
WHERE leder_id = leder.id) AS unders&aring;tter
FROM leder
ORDER BY leder, ansatt;

GO

ansatt                leder                 unders&aring;tter
--------------------- --------------------- -----------
Jo Li                 NULL                            3
Petter Olsen          NULL                            2
Henrik Abel           Hans Jensen                     0
Hans Jensen           Jo Li                           1
Lykke Li              Jo Li                           0
Olga Lifjell          Jo Li                           0
Lise Nielsen          Petter Olsen                    0
Ola Hansen            Petter Olsen                    0</pre><h3 class="western">
<a name="__RefHeading___Toc25763_1131955894"></a>Eksempel 2: DELETE
uten CTE</h3>
<p class="western">Med SQL Server ville vi ikke brukt en CTE til &aring;
flytte rader fra en tabell til en annen. Men vi kunne gjort dette
enkelt med kombinasjonen av n&oslash;kkelordene DELETE, OTPUT og
INTO. Ved bruk av OUTPUT  returneres nemlig de kolonnene vi angir fra
de slettede radene i en midlertidig tabell med navnet: <b>deleted. </b>
Slik gj&oslash;res dette i praksis:</p>
<pre class="western"><code class="western"><b>DELETE</b></code><code class="western"> FROM ansatte </code><code class="western"><b>OUTPUT</b></code><code class="western"> deleted.fornavn, deleted.etternavn, deleted.lonn, deleted.leder_id </code><code class="western"><b>INTO</b></code><code class="western"> ansatte2 </code>
WHERE lonn &gt; 500000;<code class="western"> </code></pre><p class="western">
<br/>
<br/>

</p>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc18250_1557834486"></a>
<font size="6" style="font-size: 24pt">Kapittel </font><font size="6" style="font-size: 24pt">1</font><font size="6" style="font-size: 24pt">2</font><font size="6" style="font-size: 24pt"><br/>
</font>Indekser</h1>
<p class="western">En indeks er en spesiell form for <b>sortert kopi</b>
av et felt i en tabell, eller av en kombinasjon av felter i en
tabell. Uten indekser m&aring; databasen g&aring; igjennom alle
radene i en tabell hver gang vi s&oslash;ker etter noe &ndash; den m&aring;
gj&oslash;re en s&aring;kalt &laquo;full table scan&raquo;. S&oslash;ker
vi f.eks. etter en person med etternavn &laquo;Olsen&raquo; m&aring;
etternavn-feltet i alle radene i tabellen sjekkes, for etternavnet
Olsen kan opptre i hvilken som helst rad.  Ved &aring; opprette en
indeks p&aring; felt det s&oslash;kes mye p&aring; ( som f.eks.
&laquo;etternavn&raquo;) sparer vi databasen for mye arbeid &ndash;
siden den kan sjekke en sortert versjon av feltet og dermed g&aring;
rett til bokstaven <b>O</b>, s&aring; rett til bokstaven <b>l, </b><span style="font-weight: normal">osv.
Og dermed kan vi begrense antall rader systemet m&aring; bla igjennom
til et minimum.  </span> 
</p>
<h2 class="western"><a name="__RefHeading___Toc13957_140935937"></a><strong><font color="#1b75bc">&#61609;</font></strong>
N&aring;r b&oslash;r vi bruke indekser?</h2>
<p class="western"><a name="yui_3_17_2_1_1474496678923_78"></a>Indekser
effektiviserer s&oslash;k, men ineffektiviserer lagring, siden felt
som er indekserte m&aring; re-indekseres hver gang data legges til,
oppdateres eller slettes. S&aring; indeksering b&oslash;r brukes med
forsiktighet p&aring; tabeller som det skrives mye til. Det kan
indekseres p&aring; enkeltfelt og kombinasjoner av felt, p&aring;
felt som hentes frem med funksjoner, geografiske felttyper osv., og
det finnes ulike typer indekser som er effektive for ulike typer av
s&oslash;k. Optimal bruk av indekser er p&aring; mange m&aring;ter
mer en kunstart enn en vitenskap, og det kan v&aelig;re smart &aring;
sjekke databasens bruksm&oslash;nstre med jevne mellomrom, og
eventuelt endre indekseringen etter de mest brukte s&oslash;kem&oslash;nstrene.
</p>
<p class="western">N&aring;r man bygger en ny database, kan man i
testfasen bruke metoden enkelte gartnere bruker n&aring;r de skal
anlegge en park med gress og heller der folk skal g&aring;. Metoden
best&aring;r i &aring; legge en gressplen og s&aring; vente noen uker
til man ser stiene der hvor hvor folk g&aring;r, og s&aring; legge
heller der. S&aring; slipper man &aring; ha fine stier med heller som
ingen bruker, mens folk har tr&aring;kket seg gjennom rosebuskene for
&aring; komme raskest dit de vil. Overf&oslash;rt til databaseverden
kan man lanserer test-versjonen av databasen uten indekser, og ved &aring;
sjekke logger osv. kan man se hvilke felt det s&oslash;kes p&aring;,
om det brukes kombinasjoner av felt, jokertegn eller ikke osv., og s&aring;
opprette indekser i henhold til den faktiske bruken. 
</p>
<h2 class="western"><a name="__RefHeading___Toc14214_2514959757"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Ulike typer indekser</h2>
<p class="western">De forskjellige RDBMSene har ulike typer indekser
til ulike form&aring;l: B-Tree, Hash, Brin, Gin og Gist er noen av de
mest brukte.</p>
<h3 class="western"><a name="__RefHeading___Toc14216_2514959757"></a>B-Tree
</h3>
<p class="western">Den aller vanligste typen er en s&aring;kalt
<b>B-Tree</b> indeks, som er den som opprettes som default b&aring;de
med MySQL/MariaDB, PostgreSQL, Oracle og MS SQL Server. Kort fortalt
lager denne indekstypen en sortert trestruktur som brukes til &aring;
sammenlikne et felt med et s&oslash;k til resultatet er funnet.
Istedenfor &aring; s&oslash;ke gjennom 1 million rader for &aring;
sjekke om feltet inneholder s&oslash;keordet, kan man ved &aring;
bruke en indeks av typen B-Tree klare det samme ved ca. 20
sammenlikninger. Ulempene med en B-Tree indeks ligger bl.a. i at det
kan v&aelig;re tidkrevende &aring; sette inn mange nye rader, gj&oslash;re
mange og store oppdateringer og at hele indeksen m&aring; bygges p&aring;
nytt hvis man f.eks. &oslash;ker maksimumslengden p&aring; feltet.</p>
<h3 class="western"><a name="__RefHeading___Toc14220_2514959757"></a>GIN
-  Generalized Inverted Index</h3>
<p class="western">En indeks av typen GIN brukes av PostgreSQL til &aring;
h&aring;ndtere fulltekst-s&oslash;k og s&oslash;k som inneholder
jokertegn, som f.eks. WHERE last_name LIKE &rsquo;Mc%&rsquo; eller
WHERE last_name LIKE &rsquo;%sen&rsquo;, dvs alle etternavn som
begynner p&aring; <i>Mc </i>eller slutter p&aring; <i>sen</i>.  Slik
opprettes en GIN-index med PostgreSQL</p>
<pre class="western"><code class="western">CREATE INDEX </code><em>&lt;navn&gt;</em><code class="western"> ON </code><code class="western">&lt;tabellnavn&gt;</code><code class="western"> USING GIN (</code><em>&lt;kolonne&gt;</em><code class="western">);</code> </pre><p class="western">
Kolonnen indeksen opprettes p&aring; m&aring; v&aelig;re av
data-typen <b>tsvector</b>. GIN-indekser er de best egnede til
fulltekst-s&oslash;k, siden de inneholder en index-verdi for hvert
ord (lexem) med henvisning til matchende lokasjoner. 
</p>
<h3 class="western"><a name="__RefHeading___Toc24612_3325804077"></a>GIST
- Generalized Search Tree</h3>
<p class="western">GIST-indekser brukes ogs&aring; til fulltekst-s&oslash;k,
men det anbefales &aring; bruke GIN-indekser. GIST-indekser er
&laquo;lossy&raquo;, dvs. de kan produsere falske treff. Dette er
fordi de er basert p&aring; hash-verdier av ord, og to hash-verdier
kan i sjeldne tilfeller v&aelig;re like for ulike ord. Slik opprettes
en GIST-index med PostgreSQL</p>
<pre class="western"><code class="western">CREATE INDEX </code><em>&lt;navn&gt;</em><code class="western"> ON </code><code class="western">&lt;tabellnavn&gt;</code><code class="western"> USING GI</code><code class="western">ST</code><code class="western"> (</code><em>&lt;kolonne&gt;</em><code class="western">);</code> </pre><h3 class="western">
<a name="__RefHeading___Toc19111_2730267216"></a>Brin</h3>
<p class="western">To do ...</p>
<h3 class="western"><a name="__RefHeading___Toc19113_2730267216"></a>Hash</h3>
<p class="western">To do ...</p>
<h3 class="western"><a name="__RefHeading___Toc19115_2730267216"></a>Bit</h3>
<p class="western">To do ...</p>
<h2 class="western"><a name="__RefHeading___Toc13959_140935937"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Oppretting av indekser</h2>
<p class="western">En indeks (av den typen som er default, som regel
en BTREE-indeks) opprettes med setningen:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><b>CREATE INDEX</b></strong><strong><span style="font-weight: normal"> &lt;indeksnavn&gt; </span></strong><strong><b>ON</b></strong><strong><span style="font-weight: normal"> &lt;tabellnavn&gt; (&lt;feltnavn&gt;)</span></strong></pre><p class="western">
For eksempel slik:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">CREATE INDEX lastname_idx ON employees (last_name);</span></strong></pre><p class="western">
En god nyhet er at denne syntaksen er lik for de fleste DBMSer. 
</p>
<p class="western">Hver indeks m&aring; ha et unikt navn, selv om de
er indekser av ulik type. Hvor effektiv en indeks er avhenger av
bruken av databasen, s&aring; det l&oslash;nner seg &aring; sjekke
dette med jevne mellomrom slik at man kan endre indeksene etter
behov. Et ideelt sett med indekser kan vise seg &aring; v&aelig;re
mindre ideelt etter noen m&aring;neders datamanipulering.</p>
<p class="western">Man kan vise hvilke indekser som er opprettet for
en tabell med denne syntaksen i MySQL:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><b>SHOW INDEXES FROM</b></strong><strong><span style="font-weight: normal"> &lt;tabellnavn&gt;</span></strong></pre><p class="western">
Og man kan slette indekser med denne syntaksen:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><b>DROP INDEX</b></strong><strong><span style="font-weight: normal"> &lt;indexnavn&gt; ON &lt;tabellnavn&gt;</span></strong></pre><p class="western">
eller hvis man skal slette indeksen p&aring; en prim&aelig;rn&oslash;kkel:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><b>DROP INDEX</b></strong><strong><span style="font-weight: normal"> `PRIMARY` ON &lt;tabellnavn&gt;</span></strong></pre><p class="western">
siden indekser p&aring; prim&aelig;rn&oslash;kler alltid heter
&quot;primary&quot;.</p>
<h2 class="western"><a name="__RefHeading___Toc289_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Hvor effektiv er indeksen?</h2>
<h3 class="western"><a name="__RefHeading___Toc16238_413252541"></a>Med
MySQL / MariaDB</h3>
<p class="western">Du kan sjekke hvor mange rader databasen m&aring;
s&oslash;ke gjennom med og uten indeksering ved &aring; bruke
uttrykket <strong>EXPLAIN </strong>f&oslash;r SQL-setningen, f.eks.
slik:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong><span style="font-weight: normal">EXPLAIN SELECT * FROM employees <br/>
WHERE last_name = 'Facello' AND first_name = 'Georgi'</span></strong><span style="font-weight: normal">;</span></pre>
<table width="100%" cellpadding="2" cellspacing="1">
	<col width="8*"/>

	<col width="26*"/>

	<col width="30*"/>

	<col width="22*"/>

	<col width="35*"/>

	<col width="35*"/>

	<col width="18*"/>

	<col width="20*"/>

	<col width="15*"/>

	<col width="46*"/>

	<tr>
		<td width="3%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			<font size="2" style="font-size: 9pt">id</font></p>
		</td>
		<td width="10%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			<font size="2" style="font-size: 9pt">select_type</font></p>
		</td>
		<td width="12%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			<font size="2" style="font-size: 9pt">table</font></p>
		</td>
		<td width="9%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			<font size="2" style="font-size: 9pt">type</font></p>
		</td>
		<td width="14%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			<font size="2" style="font-size: 9pt">possible_keys</font></p>
		</td>
		<td width="14%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			<font size="2" style="font-size: 9pt">key</font></p>
		</td>
		<td width="7%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			<font size="2" style="font-size: 9pt">key_len</font></p>
		</td>
		<td width="8%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			<font size="2" style="font-size: 9pt">ref</font></p>
		</td>
		<td width="6%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			<font size="2" style="font-size: 9pt">rows</font></p>
		</td>
		<td width="18%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border: 1px double #808080; padding: 0.05cm"><p class="western">
			<font size="2" style="font-size: 9pt">Extra</font></p>
		</td>
	</tr>
	<tr valign="top">
		<td width="3%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western" style="font-weight: normal">
			<font size="2" style="font-size: 9pt">1</font></p>
		</td>
		<td width="10%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western" style="font-weight: normal">
			<font size="2" style="font-size: 9pt">SIMPLE</font></p>
		</td>
		<td width="12%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western" style="font-weight: normal">
			<font size="2" style="font-size: 9pt">employees</font></p>
		</td>
		<td width="9%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western" style="font-weight: normal">
			<font size="2" style="font-size: 9pt">index_merge</font></p>
		</td>
		<td width="14%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western" style="font-weight: normal">
			<font size="2" style="font-size: 9pt">firstname_idx,lastname_idx</font></p>
		</td>
		<td width="14%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western" style="font-weight: normal">
			<font size="2" style="font-size: 9pt">lastname_idx,firstname_idx</font></p>
		</td>
		<td width="7%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western" style="font-weight: normal">
			<font size="2" style="font-size: 9pt">18,16</font></p>
		</td>
		<td width="8%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western" style="font-weight: normal">
			<font size="2" style="font-size: 9pt">NULL</font></p>
		</td>
		<td width="6%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western" style="font-weight: normal">
			<font size="2" style="font-size: 9pt">1</font></p>
		</td>
		<td width="18%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 1px double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
			<font size="2" style="font-size: 9pt">Using
			intersect(lastname_idx,firstname_idx); Using where</font></p>
		</td>
	</tr>
</table>
<p class="western"><br/>
Vi ser at det er brukt to indekser:
<b>lastname_idx</b> og <b>firstname_idx</b> og at databasen kun
beh&oslash;vde &aring; lete i &eacute;n eneste rad for &aring; finne
resultatet.</p>
<p class="western">Uten indekser ser vi at antall rader er &oslash;kt
til 300252, mao. det m&aring; s&oslash;kes i alle radene i tabellen:</p>
<table width="100%" cellpadding="2" cellspacing="1">
	<col width="8*"/>

	<col width="33*"/>

	<col width="31*"/>

	<col width="16*"/>

	<col width="40*"/>

	<col width="21*"/>

	<col width="24*"/>

	<col width="21*"/>

	<col width="23*"/>

	<col width="38*"/>

	<tr>
		<td width="3%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			id</p>
		</td>
		<td width="13%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			select_type</p>
		</td>
		<td width="12%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			table</p>
		</td>
		<td width="6%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			type</p>
		</td>
		<td width="16%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			possible_keys</p>
		</td>
		<td width="8%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			key</p>
		</td>
		<td width="9%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			key_len</p>
		</td>
		<td width="8%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			ref</p>
		</td>
		<td width="9%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border-top: 1px double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			rows</p>
		</td>
		<td width="15%" bgcolor="#c0c0c0" style="background: #c0c0c0" style="border: 1px double #808080; padding: 0.05cm"><p class="western">
			Extra</p>
		</td>
	</tr>
	<tr valign="top">
		<td width="3%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			1</p>
		</td>
		<td width="13%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			SIMPLE</p>
		</td>
		<td width="12%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			employees</p>
		</td>
		<td width="6%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			ALL</p>
		</td>
		<td width="16%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			NULL</p>
		</td>
		<td width="8%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			NULL</p>
		</td>
		<td width="9%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			NULL</p>
		</td>
		<td width="8%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			NULL</p>
		</td>
		<td width="9%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p class="western">
			300252</p>
		</td>
		<td width="15%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 1px double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
			Using where</p>
		</td>
	</tr>
</table>
<p class="western"><br/>
<br/>

</p>
<h3 class="western"><br/>
<br/>

</h3>
<h3 class="western" style="page-break-before: always"><a name="__RefHeading___Toc18252_1557834486"></a>
Med MS SQL Server</h3>
<p class="western">Vi kan sjekke hvilke indekser som brukes i et s&oslash;k,
og hvor effektive de er ved &aring; la f.eks. Management Studio eller
Azure data Studio vise oss kj&oslash;replanen til s&oslash;ket. I
Management Studio kan vi f.eks. gj&oslash;re dette med kommandoen
&lt;ctrl&gt; + L og i Azure Data Studio kan vi klikke Explain (i r&oslash;d
ramme p&aring; bildet under til venstre). Som vi ser av bildet til
venstre er det tre operasjoner som m&aring; til for &aring; utf&oslash;re
s&oslash;ket. Holder vi musepekeren over boksen <i>Index Seek, </i><span style="font-style: normal">vises
detaljene i denne operasjonen &ndash;</span><span style="font-style: normal">
som vist i bildet til h&oslash;yre.</span></p>
<p class="western"><img src="Introduksjon_til_SQL_html_8aaa4b0dce0ce99c.png" name="Bilde3" align="left" width="344" height="290" border="0"/>
<img src="Introduksjon_til_SQL_html_8b4fc63211e7b4a0.png" name="Bilde4" align="left" width="416" height="291" border="0"/>
<br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western">Som vi ser av bildet til h&oslash;yre m&aring; SQL
Server lete i ca. 183,6 rader for &aring; finne de 186 ansatte med
etternavn Facello, og vil bruke indeksen: name_idx til &aring; finne
disse radene.</p>
<p class="western" style="font-style: normal"><br/>
<br/>

</p>
<p class="western" style="font-style: normal"><br/>
<br/>

</p>
<p class="western" style="font-style: normal"><br/>
<br/>

</p>
<p class="western" style="font-style: normal"><br/>
<br/>

</p>
<p class="western" style="font-style: normal"><br/>
<br/>

</p>
<p class="western" style="font-style: normal"><br/>
<br/>

</p>
<p class="western" style="font-style: normal"><br/>
<br/>

</p>
<p class="western" style="font-style: normal"><br/>
<br/>

</p>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc18256_1557834486"></a>
<font size="6" style="font-size: 24pt">Kapittel 1</font><font size="6" style="font-size: 24pt">3</font><font size="6" style="font-size: 24pt"><br/>
</font>Innsetting,
oppdatering og sletting av data</h1>
<h2 class="western"><a name="__RefHeading___Toc18258_1557834486"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Insetting av nye rader med INSERT INTO</h2>
<p class="western">Med<strong> INSERT</strong> <strong>INTO</strong>
kan vi sette inn nye, hele rader eller deler av rader. Det er flere
m&aring;ter &aring; gj&oslash;re dette p&aring;. Den anbefalte
syntaksen er INSERT INTO &lt;tabellnavn&gt; og s&aring; en parentes
hvor man lister opp de feltene som det skal settes inn verdier for,
etter fulgt av n&oslash;kkelordet VALUES og en ny parentes med
verdiene til de tilsvarende feltene i den f&oslash;rste parentesen :</p>
<pre class="western"><strong><span style="font-weight: normal">INSERT INTO &lt;tabellnavn&gt; (&lt;felttnavn1&gt;, &lt;feltnavn2&gt;,&lt;feltnavn3&gt; ...)</span></strong>
<strong><span style="font-weight: normal">VALUES (&lt;verdi1&gt;,&lt;verdi2&gt;,&lt;verdi3&gt;...);</span></strong></pre><p class="western">
For eksempel:</p>
<pre class="western" style="line-height: 140%"><strong><b>INSERT INTO</b></strong><strong><span style="font-weight: normal"> employees</span></strong>
<strong><span style="font-weight: normal">(emp_no, first_name, last_name, birth_date, gender, hire_date)</span></strong>
<strong><b>VALUES</b></strong><strong><span style="font-weight: normal"> ('500002','Ola','Pettersen','1980-05-05','M','2016-01-01');</span></strong></pre><p class="merk">
<strong>MERK:</strong> Med noen DBMSer er n&oslash;kkelordet <b>INTO</b>
valgfritt, men det anbefales &aring; ta den med likevel, slik at
koden blir mer portabel, dvs kan overf&oslash;res til andre databaser
senere.</p>
<p class="western" style="line-height: 140%">Husk at hvis
prim&aelig;rn&oslash;kkel er et <b>selv-&oslash;kende felt</b>
(feltegenskap <em>auto_increment</em> i MySQL/MariaDB,  datatype
<em>serial</em> i PostgreSQL eller som  <i>ident</i><i>ity</i> i MS
SQL Server og Oracle fra og med versjon 12c) s&aring; skal det
naturlig nok ikke settes inn noen verdi for dette feltet - DBMSen vil
legge til en verdi automatisk. Vi utelater det ganske enkelt fra
begge parentesene. I eksemplet over er prim&aelig;rn&oslash;kkelen
<em>emp_no</em> ikke selv-&oslash;kende, s&aring; vi m&aring; sette
inn verdien manuelt. Uten verdi for prim&aelig;rn&oslash;kkelen vil
du f&aring; en feilmelding, og den nye raden vil ikke bli lagret.</p>
<h2 class="western"><a name="__RefHeading___Toc4471_762629072"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Bruk av INSERT INTO uten feltnavn</h2>
<p class="western" style="line-height: 140%">Det er mulig &aring;
sl&oslash;yfe den f&oslash;rste parentesen med feltnavnene og kun
spesifisere verdiene, slik: 
</p>
<pre class="western"><strong><span style="font-weight: normal">INSERT INTO &lt;tabellnavn&gt; VALUES (verdi1, verdi2, ...)</span></strong></pre><p class="western" style="line-height: 140%">
Men <b>dette anbefales ikke</b>, siden det inneb&aelig;rer at man m&aring;
legge inn alle felt (uten evt. selv-&oslash;kende prim&aelig;rn&oslash;kler)
og de m&aring; legges inn i riktig rekkef&oslash;lge (og da m&aring;
man kjenne rekkef&oslash;lgen) og det er lett &aring; gj&oslash;re
feil. Samtidig blir koden mindre fleksibel - hvis man legger til et
felt i tabellen, kan man ikke bruke koden uten &aring; legge til en
verdi for dette feltet i SQL-setningen.</p>
<h3 class="western"><a name="__RefHeading___Toc4473_762629072"></a><strong><span style="font-weight: normal">MySQL
/ MariaDB</span></strong></h3>
<p class="western">Med MySQL/MariaDB kan du i tillegg velge &aring;
sette inn nye rader med <strong>INSERT INTO &lt;tabellnavn&gt; SET</strong>
og en syntaks som likner den man bruker for &aring; oppdatere rader.
Eksemplet ovenfor vil med denne syntaksen se slik ut:</p>
<pre class="western"><strong><b>INSERT INTO</b></strong><strong><span style="font-weight: normal"> employees </span></strong><strong><b>SET</b></strong><strong><span style="font-weight: normal"> </span></strong>
<strong><span style="font-weight: normal">emp_no = '500002', </span></strong>
<strong><span style="font-weight: normal">first_name = 'Ola', </span></strong>
<strong><span style="font-weight: normal">last_name = 'Pettersen', </span></strong>
<strong><span style="font-weight: normal">birth_date '1980-05-05', </span></strong>
<strong><span style="font-weight: normal">gender = 'M', </span></strong>
<strong><span style="font-weight: normal">hire_date = '2016-01-01';</span></strong></pre><p class="merk">
<strong>MERK:</strong> Noen synes denne syntaksen er ryddigere siden
feltnavn og feltverdi er direkte knyttet til hverandre gjennom
likhetstegnet. Det kan v&aelig;re verdt &aring; huske at denne
syntaksen kun gjelder for MySQL og MariaDB og hvis koden skal v&aelig;re
portabel kan det l&oslash;nne seg &aring; bruke den anbefalte
syntaksen med to parenteser, siden den kan brukes med alle DBMSene.</p>
<h2 class="western"><a name="__RefHeading___Toc357_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Oppdatere eksisterende rader med UPDATE</h2>
<p class="western">Med <strong>UPDATE</strong> kan vi oppdatere hele
eller deler av eksisterende rader. Syntaksen er denne, som <strong><span style="font-weight: normal">er
lik for alle RDBMSene</span></strong>:</p>
<pre class="western"><strong><b>UPDATE</b></strong><strong><span style="font-weight: normal"> &lt;tabellnavn&gt;</span></strong>
<strong><b>SET</b></strong><strong><span style="font-weight: normal"> &lt;feltnavn&gt; = &lt;ny verdi&gt;<br/>
</span></strong><strong><b>WHERE</b></strong><strong><span style="font-weight: normal"> &lt;feltnavn&gt; = &lt;verdi&gt;;&nbsp;</span></strong></pre><p class="western">
<br/>
<br/>

</p>
<p class="merk"><strong>MERK: WHERE-</strong>betingelsen er ekstremt
viktig her. Utelater vi den, vil vi oppdatere alle radene i tabellen
til &aring; f&aring; den verdien vi setter inn for dette feltet,
f.eks. kan det f&oslash;re til at alle f&aring;r samme terlefonnummer
eller epostadresse, n&aring;r det vi ville var &aring; oppdatere
dette for en person.</p>
<p class="western"><strong>Eksempeler:</strong></p>
<h3 class="western"><a name="__RefHeading___Toc4464_762629072"></a>MySQL
/ MariaDB</h3>
<pre class="western"><strong><span style="font-weight: normal">UPDATE salaries</span></strong>
<strong><span style="font-weight: normal">SET to_date = curdate()</span></strong>
<strong><span style="font-weight: normal">WHERE emp_no = 100001 and to_date = '9999-01-01';</span></strong></pre><p class="western">
Med denne setningen har vi oppdatert l&oslash;nnsdata for ansatt nr.
100001 slik at det som var dagens l&oslash;nn n&aring; er en l&oslash;nn&nbsp;
med sluttdato i dag. 
</p>
<p class="western">S&aring; kan vi sette inn en ny l&oslash;nnslinje&nbsp;
med ny l&oslash;nn fra dagens dato og til 1.1.9999 (som angir at
dette er gjeldende l&oslash;nn), slik:</p>
<pre class="western"><strong><span style="font-weight: normal">INSERT INTO salaries (emp_no, from_date, to_date, salary) </span></strong>
<strong><span style="font-weight: normal">VALUES (100001, curdate(), '9999-01-01',89673)</span></strong></pre><p class="western">
Med disse to setningene er l&oslash;nnsdata justert for den aktuelle
ansatte, og ingen andre, siden <strong>emp_no</strong> har en unik
verdi - det finnes bare en ansatte med emp_no 1000001.</p>
<p class="merk"><strong>MERK: </strong>Du kan ogs&aring; oppdatere
mer enn &eacute;n rad av gangen - ved &aring; sette en
WHERE-betingelse som s&oslash;ker opp flere rader, f.eks.<strong>
WHERE dept_no = 'd001' </strong>vil oppdatere alle ansatte som
tilh&oslash;rer denne avdelingen hvis en SQL-setning kj&oslash;res
mot dept_emp-tabellen<strong>.</strong></p>
<p class="western">Skal vi oppdatere flere kolonner, setter vi dem
etter hverandre med komma imellom, men bruker bare &eacute;n
SET-setning, slik:</p>
<pre class="western"><strong><span style="font-weight: normal">UPDATE employees</span></strong>
<strong><span style="font-weight: normal">SET birth_date = '1986-05-05',</span></strong>
<strong>    <span style="font-weight: normal">hire_date = '2009-01-01'</span></strong>
<strong><span style="font-weight: normal">WHERE emp_no = '10006';&nbsp;</span></strong></pre><p class="western">
Skal du <strong>slette verdien for et felt</strong> i en rad, kan du
gj&oslash;re dette ved &aring; bruke UPDATE og s&aring; sette verdien
til <b>NULL</b>, eller til <b>''</b> (to apostropher) eller <b>0</b>
hvis feltet ikke aksepterer NULL-verdier.</p>
<p class="merk"><strong>MERK:</strong> Du kan bruke <strong>undersp&oslash;rringer</strong>
til &aring; oppdatere en rad med input fra en annen rad i samme eller
en annen tabell i databasen. Noen DBMSer tillater ogs&aring; bruk av
ordet FROM for &aring; angi at man oppdaterer en rad med data fra
(FROM) en annen tabell. F.eks.</p>
<pre class="western"><strong><span style="font-weight: normal">UPDATE dept_emp</span></strong>
<strong><span style="font-weight: normal">SET dept_no = (SELECT dept_no </span></strong><strong><span style="font-weight: normal">FROM</span></strong><strong><span style="font-weight: normal"> departments WHERE dept_name = 'Development')</span></strong>
<strong><span style="font-weight: normal">WHERE dept_no = 'd002'</span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Setningen over oppdaterer
tabellen </span></strong><strong><i><span style="font-weight: normal">dept_emp</span></i></strong><strong><span style="font-weight: normal">
og endrer feltet </span></strong><strong><i><span style="font-weight: normal">dept_no</span></i></strong><strong><span style="font-weight: normal">
til det som returneres ved et oppslag i tabellen </span></strong><strong><i><span style="font-weight: normal">departments
</span></i></strong><strong><span style="font-style: normal"><span style="font-weight: normal">p&aring;
dept_name  = &rsquo;Development&rsquo; - men kun for raden som har
dept_no = &rsquo;d002&rsquo; fra f&oslash;r. Med andre ord, dersom
avdelingen Development har byttet avdelingsnummer i tabellen
</span></span></strong><strong><i><span style="font-weight: normal">departments</span></i></strong><strong><span style="font-style: normal"><span style="font-weight: normal">,
blir dette n&aring; oppdatert i tabellen </span></span></strong><strong><i><span style="font-weight: normal">dept_emp</span></i></strong><strong><span style="font-style: normal"><span style="font-weight: normal">.
</span></span></strong>
</p>
<h2 class="western"><a name="__RefHeading___Toc17623_2563936057"></a><strong><font color="#1b75bc">&#61609;</font></strong>
&laquo;UPSERT&raquo; og MERGE</h2>
<p class="western">UPSERT er et uttrykk for en UPDATE som resulterer
i en INSERT dersom raden som skal oppdateres ikke finnes fra f&oslash;r,
eller omvendt, at vi vil sette inn en ny rad, men det eksisterer
allerede en rad med den prim&aelig;rn&oslash;kkelen vi fors&oslash;ker
&aring; legge inn, og vi vil la SQL oppdatere denne raden med nye
data. I SQL-standarden (fra og med SQL 2003) er dette definert som en
MERGE mellom den eksisterende og den nye raden. Det er bare Oracle og
MS SQL Server som st&oslash;tter SQL-standardens syntaks for MERGE
n&aring;r denne boken skrives, men MySQL/MariaDB og PostgreSQL har
st&oslash;tte for &aring; utf&oslash;re en UPSERT gjennom egne
syntakser. 
</p>
<p class="western">I en UPSERT kan vi velge &aring; oppdatere alle
eller noen av feltene i den eksisterende raden. Dette kan v&aelig;re
en god l&oslash;sning hvis vi f.eks. skal legge inn nye kontaktdata
og er usikker p&aring; om kontakten er registrert fra f&oslash;r.
Finnes kontakten allerede i databasen, kan vi velge &aring; erstatte
telefon, epost e.l. med nyere data (selvf&oslash;lgelig gitt at data
vi legger inn er nyere enn de som ligger der fra f&oslash;r).</p>
<p class="western">Her er noen enkle eksempler p&aring; hvordan en 
&laquo;UPSERT&raquo; eller MERGE kan se ut med de ulike RDBMSene: 
</p>
<h3 class="western"><a name="__RefHeading___Toc17625_2563936057"></a>UPSERT
med MySQL / MariaDB</h3>
<p class="western">MySQL og MariaDB har implementert UPSERT som et
valg n&aring;r vi utf&oslash;rer en  INSERT INTO. Vi legger ganske
enkelt til n&oslash;kkelordene <strong>ON DUPLICATE KEY UPDATE,</strong>
og s&aring; angir vi hvilke felt vi vil ha oppdatert, slik:</p>
<pre class="western"><strong><b>INSERT INTO</b></strong><strong><span style="font-weight: normal"> </span></strong><strong><span style="font-weight: normal">&lt;</span></strong><strong><span style="font-weight: normal">tabe</span></strong><strong><span style="font-weight: normal">ll&gt;</span></strong>
<strong>&nbsp; <span style="font-weight: normal">(</span></strong><strong><span style="font-weight: normal">&lt;felt</span></strong><strong><span style="font-weight: normal">1</span></strong><strong><span style="font-weight: normal">&gt;</span></strong><strong><span style="font-weight: normal">, </span></strong><strong><span style="font-weight: normal">&lt;felt</span></strong><strong><span style="font-weight: normal">2</span></strong><strong><span style="font-weight: normal">&gt;</span></strong><strong><span style="font-weight: normal">, </span></strong><strong><span style="font-weight: normal">&lt;felt</span></strong><strong><span style="font-weight: normal">3</span></strong><strong><span style="font-weight: normal">&gt;</span></strong><strong><span style="font-weight: normal">, </span></strong><strong><span style="font-weight: normal">&lt;felt</span></strong><strong><span style="font-weight: normal">4</span></strong><strong><span style="font-weight: normal">&gt;</span></strong><strong><span style="font-weight: normal">)</span></strong>
<strong><b>VALUES</b></strong>
<strong>&nbsp; <span style="font-weight: normal">(</span></strong><strong><span style="font-weight: normal">&lt;</span></strong><strong><span style="font-weight: normal">v</span></strong><strong><span style="font-weight: normal">erdi</span></strong><strong><span style="font-weight: normal">1</span></strong><strong><span style="font-weight: normal">&gt;</span></strong><strong><span style="font-weight: normal">, </span></strong><strong><span style="font-weight: normal">&lt;</span></strong><strong><span style="font-weight: normal">v</span></strong><strong><span style="font-weight: normal">erdi2&gt;</span></strong><strong><span style="font-weight: normal">, </span></strong><strong><span style="font-weight: normal">&lt;</span></strong><strong><span style="font-weight: normal">v</span></strong><strong><span style="font-weight: normal">erdi3&gt;</span></strong><strong><span style="font-weight: normal">, </span></strong><strong><span style="font-weight: normal">&lt;</span></strong><strong><span style="font-weight: normal">v</span></strong><strong><span style="font-weight: normal">erdi4&gt;</span></strong><strong><span style="font-weight: normal">)</span></strong>
<strong><b>ON DUPLICATE KEY UPDATE</b></strong>
<strong>&nbsp; </strong><strong><span style="font-weight: normal">&lt;felt</span></strong><strong><span style="font-weight: normal">2</span></strong><strong><span style="font-weight: normal">&gt;</span></strong><strong><span style="font-weight: normal">=</span></strong><strong><span style="font-weight: normal">&lt;</span></strong><strong><span style="font-weight: normal">v</span></strong><strong><span style="font-weight: normal">erdi2&gt;</span></strong><strong><span style="font-weight: normal">,</span></strong>
<strong>&nbsp; </strong><strong><span style="font-weight: normal">&lt;felt3&gt;</span></strong><strong><span style="font-weight: normal">=</span></strong><strong><span style="font-weight: normal">&lt;</span></strong><strong><span style="font-weight: normal">v</span></strong><strong><span style="font-weight: normal">erdi3&gt;</span></strong><strong><span style="font-weight: normal">,</span></strong>
<strong>&nbsp; </strong><strong><span style="font-weight: normal">&lt;felt4&gt;</span></strong><strong><span style="font-weight: normal">=</span></strong><strong><span style="font-weight: normal">&lt;</span></strong><strong><span style="font-weight: normal">v</span></strong><strong><span style="font-weight: normal">erdi4&gt;</span></strong><strong><span style="font-weight: normal">,</span></strong></pre><p class="western">
Du kan velge &aring; oppdatere alle eller noen av feltene i den
eksisterende raden. Dette kan v&aelig;re en god l&oslash;sning hvis
du f.eks. skal legge inn nye kontaktdata og er usikker p&aring; om
kontakten er registrert fra f&oslash;r. Finnes kontakten allerede i
databasen, kan du velge &aring; erstatte telefon, epost e.l. med
nyere data (selvf&oslash;lgelig gitt at data du legger inn er nyere
enn de som ligger der fra f&oslash;r). Slik kan en UPSERT se ut med
MySQL / MariaDB hvis vi f.eks. vil oppdatere feltet <i>notater </i><span style="font-style: normal">dersom
feltet </span><i>epost </i><span style="font-style: normal">allerede
inneholder verdien </span><i>petter@smart.com</i>:</p>
<pre class="western"><strong><span style="font-weight: normal">INSERT INTO brukere (epost,notater) VALUES ('petter@smart.com','Oppdatert i dag') </span></strong><strong><b>ON </b></strong><strong><b>DUPLICATE KEY UPDATE </b></strong><strong><span style="font-weight: normal">notater</span></strong><strong><b> = </b></strong><strong><span style="font-weight: normal">'</span></strong><strong><span style="font-weight: normal">Oppdatert i dag</span></strong><strong><span style="font-weight: normal">';</span></strong></pre><h3 class="western">
<a name="__RefHeading___Toc17627_2563936057"></a>UPSERT / MERGE med
ORACLE</h3>
<p class="western"><strong><span style="font-weight: normal">Oracle
bruker n&oslash;kkelordet </span></strong><strong><b>MERGE </b></strong><strong><span style="font-weight: normal">til
&aring; utf&oslash;re en &laquo;UPSERT&raquo;.  </span></strong><strong><span style="font-weight: normal">Vi
skal konstruere et lite eksempel for &aring; belyse bruken av MERGE
med Oracle. F&oslash;rst oppretter vi en tabell &laquo;person&raquo;,
med 4 felt &ndash; id, fornavn, etternavn, tel.</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">CREATE TABLE person (id varchar(10) primary key, fornavn varchar(30), etternavn varchar(30), tel varchar(10)) ;</span></strong></pre><p class="western">
<strong><span style="font-weight: normal">S&aring; setter vi inn noen
rader med data i tabellen:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">INSERT ALL </span></strong>
<strong><span style="font-weight: normal">INTO person (id,fornavn,etternavn,tel) values ('1001','Ola','Normann','12345678') </span></strong>
<strong><span style="font-weight: normal">INTO person (id,fornavn,etternavn,tel) values ('1002','Kari','Normann','12345678') </span></strong>
<strong><span style="font-weight: normal">INTO person (id,fornavn,etternavn,tel) values ('1003','Petter','Normann','87654321') </span></strong>
<strong><span style="font-weight: normal">INTO person (id,fornavn,etternavn,tel) values ('1004','Eva','Normann','98765432') </span></strong>
<strong><span style="font-weight: normal">select 1 from dual;</span></strong></pre><p class="merk">
<strong>MERK: </strong><strong><span style="font-weight: normal">Vi
kan sette inn flere rader med en SQL-setning ved &aring; bruke
n&oslash;kkelordene </span></strong><strong><b>INSERT ALL, </b></strong><strong><span style="font-weight: normal">men
vi m&aring; avslutte med  </span></strong><strong><span style="font-weight: normal">noe
&agrave; la </span></strong><strong><span style="font-weight: normal">&laquo;select
1 from dual&raquo; (slik at det lages en rad som brukes til
innsettingen). Dette er en spesialitet som bare Oracle bruker. </span></strong>
</p>
<p class="western"><strong><span style="font-weight: normal">S&aring;
kopierer vi tabellen til en tabell vi kaller &laquo;person_ny&raquo;,
slik:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">create table person_ny as select * from person; </span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Og deretter endrer vi litt
p&aring; denne tabellen, slik at den inneholder mer oppdaterte data
en den opprinnelige tabellen (&laquo;person&raquo;):</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">INSERT</span></strong><strong><span style="font-weight: normal"> INTO person_ny (id,fornavn,etternavn,tel) <br/>
</span></strong><strong><span style="font-weight: normal">VALUES</span></strong><strong><span style="font-weight: normal"> ('1005','Krister','Petterson','11223344');</span></strong>

<a name="__DdeLink__19938_3633986250"></a><strong><span style="font-weight: normal">UPDATE</span></strong><strong><span style="font-weight: normal"> person_ny </span></strong><strong><span style="font-weight: normal">SET</span></strong><strong><span style="font-weight: normal"> tel='22222222' where id='1002';</span></strong>

<strong><span style="font-weight: normal">DELETE FROM person_ny WHERE id='1001'</span></strong></pre><p class="western">
<strong><span style="font-weight: normal">V</span></strong><strong><span style="font-weight: normal">i
har da oppdatert en eksisterende rad og satt inn en ny rad i forhold
til den opprinnelige tabellen. De to tabellene ser n&aring; slik ut:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">select * from person; </span></strong>

<strong><span style="font-weight: normal">1001	Ola		Normann	12345678</span></strong>
<strong><span style="font-weight: normal">1002	Kari		Normann	12345678</span></strong>
<strong><span style="font-weight: normal">1003	Petter		Normann	87654321</span></strong>
<strong><span style="font-weight: normal">1004	Eva		Normann	98765432</span></strong>

<strong><span style="font-weight: normal">select * from person_ny;</span></strong>

<strong><span style="font-weight: normal">1002	Kari		Normann	22222222</span></strong>
<strong><span style="font-weight: normal">1003	Petter		Normann	87654321</span></strong>
<strong><span style="font-weight: normal">1004	Eva		Normann	98765432</span></strong>
<strong><span style="font-weight: normal">1005	Krister	Petterson	11223344 </span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Vi kan n&aring; oppdatere
tabellen &laquo;person&raquo; med nye data fra tabellen &laquo;person_ny&raquo;
ved &aring; konstruere en MERGE-setning, slik:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">MERGE into person p USING person_ny ny</span></strong>
<strong><span style="font-weight: normal">ON (p.id = ny.id)</span></strong>
<strong><b>WHEN MATCHED THEN</b></strong><strong><span style="font-weight: normal"> UPDATE SET p.fornavn = ny.fornavn, p.etternavn = ny.etternavn, p.tel = ny.tel</span></strong>
<strong><b>WHEN NOT MATCHED THEN</b></strong><strong><span style="font-weight: normal"> INSERT (id,fornavn,etternavn,tel)  </span></strong>
<strong><span style="font-weight: normal">VALUES (ny.id, ny.fornavn, ny.etternavn, ny.tel); </span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Setningen gir oss dette
tilbake: </span></strong>
</p>
<pre class="western"><strong><span style="font-weight: normal">4</span></strong><strong><span style="font-weight: normal"> rows merged.</span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Hvi kan sjekke hva som har
skjedd </span></strong><strong><span style="font-weight: normal">ved
&aring; se p&aring; innholdet i person-tabellen:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">SELECT * FROM person;</span></strong>

<strong><span style="font-weight: normal">1001	Ola		Normann	12345678</span></strong>
<strong><span style="font-weight: normal">1002	Kari		Normann	22222222</span></strong>
<strong><span style="font-weight: normal">1003	Petter		Normann	87654321</span></strong>
<strong><span style="font-weight: normal">1004	Eva		Normann	98765432</span></strong>
<strong><span style="font-weight: normal">1005	Krister	Petterson	11223344</span></strong></pre><p class="western">
<strong><span style="font-weight: normal">Vi ser at vi har oppdatert
telefon-nummeret </span></strong><strong><span style="font-weight: normal">til
Kari og lagt til en rad for Krister. Men legg merke til at vi ikke
har slettet Ola. Den ny tabellen trenger ikke inneholde alle radene i
den gamle. </span></strong>
</p>
<h3 class="western"><a name="__RefHeading___Toc17629_2563936057"></a><strong><span style="font-weight: normal">UPSERT
med Microsoft SQL Server</span></strong></h3>
<p class="western"><strong><span style="font-weight: normal">SQL-server
bruker ogs&aring; n&oslash;kkelordet MERGE til &aring; lage en
&laquo;UPSERT&raquo;. </span></strong><strong><span style="font-weight: normal">SQL-setningen
nedenfor oppdaterer etternavnet til ansatt nummer 50000</span></strong><strong><span style="font-weight: normal">2</span></strong><strong><span style="font-weight: normal">,
og hvis det ikke finnes noen ansatt nummer 50000</span></strong><strong><span style="font-weight: normal">2</span></strong><strong><span style="font-weight: normal">,
settes det inn en ny rad med verdie</span></strong><strong><span style="font-weight: normal">r</span></strong><strong><span style="font-weight: normal">
for den nye ansatte. Setningen bruker funksjonen </span></strong><strong><b>getdate()
</b></strong><strong><span style="font-weight: normal">til &aring;
hente dagens dato for feltet </span></strong><strong><i><span style="font-weight: normal">hire_date.
</span></i></strong>
</p>
<pre class="western"><b>MERGE</b> employees AS e1 USING (SELECT '500002' AS n) as n
ON e1.emp_no = n
WHEN MATCHED THEN UPDATE SET e1.last_name = 'Olsen'
WHEN NOT MATCHED 
THEN INSERT (emp_no,first_name,last_name,gender,hire_date,birth_date) 
values ('500002','Ola','Nordmann','M',getdate(),'1970-01-01');
</pre><p class="western">
Du kan ogs&aring; gj&oslash;re det p&aring; denne m&aring;ten, men
den er litt mindre effektiv: (hvis du bare skal sette inn nye data
kan IF EXISTS v&aelig;re raskere, men hvis du ogs&aring; skal
oppdatere kan MERGE v&aelig;re raskere.)</p>
<pre class="western">IF EXISTS (select emp_no from employees where emp_no='500002')
   UPDATE employees SET last_name = 'Olsen' where emp_no = '500002';
ELSE
  INSERT into employees  (emp_no,first_name,last_name,gender,hire_date,birth_date)  
VALUES ('500002','Ola','Nordmann','M',getdate(),'1970-01-01');</pre><h3 class="western">
<a name="__RefHeading___Toc17631_2563936057"></a><strong><span style="font-weight: normal">UPSERT
med PostgreSQL</span></strong></h3>
<p class="western"><strong><span style="font-weight: normal">PostgreSQL
lager en UPSERT ved &aring; legge til </span></strong><strong><span style="font-weight: normal">n&oslash;kkelordene</span></strong><strong><span style="font-weight: normal">
</span></strong><strong><b>ON CONFLICT</b></strong><strong><span style="font-weight: normal">
</span></strong><strong><span style="font-weight: normal">(</span></strong><strong><span style="font-weight: normal">&lt;felt&gt;</span></strong><strong><span style="font-weight: normal">)</span></strong><strong><span style="font-weight: normal">
</span></strong><strong><b>DO UPDATE SET &lt;</b></strong><strong><span style="font-weight: normal">felt&gt;
= </span></strong><strong><b>EXCLUDED.</b></strong><strong><span style="font-weight: normal">&lt;felt&gt;
</span></strong><strong><span style="font-weight: normal"> i en
INSERT-setning. </span></strong><strong><span style="font-weight: normal">Hvis
vi for eksempel har en tabell </span></strong><strong><i><span style="font-weight: normal">brukere
</span></i></strong><strong><span style="font-weight: normal">som
inneholder feltene </span></strong><strong><i><span style="font-weight: normal">epost</span></i></strong><strong><span style="font-weight: normal">
og </span></strong><strong><i><span style="font-weight: normal">notater,
hvor</span></i></strong><strong><span style="font-style: normal"><span style="font-weight: normal">
feltet </span></span></strong><strong><i><span style="font-weight: normal">epost</span></i></strong><strong><span style="font-style: normal"><span style="font-weight: normal">
er definert som et unikt felt, kan vi lage en upsert slik:</span></span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">INSERT INTO brukere (epost,notater) VALUES ('petter@smart.com','Oppdatert i dag') </span></strong><strong><b>ON CONFLICT (epost) DO UPDATE SET notater = EXCLUDED.notater</b></strong><strong><span style="font-weight: normal">;</span></strong></pre><p class="western">
<strong><span style="font-style: normal"><span style="font-weight: normal">Setningen
over vil sette inn en </span></span></strong><strong><span style="font-style: normal"><span style="font-weight: normal">rad,
og hvis epostadressen </span></span></strong><strong><i><span style="font-weight: normal">petter@smart.com</span></i></strong><strong><span style="font-style: normal"><span style="font-weight: normal">
allerede finnes i tabellen vil denne raden bli oppdatert med en ny
verdi </span></span></strong><strong><span style="font-style: normal"><span style="font-weight: normal">-
&laquo;Oppdatert i dag&raquo; - </span></span></strong><strong><span style="font-style: normal"><span style="font-weight: normal">for
feltet notater. </span></span></strong>
</p>
<p class="merk"><strong>MERK: </strong><strong><span style="font-weight: normal">PostgreSQL
bruker n&oslash;kkelordet </span></strong><strong><b>EXCLUDED</b></strong><strong><span style="font-weight: normal">
til &aring; angi at et felt skal oppdateres med en verdi angitt i
INSERT-setningen. For eksempel vil EXCLUDED.notater angi verdien vi
har gitt til feltet notater i INSERT-setningen &ndash; i eksemplet
over er denne verdien setningen &rsquo;Oppdatert i dag&rsquo;.  </span></strong>
</p>
<p class="western"><strong><span style="font-weight: normal">Hvis vi
ikke vil oppdatere eksisterende rader, kan vi i stedet sette inn
n&oslash;kkelordene </span></strong><strong><b>ON CONFLICT (&lt;felt&gt;)
DO NOTHING</b></strong><strong><span style="font-weight: normal">,
slik:</span></strong></p>
<pre class="western"><strong><span style="font-weight: normal">INSERT INTO brukere (epost,notater) VALUES ('petter@smart.com','Oppdatert i dag') </span></strong><strong><b>ON CONFLICT (epost) DO NOTHING</b></strong><strong><span style="font-weight: normal">;</span></strong></pre><h2 class="western">
<a name="__RefHeading___Toc359_487959650"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Slette data med DELETE og TRUNCATE</h2>
<p class="western">Skal du slette en <strong>hel rad </strong>eller<strong>
flere hele rader </strong>i en tabell, gj&oslash;res dette med
DELETE, slik:</p>
<pre class="western"><strong><span style="font-weight: normal">DELETE FROM Customers</span></strong>
<strong><span style="font-weight: normal">WHERE cust_id = '100000006';&nbsp;</span></strong></pre><p class="western">
Det er ekstremt viktig at man har med en WHERE-betingelse som angir
hvilke rad(er) som skal slettes. Glemmer man dette, slettes <strong>alle</strong>
rader i tabellen.</p>
<p class="western">Dersom man <em>&oslash;nsker</em> &aring; <strong>slette
alle rader</strong> i en tabell, gj&oslash;res dette mer effektivt
med TRUNCATE, slik</p>
<pre class="western"><strong><span style="font-weight: normal">TRUNCATE TABLE Customers;</span></strong></pre><p class="western">
Du kan gj&oslash;re det samme med <b>DELETE FROM Customers </b><span style="font-weight: normal">(uten
noen WHERE-betingelse)</span>, men da m&aring; DBMSen bla gjennom
alle radene og slette en og en. Med TRUNCATE t&oslash;mmes tabellen
for data i &eacute;n operasjon.</p>
<p class="merk"><strong>MERK:</strong> Bruker du TRUNCATE logges
t&oslash;mmingen av tabellen ogs&aring; med en linje istedenfor med
en linje per rad hvis du bruker DELETE FROM. Det kan bli en stor
loggfil hvis du sletter noen millioner rader.</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc23529_1624848858"></a>
<font size="6" style="font-size: 24pt">Kapittel 1</font><font size="6" style="font-size: 24pt">4</font><br/>
Komplekse
Datatyper: Arrays, JSON og XML</h1>
<h2 class="western"><a name="__RefHeading___Toc18262_15578344861"></a>
<strong><font color="#1b75bc">&#61609;</font></strong> Komplekse
datatyper</h2>
<p class="western">Komplekse datatyper er datatyper som kan inneholde
mer enn &eacute;n verdi &ndash; som f.eks. lister (arrays), maps,
JSON-objekter og XML-dokumenter. Vi skal i dette kapitlet se p&aring;
hvordan disse h&aring;ndteres (eller ikke h&aring;ndteres) i de 4
store RDBMSene. Innledningsvis kan vi sl&aring; fast at distribuerte
databaser (se del 2 av denne boken) skinner best i h&aring;ndteringen
av disse, men det er mye som tyder p&aring; at st&oslash;tte for dem
er p&aring; full vei ogs&aring; inn i de tradisjonelle RDBMSene.</p>
<h2 class="western"><a name="__RefHeading___Toc23531_1624848858"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Arrays</h2>
<p class="western">Arrays er &eacute;n- eller flerdimensjonale
lister. En rad i en SQL-tabell kan sees som et &eacute;n-dimensjonalt
array, og en tabell kan sees som et to-dimensjonalt array. St&oslash;tten
for array som datatype er enn&aring; ikke utbredt blant de
tradisjonelle RDBMSene, siden bruken av dem ofte strider mot
normaliserings-paradigmet som ligger til grunn for datamodellene de
bygger p&aring;. Men en viss st&oslash;tte finnes.</p>
<h3 class="western"><a name="__RefHeading___Toc23533_1624848858"></a>Arrays
med PostgreSQL</h3>
<p class="western">PostgreSQL har relativt god st&oslash;tte for b&aring;de
&eacute;n- og flerdimensjonelle arrays som datatype, og har ogs&aring;
en rekke innebygde funksjoner for &aring; h&aring;ndtere dem.</p>
<p class="western">Slik oppretter vi en tabell med felt som har
arrays uten fastsatt st&oslash;rrelse som datatype. Id&eacute;en er &aring;
ha et felt med et &eacute;ndimensjonalt array som kan inneholde flere
epostadresser og et felt med et todimensjonalt array som inneholder
ukenummer og aktivitet for uken. Slik gj&oslash;res det: 
</p>
<pre class="western">CREATE TABLE kontakter (
id int primary key, 
fornavn text,
etternavn text,
epost text[]
) </pre><h3 class="western">
<a name="__RefHeading___Toc23535_1624848858"></a>Innsetting av
elementer i et array</h3>
<p class="western">Vi kan sette inn verdier for epost &ndash; arrayet
p&aring; to m&aring;ter &ndash; med kr&oslash;llklammer, slik:</p>
<pre class="western">INSERT INTO kontakter (id,fornavn,etternavn,epost) VALUES (1,'Donald','Duck','{&quot;donald@disney.com&quot;,&quot;d.duck@disney.com&quot;}');</pre><p class="western">
eller med konstruksjonen <b>array[&lt;element&gt;]</b>:</p>
<pre class="western">INSERT INTO kontakter (id,fornavn,etternavn,epost) VALUES (2,'Petter','Smart',array['petter.smart@disney.com','p.smart@disney.com']);</pre><p class="merk">
<b>MERK: </b><span style="font-weight: normal">Legg merke til bruken
av doble og enkle anf&oslash;rselstegn i de to m&aring;tene &aring;
angi et array p&aring;. Bruker vi array[] - syntaksen skal vi bruke
enkle anf&oslash;rselstegn rundt tekst-elementene i arrayet, bruker
vi kr&oslash;llklamme-syntaksen bruker vi enkle rundt hele og doble
rundt hvert element.</span></p>
<p class="western">Tabellen ser n&aring; slik ut:</p>
<pre class="western">select * from kontakter; <br/>

id | fornavn | etternavn | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;epost &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
----+---------+-----------+---------------------------------------------- <br/>
&nbsp;1 | Donald &nbsp;| Duck &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {donald@disney.com,d.duck@disney.com} <br/>
&nbsp;2 | Petter &nbsp;| Smart &nbsp;&nbsp;&nbsp;&nbsp;| {petter.smart@disney.com,p.smart@disney.com} <br/>
(2 rows)</pre><h3 class="western">
<a name="__RefHeading___Toc23537_1624848858"></a>S&oslash;ke etter
elementer i et array 
</h3>
<p class="western">Vi kan n&aring; f.eks. s&oslash;ke etter kontakter
via epost-feltet med tegnet <b>@&gt;</b>  (kalles gjerne
iskrem-tegnet og st&aring;r for: inneholder) , slik:</p>
<pre class="western">SELECT fornavn, etternavn FROM kontakter 
WHERE epost @&gt; array['petter.smart@disney.com'];

fornavn | etternavn &nbsp;<br/>
---------+----------- <br/>
Petter &nbsp;| Smart <br/>
(1 row)</pre><p class="western">
Samme resultat kan oppn&aring;s ved &aring; bruke n&oslash;kkelordet
<b>any</b><span style="font-weight: normal">, som angir at vi vil
s&oslash;ke etter hvilket som helst element i arrayet som inneholder
s&oslash;keordet, slik:</span></p>
<pre class="western">SELECT fornavn, etternavn FROM kontakter 
WHERE 'donald@disney.com' = any(epost); &nbsp;&nbsp;&nbsp;<br/>

fornavn | etternavn &nbsp;<br/>
---------+----------- <br/>
Donald &nbsp;| Duck<br/>
</pre><p class="merk">
<b>MERK: </b><span style="font-weight: normal">Legg merke til at vi
setter s&oslash;ke-frasen f&oslash;rst n&aring;r vi bruker any. </span>
</p>
<p class="merk" style="font-weight: normal">Omvendt rekkef&oslash;lge
gir en feilmelding:</p>
<p class="merk">SELECT fornavn, etternavn FROM kontakter <br/>
WHERE
any(epost) = 'donald@disney.com'; 
</p>
<p class="merk">ERROR: &nbsp;syntax error at or near &quot;any&quot;
<br/>
<span style="font-weight: normal"> </span>
</p>
<p class="western">Vi kan ogs&aring; liste ut eller s&oslash;ke etter
et element i et array etter posisjonen elementet har i arrayet &ndash;
for eksempel liste ut eller s&oslash;ke i den f&oslash;rste eposten i
listen, slik:</p>
<pre class="western">
SELECT fornavn, etternavn, epost[1] FROM kontakter;

fornavn | etternavn | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;epost &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
---------+-----------+------------------------- <br/>
Donald &nbsp;| Duck &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| donald@disney.com <br/>
Petter &nbsp;| Smart &nbsp;&nbsp;&nbsp;&nbsp;| petter.smart@disney.com <br/>
(2 rows)<br/>
<br/>


SELECT fornavn, etternavn FROM kontakter 
WHERE epost[1] = 'donald@disney.com'; <br/>

fornavn | etternavn &nbsp;<br/>
---------+----------- <br/>
Donald &nbsp;| Duck <br/>
(1 row)<br/>
</pre><p class="merk">
MERK: PostgreSQL arrays er indeksert med 1 som f&oslash;rste element,
i motsetning til mange spr&aring;k hvor arrays er null-indekserte.</p>
<h3 class="western"><a name="__RefHeading___Toc23539_1624848858"></a>Oppdatering
og sletting av elementer i et array:</h3>
<p class="western">Vi kan oppdatere et element i et array ved &aring;
referere til elementets posisjon:</p>
<pre class="western">UPDATE kontakter SET epost[2] = 'd.d@disney.com' WHERE id = 1;<br/>
<br/>
select * from kontakter where id=1; <br/>

id | fornavn | etternavn | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;epost &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
----+---------+-----------+------------------------------------ <br/>
&nbsp;1 | Donald &nbsp;| Duck &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {donald@disney.com,d.d@disney.com}</pre><p class="western">
 og vi kan legge til en epost til med sammenskj&oslash;tings-tegnet
(<b>||)</b>, slik:</p>
<pre class="western">UPDATE kontakter 
SET epost = epost || array['donald@.duck.com'] where id = 1;

select * from kontakter where id=1; <br/>

<font size="1" style="font-size: 8pt">id | fornavn | etternavn | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;epost &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
----+---------+-----------+----------------------------------------------------- <br/>
&nbsp;1 | Donald &nbsp;| Duck &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {donald@disney.com,d.d@disney.com,donald@.duck.com}</font></pre><h3 class="western">
<a name="__RefHeading___Toc23541_1624848858"></a>Operander og
funksjoner for arrays i PostgreSQL 
</h3>
<p class="western">PostgreSQL har et knippe hendige operander og
funksjoner for &aring; behandle arrays. Her er en oversikt sakset fra
dokumentasjonen til versjon 10:</p>
<p class="western"><b>Array-operander</b></p>
<table width="711" cellpadding="2" cellspacing="1">
	<col width="64"/>

	<col width="174"/>

	<col width="265"/>

	<col width="185"/>

	<thead>
		<tr>
			<th width="64" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
				Operand</p>
			</th>
			<th width="174" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
				Beskrivelse</p>
			</th>
			<th width="265" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
				Eksempel</p>
			</th>
			<th width="185" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
				Resultat</p>
			</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">=</code></p>
			</td>
			<td width="174" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				equal</p>
			</td>
			<td width="265" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3]</code></p>
			</td>
			<td width="185" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">t</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">&lt;&gt;</code></p>
			</td>
			<td width="174" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				not equal</p>
			</td>
			<td width="265" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">ARRAY[1,2,3] &lt;&gt; ARRAY[1,2,4]</code></p>
			</td>
			<td width="185" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">t</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">&lt;</code></p>
			</td>
			<td width="174" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				less than</p>
			</td>
			<td width="265" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">ARRAY[1,2,3] &lt; ARRAY[1,2,4]</code></p>
			</td>
			<td width="185" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">t</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">&gt;</code></p>
			</td>
			<td width="174" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				greater than</p>
			</td>
			<td width="265" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">ARRAY[1,4,3] &gt; ARRAY[1,2,4]</code></p>
			</td>
			<td width="185" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">t</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">&lt;=</code></p>
			</td>
			<td width="174" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				less than or equal</p>
			</td>
			<td width="265" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">ARRAY[1,2,3] &lt;= ARRAY[1,2,3]</code></p>
			</td>
			<td width="185" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">t</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">&gt;=</code></p>
			</td>
			<td width="174" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				greater than or equal</p>
			</td>
			<td width="265" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">ARRAY[1,4,3] &gt;= ARRAY[1,4,3]</code></p>
			</td>
			<td width="185" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">t</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">@&gt;</code></p>
			</td>
			<td width="174" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				contains</p>
			</td>
			<td width="265" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">ARRAY[1,4,3] @&gt; ARRAY[3,1]</code></p>
			</td>
			<td width="185" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">t</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">&lt;@</code></p>
			</td>
			<td width="174" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				is contained by</p>
			</td>
			<td width="265" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">ARRAY[2,7] &lt;@ ARRAY[1,7,4,2,6]</code></p>
			</td>
			<td width="185" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">t</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">&amp;&amp;</code></p>
			</td>
			<td width="174" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				overlap (have elements in common)</p>
			</td>
			<td width="265" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</code></p>
			</td>
			<td width="185" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">t</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">||</code></p>
			</td>
			<td width="174" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				array-to-array concatenation</p>
			</td>
			<td width="265" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">ARRAY[1,2,3] || ARRAY[4,5,6]</code></p>
			</td>
			<td width="185" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">{1,2,3,4,5,6}</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">||</code></p>
			</td>
			<td width="174" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				array-to-array concatenation</p>
			</td>
			<td width="265" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]</code></p>
			</td>
			<td width="185" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">{{1,2,3},{4,5,6},{7,8,9}}</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">||</code></p>
			</td>
			<td width="174" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				element-to-array concatenation</p>
			</td>
			<td width="265" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">3 || ARRAY[4,5,6]</code></p>
			</td>
			<td width="185" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">{3,4,5,6}</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">||</code></p>
			</td>
			<td width="174" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				array-to-element concatenation</p>
			</td>
			<td width="265" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">ARRAY[4,5,6] || 7</code></p>
			</td>
			<td width="185" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">{4,5,6,7}</code></p>
			</td>
		</tr>
	</tbody>
</table>
<p class="western"><br/>
<br/>

</p>
<p class="western"><b>Array-f</b><b>unksjoner</b></p>
<div id="ARRAY-FUNCTIONS-TABLE" dir="ltr">
	<table width="711" cellpadding="2" cellspacing="1">
		<col width="135"/>

		<col width="119"/>

		<col width="181"/>

		<col width="151"/>

		<col width="97"/>

		<thead>
			<tr>
				<th width="135" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
					<font face="Liberation Serif, serif">Funksjon</font></p>
				</th>
				<th width="119" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
					<font face="Liberation Serif, serif">Retur-type</font></p>
				</th>
				<th width="181" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
					<font face="Liberation Serif, serif">Beskrivelse</font></p>
				</th>
				<th width="151" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
					<font face="Liberation Serif, serif">Eksempel</font></p>
				</th>
				<th width="97" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
					<font face="Liberation Serif, serif">Resultat</font></p>
				</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_append(anyarray,
					anyelement)</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">anyarray</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">append an element to the
					end of an array</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_append(ARRAY[1,2],
					3)</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">{1,2,3}</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_cat(anyarray,
					anyarray)</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">anyarray</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">concatenate two arrays</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_cat(ARRAY[1,2,3],
					ARRAY[4,5])</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">{1,2,3,4,5}</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_ndims(anyarray)</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">int</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">returns the number of
					dimensions of the array</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_ndims(ARRAY[[1,2,3],
					[4,5,6]])</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">2</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_dims(anyarray)</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">text</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">returns a text
					representation of array's dimensions</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_dims(ARRAY[[1,2,3],
					[4,5,6]])</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">[1:2][1:3]</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_fill(anyelement,
					int[] [, int[]])</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">anyarray</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">returns an array
					initialized with supplied value and dimensions, optionally with
					lower bounds other than 1</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_fill(7,
					ARRAY[3], ARRAY[2])</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">[2:4]={7,7,7}</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_length(anyarray,
					int)</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">int</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">returns the length of the
					requested array dimension</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_length(array[1,2,3],
					1)</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">3</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_lower(anyarray,
					int)</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">int</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">returns lower bound of the
					requested array dimension</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_lower('[0:2]={1,2,3}'::int[],
					1)</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">0</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_position(anyarray,
					anyelement [, int])</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">int</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">returns the subscript of
					the first occurrence of the second argument in the array,
					starting at the element indicated by the third argument or at
					the first element (array must be one-dimensional)</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'],
					'mon')</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">2</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_positions(anyarray,
					anyelement)</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">int[]</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">returns an array of
					subscripts of all occurrences of the second argument in the
					array given as first argument (array must be one-dimensional)</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_positions(ARRAY['A','A','B','A'],
					'A')</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">{1,2,4}</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_prepend(anyelement,
					anyarray)</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">anyarray</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">append an element to the
					beginning of an array</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_prepend(1,
					ARRAY[2,3])</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">{1,2,3}</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_remove(anyarray,
					anyelement)</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">anyarray</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">remove all elements equal
					to the given value from the array (array must be
					one-dimensional)</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_remove(ARRAY[1,2,3,2],
					2)</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">{1,3}</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_replace(anyarray,
					anyelement, anyelement)</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">anyarray</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">replace each array element
					equal to the given value with a new value</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_replace(ARRAY[1,2,5,4],
					5, 3)</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">{1,2,3,4}</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_to_string(anyarray,
					text [, text])</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">text</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">concatenates array elements
					using supplied delimiter and optional null string</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_to_string(ARRAY[1,
					2, 3, NULL, 5], ',', '*')</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">1,2,3,*,5</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_upper(anyarray,
					int)</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">int</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">returns upper bound of the
					requested array dimension</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">array_upper(ARRAY[1,8,3,7],
					1)</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">4</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">cardinality(anyarray)</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">int</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">returns the total number of
					elements in the array, or 0 if the array is empty</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">cardinality(ARRAY[[1,2],[3,4]])</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">4</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">string_to_array(text,
					text [, text])</span></font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">text[]</span></font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western" style="font-weight: normal">
					<font face="Liberation Serif, serif">splits string into array
					elements using supplied delimiter and optional null string</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">string_to_array('xx~^~yy~^~zz',
					'~^~', 'yy')</span></font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif"><span style="font-weight: normal">{xx,NULL,zz}</span></font></code></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif">unnest(anyarray)</font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif">setof
					anyelement</font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<font face="Liberation Serif, serif">expand an array to a set of
					rows</font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif">unnest(ARRAY[1,2])</font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><pre class="western"><font face="Liberation Serif, serif">1</font>
<font face="Liberation Serif, serif">2</font></pre><p class="western">
					<font face="Liberation Serif, serif">(2 rows)</font></p>
				</td>
			</tr>
			<tr>
				<td width="135" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif">unnest(anyarray,
					anyarray [, ...])</font></code></p>
				</td>
				<td width="119" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif">setof
					anyelement, anyelement [, ...]</font></code></p>
				</td>
				<td width="181" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<font face="Liberation Serif, serif">expand multiple arrays
					(possibly of different types) to a set of rows. This is only
					allowed in the FROM clause; see <a href="https://www.postgresql.org/docs/10/static/queries-table-expressions.html#QUERIES-TABLEFUNCTIONS">Section&nbsp;7.2.1.4</a></font></p>
				</td>
				<td width="151" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
					<code class="western"><font face="Liberation Serif, serif">unnest(ARRAY[1,2],ARRAY['foo','bar','baz'])</font></code></p>
				</td>
				<td width="97" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><pre class="western"><font face="Liberation Serif, serif">1    foo</font>
<font face="Liberation Serif, serif">2    bar</font>
<font face="Liberation Serif, serif">NULL baz</font></pre><p class="western">
					<font face="Liberation Serif, serif">(3 rows)</font></p>
				</td>
			</tr>
		</tbody>
	</table>
</div>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<h2 class="western" style="page-break-before: always"><a name="__RefHeading___Toc23543_1624848858"></a>
<strong><font color="#1b75bc">&#61609;</font></strong>  JSON 
</h2>
<p class="western">JSON st&aring;r for JavaScript Object Notation
(evt. JavaScript Simple Object Notation, avhengig av hvem du sp&oslash;r)
og er en enkel og stadig mer popul&aelig;r notasjon for &aring;
serialisere JavaScript-objekter. JSON ble utviklet av Douglas
Crockford, som er en ivrig deltaker p&aring; JavaScript-fora (samt p&aring;
<a href="http://www.crockford.com/">www.crockford.com</a>) og har en
intuitiv og lett forst&aring;elig syntaks for &aring; notere
n&oslash;kkel-verdi par, hvor verdien kan v&aelig;re tekst, tall et
array eller et under-objekt. Vi skal se p&aring; hvordan de ulike
RDBMSene h&aring;ndterer JSON-dokumenter som datatype og hvordan man
kan s&oslash;ke i dem med egne funksjoner laget for bruk med JSON som
datatype i SQL. 
</p>
<h3 class="western"><a name="__RefHeading___Toc23545_1624848858"></a>JSON
med PostgreSQL</h3>
<p class="western">PostgreSQL har JSON som en egen datatype,
kombinert med et sett med JSON-relaterte funksjoner. I tillegg er det
st&oslash;tte for JSONB, dvs. bin&aelig;r JSON, som ogs&aring; er en
egen datatype med et tilsvarende sett funksjoner. 
</p>
<p class="western">La oss se p&aring; noen eksempler: F&oslash;rst
oppretter vi en tabell med et par JSONB-kolonner (siden JSONB lagres
mer effektivt enn ren JSON):</p>
<pre class="western">create table blogg ( <br/>
id int primary key generated by default AS identity, <br/>
innlegg jsonb, <br/>
kommentarer jsonb <br/>
);</pre><p class="western">
Vi kan strukturere som JSON-objektene til innleggene slik, for
enkelhets skyld:</p>
<pre class="western">{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;id&quot;: 1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;tittel&quot;: &quot;Nytt blogginnlegg&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&quot;body&quot;: &quot;Dette er teksten til et nytt blogginnlegg&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
}</pre><p class="western">
og kommentarene som et array av JSON-objekter med denne strukturen:</p>
<pre class="western">[{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;id&quot;: 1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;kommentar&quot;: &quot;Dette er teksten til kommentar 1&quot; <br/>
},
{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;id&quot;: 2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;kommentar&quot;: &quot;Dette er teksten til kommentar 2&quot; <br/>
}]</pre><p class="western">
S&aring; setter vi inn et par rader med JSON-objektene i tabellen:</p>
<pre class="western">INSERT INTO blogg (innlegg, kommentarer) VALUES 
(
'{&quot;id&quot;:1,&quot;tittel&quot;:&quot;Nytt blogginnlegg&quot;,&quot;body&quot;:&quot;Dette er teksten til et nytt blogginnlegg&quot;}',
'[{&quot;id&quot;:1,&quot;kommentar&quot;:&quot;Dette er teksten til kommentar 1&quot;}]'
); &nbsp;<br/>

INSERT INTO blogg (innlegg, kommentarer) VALUES 
(
'{&quot;id&quot;:2,&quot;tittel&quot;:&quot;Enda et nytt blogginnlegg&quot;,&quot;body&quot;:&quot;Dette er teksten til enda et nytt blogginnlegg&quot;}',
'[{&quot;id&quot;:1,&quot;kommentar&quot;:&quot;Dette er teksten til kommentar 1&quot;},{&quot;id&quot;:2,&quot;kommentar&quot;:&quot;Dette er teksten til kommentar 2&quot;}]'<br/>
);</pre><p class="western">
Vi kan se hvordan dokumentene ser ut med: 
</p>
<pre class="western"> <font size="1" style="font-size: 7pt"><br/>
</font>select innlegg from blogg; &nbsp;<br/>
<font size="1" style="font-size: 6pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;innlegg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
------------------------------------------------------------------------------------------------------------ <br/>
{&quot;id&quot;: 1, &quot;body&quot;: &quot;Dette er teksten til et nytt blogginnlegg&quot;, &quot;tittel&quot;: &quot;Nytt blogginnlegg&quot;} <br/>
{&quot;id&quot;: 2, &quot;body&quot;: &quot;Dette er teksten til enda et nytt blogginnlegg&quot;, &quot;tittel&quot;: &quot;Enda et nytt blogginnlegg&quot;} <br/>
(2 rows)</font>

<font size="2" style="font-size: 9pt">select kommentarer from blogg; </font><font size="1" style="font-size: 6pt"><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kommentarer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
---------------------------------------------------------------------------------------------------------------<br/>
[{&quot;id&quot;: 1, &quot;kommentar&quot;: &quot;Dette er teksten til kommentar 1&quot;}] <br/>
[{&quot;id&quot;: 1, &quot;kommentar&quot;: &quot;Dette er teksten til kommentar 1&quot;}, {&quot;id&quot;: 2, &quot;kommentar&quot;: &quot;Dette er teksten til kommentar 2&quot;}]</font></pre><p class="western">
Vi kan bruke funksjonen <b>jsonb_pretty()</b> til &aring; vise
strukturen til JSON-objektene bedre:</p>
<pre class="western"><b>select jsonb_pretty(innlegg) as in</b><b>n</b><b>legg from blogg; </b><br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;innlegg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
--------------------------------------------------------------- <br/>
{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;id&quot;: 1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;body&quot;: &quot;Dette er teksten til et nytt blogginnlegg&quot;, &nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;tittel&quot;: &quot;Nytt blogginnlegg&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
} <br/>
{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;id&quot;: 2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;body&quot;: &quot;Dette er teksten til enda et nytt blogginnlegg&quot;,+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;tittel&quot;: &quot;Enda et nytt blogginnlegg&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
} <br/>

(2 rows)

<b>select jsonb_pretty(kommentarer) as kommentarer from blogg; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b><br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kommentarer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
--------------------------------------------------------- <br/>
[ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;id&quot;: 1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;kommentar&quot;: &quot;Dette er teksten til kommentar 1&quot;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
] <br/>
[ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;id&quot;: 1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;kommentar&quot;: &quot;Dette er teksten til kommentar 1&quot;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;id&quot;: 2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;kommentar&quot;: &quot;Dette er teksten til kommentar 2&quot;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
] <br/>
(2 rows)</pre><p class="western">
Neste oppgave er &aring; s&oslash;ke i JSONB-feltene. PostgreSQL har
egne operander for dette form&aring;let: 
</p>
<table width="711" cellpadding="2" cellspacing="1">
	<col width="64"/>

	<col width="88"/>

	<col width="230"/>

	<col width="230"/>

	<col width="71"/>

	<thead>
		<tr>
			<th width="64" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
				Operand</p>
			</th>
			<th width="88" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
				Riktig Operand- type</p>
			</th>
			<th width="230" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
				Beskrivelse</p>
			</th>
			<th width="230" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
				Eksempel</p>
			</th>
			<th width="71" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
				Resultat</p>
			</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">-&gt;</code></p>
			</td>
			<td width="88" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">int</code></p>
			</td>
			<td width="230" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Get JSON array element (indexed from zero, negative integers
				count from the end)</p>
			</td>
			<td width="230" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'[{&quot;a&quot;:&quot;foo&quot;},{&quot;b&quot;:&quot;bar&quot;},{&quot;c&quot;:&quot;baz&quot;}]'::json-&gt;2</code></p>
			</td>
			<td width="71" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">{&quot;c&quot;:&quot;baz&quot;}</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">-&gt;</code></p>
			</td>
			<td width="88" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">text</code></p>
			</td>
			<td width="230" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Get JSON object field by key</p>
			</td>
			<td width="230" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'{&quot;a&quot;: {&quot;b&quot;:&quot;foo&quot;}}'::json-&gt;'a'</code></p>
			</td>
			<td width="71" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">{&quot;b&quot;:&quot;foo&quot;}</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">-&gt;&gt;</code></p>
			</td>
			<td width="88" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">int</code></p>
			</td>
			<td width="230" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Get JSON array element as <code class="western">text</code></p>
			</td>
			<td width="230" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'[1,2,3]'::json-&gt;&gt;2</code></p>
			</td>
			<td width="71" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">3</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">-&gt;&gt;</code></p>
			</td>
			<td width="88" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">text</code></p>
			</td>
			<td width="230" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Get JSON object field as <code class="western">text</code></p>
			</td>
			<td width="230" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'{&quot;a&quot;:1,&quot;b&quot;:2}'::json-&gt;&gt;'b'</code></p>
			</td>
			<td width="71" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">2</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">#&gt;</code></p>
			</td>
			<td width="88" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">text[]</code></p>
			</td>
			<td width="230" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Get JSON object at specified path</p>
			</td>
			<td width="230" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'{&quot;a&quot;: {&quot;b&quot;:{&quot;c&quot;:
				&quot;foo&quot;}}}'::json#&gt;'{a,b}'</code></p>
			</td>
			<td width="71" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">{&quot;c&quot;: &quot;foo&quot;}</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">#&gt;&gt;</code></p>
			</td>
			<td width="88" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">text[]</code></p>
			</td>
			<td width="230" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Get JSON object at specified path as <code class="western">text</code></p>
			</td>
			<td width="230" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'{&quot;a&quot;:[1,2,3],&quot;b&quot;:[4,5,6]}'::json#&gt;&gt;'{a,2}'</code></p>
			</td>
			<td width="71" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western"> </code><code class="western">3</code></p>
			</td>
		</tr>
	</tbody>
</table>
<p class="western"><br/>
<br/>

</p>
<p class="western">Vi kan bruke operanden <b>-</b><span style="text-decoration: none"><b>&gt;</b></span><span style="text-decoration: none">
til &aring; hente elementer fra JSON-felt eller JSONB-felt som tekst,
f.eks. slik:</span></p>
<pre class="western">select <b>innlegg-&gt;'tittel'</b> as tittel from blogg;

&nbsp;&nbsp;&nbsp;tittel &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
----------------------------- <br/>
&quot;Nytt blogginnlegg&quot; <br/>
&quot;Enda et nytt blogginnlegg&quot; <br/>
(2 rows)</pre><p class="western">
Og vi kan bruker operanden <b>-&gt;&gt; </b><span style="font-weight: normal">til
&aring; hente et element fra et JSON eller JSONB array:</span></p>
<pre class="western">select innlegg-&gt;'tittel' as tittel, <b>(kommentarer-&gt;&gt;0)::json-&gt;'kommentar'</b> as kommentar1, <b>(kommentarer-&gt;&gt;1)::json-&gt;'kommentar'</b> as kommentar2 from blogg; <br/>

-[ RECORD 1 ]---------------------------------- <br/>
tittel &nbsp;&nbsp;&nbsp;&nbsp;| &quot;Nytt blogginnlegg&quot; <br/>
kommentar1 | &quot;Dette er teksten til kommentar 1&quot; <br/>
kommentar2 | &nbsp;<br/>
-[ RECORD 2 ]---------------------------------- <br/>
tittel &nbsp;&nbsp;&nbsp;&nbsp;| &quot;Enda et nytt blogginnlegg&quot; <br/>
kommentar1 | &quot;Dette er teksten til kommentar 1&quot; <br/>
kommentar2 | &quot;Dette er teksten til kommentar 2&quot;</pre><p class="merk">
<b>MERK: </b><span style="font-weight: normal">Vi m&aring; konvertere
uttrykkene (kommentarer-&gt;&gt;0) og (kommentar-&gt;&gt;1) til json
med konstruksjonen </span><b>(kommentar-&gt;&gt;0)::json </b><span style="font-weight: normal">f&oslash;r
vi kan konvertere den til tekst. Legg ogs&aring; merke til at
JSON-arrays er 0-indekserte, i motsetning til PostgreSQL arrays hvor
f&oslash;rste element har indeks 1.</span></p>
<h3 class="western"><a name="__RefHeading___Toc23547_1624848858"></a>Operander
som kun gjelder for JSONB</h3>
<p class="western">PostgreSQL har et eget sett med operander for
JSONB:</p>
<p class="western"><br/>
<br/>

</p>
<table width="711" cellpadding="2" cellspacing="1">
	<col width="64"/>

	<col width="90"/>

	<col width="330"/>

	<col width="205"/>

	<thead>
		<tr>
			<th width="64" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
				Operand</p>
			</th>
			<th width="90" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
				Riktig Operand- type</p>
			</th>
			<th width="330" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
				Beskrivelse</p>
			</th>
			<th width="205" style="border-top: 0.75pt double #808080; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding: 0.05cm"><p class="western">
				Eksempel</p>
			</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">@&gt;</code></p>
			</td>
			<td width="90" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">jsonb</code></p>
			</td>
			<td width="330" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Does the left JSON value contain the right JSON path/value
				entries at the top level?</p>
			</td>
			<td width="205" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'{&quot;a&quot;:1, &quot;b&quot;:2}'::jsonb
				@&gt; '{&quot;b&quot;:2}'::jsonb</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">&lt;@</code></p>
			</td>
			<td width="90" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">jsonb</code></p>
			</td>
			<td width="330" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Are the left JSON path/value entries contained at the top level
				within the right JSON value?</p>
			</td>
			<td width="205" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'{&quot;b&quot;:2}'::jsonb &lt;@ '{&quot;a&quot;:1,
				&quot;b&quot;:2}'::jsonb</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">?</code></p>
			</td>
			<td width="90" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">text</code></p>
			</td>
			<td width="330" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Does the <em>string</em> exist as a top-level key within the JSON
				value?</p>
			</td>
			<td width="205" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'{&quot;a&quot;:1, &quot;b&quot;:2}'::jsonb
				? 'b'</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">?|</code></p>
			</td>
			<td width="90" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">text[]</code></p>
			</td>
			<td width="330" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Do any of these array <em>strings</em> exist as top-level keys?</p>
			</td>
			<td width="205" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'{&quot;a&quot;:1, &quot;b&quot;:2,
				&quot;c&quot;:3}'::jsonb ?| array['b', 'c']</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">?&amp;</code></p>
			</td>
			<td width="90" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">text[]</code></p>
			</td>
			<td width="330" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Do all of these array <em>strings</em> exist as top-level keys?</p>
			</td>
			<td width="205" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'[&quot;a&quot;, &quot;b&quot;]'::jsonb ?&amp;
				array['a', 'b']</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">||</code></p>
			</td>
			<td width="90" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">jsonb</code></p>
			</td>
			<td width="330" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Concatenate two <code class="western">jsonb</code> values into a
				new <code class="western">jsonb</code> value</p>
			</td>
			<td width="205" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'[&quot;a&quot;, &quot;b&quot;]'::jsonb ||
				'[&quot;c&quot;, &quot;d&quot;]'::jsonb</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">-</code></p>
			</td>
			<td width="90" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">text</code></p>
			</td>
			<td width="330" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Delete key/value pair or <em>string</em> element from left
				operand. Key/value pairs are matched based on their key value.</p>
			</td>
			<td width="205" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'{&quot;a&quot;: &quot;b&quot;}'::jsonb -
				'a'</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">-</code></p>
			</td>
			<td width="90" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">text[]</code></p>
			</td>
			<td width="330" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Delete multiple key/value pairs or <em>string</em> elements from
				left operand. Key/value pairs are matched based on their key
				value.</p>
			</td>
			<td width="205" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'{&quot;a&quot;: &quot;b&quot;, &quot;c&quot;:
				&quot;d&quot;}'::jsonb - '{a,c}'::text[]</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 1px double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">-</code></p>
			</td>
			<td width="90" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">integer</code></p>
			</td>
			<td width="330" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Delete the array element with specified index (Negative integers
				count from the end). Throws an error if top level container is
				not an array.</p>
			</td>
			<td width="205" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'[&quot;a&quot;, &quot;b&quot;]'::jsonb - 1</code></p>
			</td>
		</tr>
		<tr>
			<td width="64" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 0.75pt double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">#-</code></p>
			</td>
			<td width="90" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">text[]</code></p>
			</td>
			<td width="330" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				Delete the field or element with specified path (for JSON arrays,
				negative integers count from the end)</p>
			</td>
			<td width="205" style="border-top: none; border-bottom: 0.75pt double #808080; border-left: 1px double #808080; border-right: 0.75pt double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p class="western">
				<code class="western">'[&quot;a&quot;, {&quot;b&quot;:1}]'::jsonb
				#- '{1,b}'</code></p>
			</td>
		</tr>
	</tbody>
</table>
<p class="western"><br/>
<br/>

</p>
<p class="western">Vi kan f.eks. bruke <b>iskrem-tegnet</b> (<b>@&gt;</b>)
til &aring; s&oslash;ke i topp-elementene i JSONB-felt slik:</p>
<pre class="western">SELECT innlegg-&gt;'body' AS bloggtekst FROM blogg 
WHERE innlegg @&gt; '{&quot;tittel&quot;:&quot;Enda et nytt blogginnlegg&quot;}'; &nbsp;<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bloggtekst &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
-------------------------------------------------- <br/>
&quot;Dette er teksten til enda et nytt blogginnlegg&quot;</pre><p class="merk">
<b>Merk: </b><span style="font-weight: normal">Tegnet</span><b> @&gt;</b><span style="font-weight: normal">
kan her tolkes som: </span><b>&laquo;inneholder JSON-element&raquo;</b></p>
<p class="ressurs">PostgreSQL har en lang liste med <b>funksjoner for
&aring; konvertere til og fra JSON og JSONB.</b> Her er en lenke til
dokumentasjonen for versjon 10:
<a href="https://www.postgresql.org/docs/10/static/functions-json.html">https://www.postgresql.org/docs/10/static/functions-json.html</a></p>
<p class="western">Vi kan for eksempel hente ut de enkelte elementene
i et JSONB-array med funksjonen  jsonb_array_elements(), slik:</p>
<pre class="western">select <b>jsonb_array_elements(kommentarer)</b> as kommentarer from blogg where id=2; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kommentarer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
------------------------------------------------------------ <br/>
{&quot;id&quot;: 1, &quot;kommentar&quot;: &quot;Dette er teksten til kommentar 1&quot;} <br/>
{&quot;id&quot;: 2, &quot;kommentar&quot;: &quot;Dette er teksten til kommentar 2&quot;}</pre><p class="western">
Hvis vi kun vil ha kommentar-teksene, kan vi hente dem slik:</p>
<pre class="western">select <b>jsonb_array_elements(kommentarer)-&gt;'kommentar' </b>as kommentarer from blogg where id=2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kommentarer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
------------------------------------ <br/>
&quot;Dette er teksten til kommentar 1&quot; <br/>
&quot;Dette er teksten til kommentar 2&quot;</pre><p class="western">
<br/>
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc25221_2723464228"></a><strong><font color="#1b75bc">&#61609;
</font></strong>XML</h2>
<h3 class="western"><a name="__RefHeading___Toc25223_2723464228"></a>XML
med MS SQL Server</h3>
<p class="western">SQL Server har relativt god st&oslash;tte for XML.
Vi kan for eksempel hente ut data fra en tabell formatert som XML med
n&oslash;kkelordene: <i><b>FOR XML </b></i><span style="font-style: normal"><span style="font-weight: normal">etterfulgt
av ett av disse valgene:</span></span><i><b> </b></i><i><b>RAW, AUTO,
EXPLICIT</b></i> eller <i><b>PATH. </b></i>
</p>
<p class="western" style="font-style: normal; font-weight: normal"><b>RAW</b>
produserer et enkelt &lt;row&gt;-element per rad i tabellen som
SELECT-setningen returnerer.</p>
<p class="western"><b>AUTO</b> n&oslash;ster hierarkiske data i
resultat-tabellen til XML ut fra spesifikasjonene i SELECT-setningen.
Med dette valget har man minimalt med kontroll over hvordan
XML-dokumentet blir seende ut. 
</p>
<p class="western"><b>EXPLICIT</b> gir mer kontroll over
XML-resultatet. Man kan f.eks. blande attributter og elementer etter
&oslash;nske, n&oslash;ste komplekse egenskaper mm. Dette er
imidlertid ogs&aring; det mest krevende valget &aring; bruke.</p>
<p class="western"><b>PATH</b> sammen med n&oslash;stede FOR XML
-sp&oslash;rringer gir fleksibilitetetn til EXPLICIT, men er enklere
&aring; bruke. 
</p>
<p class="western" style="font-style: normal; font-weight: normal">Under
er et par eksempler med bruk av FOR XML PATH</p>
<h4 class="western" style="font-weight: normal"><a name="__RefHeading___Toc25225_2723464228"></a>
FOR XML PATH</h4>
<p class="western" style="font-weight: normal">SQL-setningen nedenfor
bruker FOR XML PATH til &aring; hente ut ansattnummer, fornavn,
etternavn og kj&oslash;nn til de ansatte (begrenset til de 2 f&oslash;rste
radene med TOP 2) og gir resultatet formatert med et element &lt;ansatt&gt;
for hver ansatt, emp_no som attributt og de andre feltene som
elementer - og med alle ansatte satt under et rot-element: &lt;ansatte&gt;:</p>
<pre class="western">SELECT TOP 2 
emp_no '@emp_no', first_name, last_name, gender 
FROM employees
<b>FOR XML PATH('ansatt'), root('ansatte');</b></pre><p class="western">
Vi bruker et alias som starter med en @ for  angi at denne kolonnen
skal skrives som et attributt, og ikke et element i XML-dokumentet.
Ved &aring; sette en tekst (her: &rsquo;ansatt&rsquo;) inne i
parentesen etter PATH, f&aring;r hvert element i dokumentet (dvs.
hver rad fra tabellen) navnet ansatt, og ved &aring; sette teksten
&rsquo;ansatte&rsquo; i parentesen etter n&oslash;kkelordet root,
settes det et element med navn ansatte som et rot-element rundt alle
elementene, slik at sluttresultatet blir et gyldig XML-dokument.</p>
<p class="western">Slik vil resultatet av setningen over se ut:</p>
<pre class="western"><strong><span style="font-weight: normal">&lt;ansatte&gt;</span></strong>
	&lt;ansatt emp_no=&quot;10001&quot;&gt;
		&lt;first_name&gt;Georgi&lt;/first_name&gt;
		&lt;last_name&gt;Facello&lt;/last_name&gt;
		&lt;gender&gt;M&lt;/gender&gt;
	&lt;/ansatt&gt;
	&lt;ansatt emp_no=&quot;10002&quot;&gt;
		&lt;first_name&gt;Bezalel&lt;/first_name&gt;
		&lt;last_name&gt;Simmel&lt;/last_name&gt;
		&lt;gender&gt;F&lt;/gender&gt;
		&lt;/ansatt&gt;
&lt;/ansatte&gt;</pre><p class="western">
Her er en litt mer kompleks sp&oslash;rring, med en undersp&oslash;rring
som ogs&aring; henter ut l&oslash;nnshistorikken for hver ansatt:</p>
<pre class="western">SELECT top 2 emp_no '@emp_no', first_name,last_name,gender,
 
(select year(to_date) as '@year', salary as '@salary' FROM salaries 
WHERE emp_no = employees.emp_no <b>FOR</b><b> XML PATH('salaries'), TYPE</b>)

FROM employees 
<b>FOR</b><b> XML PATH('ansatt'), root('ansatte')</b>;</pre><p class="western">
Setningen over gir dette resultatet:</p>
<pre class="western">&lt;ansatte&gt;
	&lt;ansatt emp_no=&quot;10001&quot;&gt;
		&lt;first_name&gt;Georgi&lt;/first_name&gt;
		&lt;last_name&gt;Facello&lt;/last_name&gt;
		&lt;gender&gt;M&lt;/gender&gt;
		&lt;salaries year=&quot;1987&quot; salary=&quot;60117&quot;/&gt;
		&lt;salaries year=&quot;1988&quot; salary=&quot;62102&quot;/&gt;
		&lt;salaries year=&quot;1989&quot; salary=&quot;66074&quot;/&gt;
		&lt;salaries year=&quot;1990&quot; salary=&quot;66596&quot;/&gt;
		&lt;salaries year=&quot;1991&quot; salary=&quot;66961&quot;/&gt;
		&lt;salaries year=&quot;1992&quot; salary=&quot;71046&quot;/&gt;
		&lt;salaries year=&quot;1993&quot; salary=&quot;74333&quot;/&gt;
		&lt;salaries year=&quot;1994&quot; salary=&quot;75286&quot;/&gt;
		&lt;salaries year=&quot;1995&quot; salary=&quot;75994&quot;/&gt;
		&lt;salaries year=&quot;1996&quot; salary=&quot;76884&quot;/&gt;
		&lt;salaries year=&quot;1997&quot; salary=&quot;80013&quot;/&gt;
		&lt;salaries year=&quot;1998&quot; salary=&quot;81025&quot;/&gt;
		&lt;salaries year=&quot;1999&quot; salary=&quot;81097&quot;/&gt;
		&lt;salaries year=&quot;2000&quot; salary=&quot;84917&quot;/&gt;
		&lt;salaries year=&quot;2001&quot; salary=&quot;85112&quot;/&gt;
		&lt;salaries year=&quot;2002&quot; salary=&quot;85097&quot;/&gt;
		&lt;salaries year=&quot;9999&quot; salary=&quot;88958&quot;/&gt;
	&lt;/ansatt&gt;
	&lt;ansatt emp_no=&quot;10002&quot;&gt;
		&lt;first_name&gt;Bezalel&lt;/first_name&gt;
		&lt;last_name&gt;Simmel&lt;/last_name&gt;
		&lt;gender&gt;F&lt;/gender&gt;
		&lt;salaries year=&quot;1997&quot; salary=&quot;65828&quot;/&gt;
		&lt;salaries year=&quot;1998&quot; salary=&quot;65909&quot;/&gt;
		&lt;salaries year=&quot;1999&quot; salary=&quot;67534&quot;/&gt;
		&lt;salaries year=&quot;2000&quot; salary=&quot;69366&quot;/&gt;
		&lt;salaries year=&quot;2001&quot; salary=&quot;71963&quot;/&gt;
		&lt;salaries year=&quot;9999&quot; salary=&quot;72527&quot;/&gt;
	&lt;/ansatt&gt;
&lt;/ansatte&gt;</pre><p class="western">
Vi brukte n&oslash;kkelordet TYPE i undersp&oslash;rringen for &aring;
angi at salaries skal listes som underelementer under elementet
ansatt. 
</p>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc25546_4206096343"></a>
<font size="6" style="font-size: 24pt">Kapittel 15</font><br/>
Geometriske
og Geografiske data</h1>
<h2 class="western"><a name="__RefHeading___Toc25548_4206096343"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Geometriske datatyper</h2>
<p class="western">Alle de 4 RDBMSene som omfattes av denne boken har
st&oslash;tte for h&aring;ndtering av geografiske og geometriske
data. Dette gj&oslash;res gjennom at data for et spatialt omr&aring;de
legges inn med lengde- og breddegrad og f.eks. defineres som et
punkt, en linje eller et polygon</p>
<p class="western">Hvis data er definert som et punkt, kan man s&oslash;ke
opp data som ligger innenfor eller utenfor en bestemt radius fra
punktet, f.eks. som svar p&aring; problemstillingen: &laquo;Finn
pizzarestauranter som ligger innenfor 300 meter fra der jeg st&aring;r
n&aring;&raquo;. Data definert som et polygon kan inneholde
koordinatene til bydel Gr&uuml;nerl&oslash;kka i Oslo, og s&aring;
kan man s&oslash;ke opp alle skobutikker som ligger i den bydelen, og
data definert som en multilinje kan inneholde koordinatene til Ring 3
&ndash; slik at vi kan finne veier som krysser Ring 3, som ligger s&oslash;r
eller nord for Ring 3 osv.</p>
<p class="western">Her er litt om hvordan &laquo;de fire store&raquo;
takler slike problemstillinger:</p>
<h3 class="western"><a name="__RefHeading___Toc25550_4206096343"></a>Geografiske
og geometriske data med MS SQL Server</h3>
<p class="western">Microsoft SQL Server skiller mellom to
hoved-datatyper for stedsanvisninger: Geografiske og Geometriske. 
</p>
<p class="western"><strong><span style="font-weight: normal">Datatypen
</span></strong><strong>geometry</strong> brukes til &aring;
representere data i et Euclidisk (flatt) koordinatsystem.</p>
<ul>
	<li><p class="western">Datatypen <strong>geography</strong> brukes
	til &aring; representere data i et jordklode-koordinatsystem.</p>
</ul>
<p class="western">Begge datatypene er implementert som .NET <i><b>common
language runtime (CLR)</b></i> datatyper i MS SQL Server.</p>
<p class="western" style="page-break-before: always">MS SQL Server
deler inn spatiale data i f&oslash;lgende undertyper:</p>
<ul>
	<li><p class="western">Point</p>
	<li><p class="western">LineString</p>
	<li><p class="western">CircularString</p>
	<li><p class="western">CompoundCurve</p>
	<li><p class="western">Polygon</p>
	<li><p class="western">CurvePolygon</p>
	<li><p class="western">MultiPoint</p>
	<li><p class="western">MultiLineString</p>
	<li><p class="western">MultiPolygon</p>
	<li><p class="western">GeometryCollection</p>
</ul>
<p class="western"><br/>
<br/>

</p>
<h4 class="western"><a name="__RefHeading___Toc25552_4206096343"></a>Datatypen
Geography</h4>
<p class="western">Datatypen <strong>geography</strong> er
predefinert og tilgjengelig for alle databaser. Man kan opprette
kolonner med datatype <strong>geography</strong> og legge inn og
hente frem <strong><span style="font-weight: normal">geografiske</span></strong>
data p&aring; samme m&aring;te som med andre datatyper.</p>
<p class="western">Her er et eksempel p&aring; hvordan et punkt
(point) kan brukes innenfor geografi og geometri (sakset fra
Microsofts dokumentasjon til SQL Server) :</p>
<h4 class="western"><a name="__RefHeading___Toc25554_4206096343"></a><a name="geography-data-type"></a>
Point Geography Data Type</h4>
<p class="western">The Point type for the geography data type
represents a single location where <em>Lat</em> represents latitude
and <em>Long</em> represents longitude. The values for latitude and
longitude are measured in degrees. Values for latitude always lie in
the interval [-90, 90], and values that are inputted outside this
range will throw an exception. Values for longitude always lie in the
interval (-180, 180], and values inputted outside this range are
wrapped around to fit in this range. For example, if 190 is inputted
for longitude, then it will be wrapped to the value -170. <em>SRID</em>
represents the spatial reference ID of the <strong>geography</strong>
instance that you wish to return.</p>
<h4 class="western"><a name="__RefHeading___Toc25556_4206096343"></a><a name="geometry-data-type"></a>
Point Geometry Data Type</h4>
<p class="western">The Point type for the geometry data type
represents a single location where <em>X</em> represents the
X-coordinate of the Point being generated and <em>Y</em> represents
the Y-coordinate of the Point being generated. <em>SRID</em>
represents the spatial reference ID of the <strong>geometry</strong>
instance that you wish to return.</p>
<h3 class="western"><a name="__RefHeading___Toc25558_4206096343"></a>Eksempler</h3>
<p class="western">I det f&oslash;rste eksemplet nedenfor oppretter
vi en tabell med en identity-kolonne og en kolonne med datatypen
<code class="western"><font face="Liberation Serif, serif">geography:</font></code>
<code class="western"><font face="Liberation Serif, serif">GeogCol1</font></code><font face="Liberation Serif, serif">.</font>
En tredje kolonne omdanner <code class="western"><font face="Liberation Serif, serif">geography-kolonnen
ti</font></code><code class="western"><font face="Liberation Serif, serif">l
dens</font></code> <b>Open Geospatial Consortium (OGC) Well-Known
Text (WKT) - </b>representasjon, og bruker mtoden <code class="western"><font face="Liberation Serif, serif"><b>STAsText()</b></font></code>.
To rader settes s&aring; inn i tabellen: en rad inneholder en 
<code class="western"><font face="Liberation Serif, serif"><i><b>LineString</b></i></font></code>
undertype av <code class="western"><font face="Liberation Serif, serif">geography</font></code>,
og den andre raden inneholder undertypen <code class="western"><font face="Liberation Serif, serif"><i><b>Polygon</b></i></font></code>.</p>
<pre class="western"><code class="western">CREATE TABLE SpatialTable   </code>
<code class="western">    </code><code class="western">( id int IDENTITY (1,1),  </code>
<code class="western">    </code><code class="western">GeogCol1 geography,   </code>
<code class="western">    </code><code class="western">GeogCol2 AS GeogCol1.STAsText() );  </code>
<code class="western">GO  </code>
<code class="western">  </code>
<code class="western">INSERT INTO SpatialTable (GeogCol1)  </code>
<code class="western">VALUES (geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326));  </code>
<code class="western">  </code>
<code class="western">INSERT INTO SpatialTable (GeogCol1)  </code>
<code class="western">VALUES (geography::STGeomFromText('POLYGON((-122.358 47.653 , -122.348 47.649, -122.348 47.658, -122.358 47.658, -122.358 47.653))', 4326));  </code>
<code class="western">GO  </code></pre><p class="western">
Eksemplet nedenfor bruker metoden  <code class="western"><font face="Liberation Serif, serif"><b>STIntersection()</b></font></code><font face="Liberation Serif, serif"><b>
</b></font>for &aring; hente punktene hvor de to geografiske feltene
krysser hverandre.</p>
<pre class="western"><code class="western">DECLARE @geog1 geography;  </code>
<code class="western">DECLARE @geog2 geography;  </code>
<code class="western">DECLARE @result geography;  </code>
<code class="western">  </code>
<code class="western">SELECT @geog1 = GeogCol1 FROM SpatialTable WHERE id = 1;  </code>
<code class="western">SELECT @geog2 = GeogCol1 FROM SpatialTable WHERE id = 2;  </code>
<code class="western">SELECT @result = @geog1.STIntersection(@geog2);  </code>
<code class="western">SELECT @result.STAsText();  </code>

<code class="western"><b>Resultat:</b></code>

<code class="western">LINESTRING (-122.35800000000017 47.656000130337446, -122.34800000000006 47.656000260674908)</code></pre><h3 class="western">
<a name="__RefHeading___Toc25765_1131955894"></a>Eksempel 2 &ndash;
byer som punkter</h3>
<p class="western">I det neste eksemplet lager vi en enkel tabell
hvor noen norske byer legges inn med navn og sted - som punkter med
lengde- og breddekoordinater, og s&aring; regner vi ut avstanden
mellom dem.</p>
<pre class="western">create table geotest (
id int primary key identity,
navn nvarchar(20),
sted geography,
sted_tekst AS sted.STAsText() 
);

insert into geotest (navn, sted) values 
('Oslo',geography::Parse('POINT(59.911491 10.757933)')),
('Sarpsborg',geography::Parse('POINT(59.284073 11.10940)')),
('Stavanger',geography::Parse('POINT(58.969975 5.733107)')),
('Troms&oslash;',geography::Parse('POINT(69.650253 18.995115)'));

select * from geotest;

<b>Resultat:</b>

<font size="1" style="font-size: 6pt"><b>id	navn	sted					 sted_tekst</b></font>
<font size="1" style="font-size: 6pt">1	Oslo	0xE6100000010C4B1E4FCB0F84254096CCB1BCABF44D40	 POINT (59.911491 10.757933)</font>
<font size="1" style="font-size: 6pt">2	Sarpsborg	0xE6100000010C645DDC46033826409B560A815CA44D40	 POINT (59.284073 11.1094)</font>
<font size="1" style="font-size: 6pt">3	Stavanger	0xE6100000010CECDFF599B3EE164003780B24287C4D40	 POINT (58.969975 5.733107)</font>
<font size="1" style="font-size: 6pt">4	Troms&oslash;	0xE6100000010C50C24CDBBFFE32400F48C2BE9D695140	 POINT (69.650253 18.995115)</font>

go

declare @o geography;
declare @s geography;
set @o = (select sted from geotest where navn='Oslo');
set @s = (select sted from geotest where navn='Sarpsborg');
Select @o.STDistance(@s) as avstand;

go

<b>Resultat:</b>

<font size="2" style="font-size: 9pt"><b>avstand</b></font>
<font size="2" style="font-size: 9pt">78836,6946764731</font></pre><p class="western">
Som vi ser er det ca. 79 kilometer fra Oslo til Sarpsborg &ndash; i
luftlinje.</p>
<h3 class="western"><a name="__RefHeading___Toc26111_1526864018"></a>Oversikt
over OGC-metoder som st&oslash;ttes av SQL Server</h3>
<p class="western">Microsoft SQL Server st&oslash;tter disse metodene
fra OGC (Open Geospatial Consortium) :</p>
<ul>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/starea-geography-data-type?view=sql-server-2017">STArea</a></p>
</ul>
<ul>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stasbinary-geography-data-type?view=sql-server-2017">STAsBinary</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stastext-geography-data-type?view=sql-server-2017">STAsText</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stbuffer-geography-data-type?view=sql-server-2017">STBuffer</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stcurven-geography-data-type?view=sql-server-2017">STCurveN
	(geography Data Type)</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stcurvetoline-geography-data-type?view=sql-server-2017">STCurveToLine
	(geography Data Type)</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stdifference-geography-data-type?view=sql-server-2017">STDifference</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stdimension-geography-data-type?view=sql-server-2017">STDimension</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stdisjoint-geography-data-type?view=sql-server-2017">STDisjoint</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stdistance-geography-data-type?view=sql-server-2017">STDistance</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stendpoint-geography-data-type?view=sql-server-2017">STEndpoint</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stequals-geography-data-type?view=sql-server-2017">STEquals</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stgeometryn-geography-data-type?view=sql-server-2017">STGeometryN</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stgeometrytype-geography-data-type?view=sql-server-2017">STGeometryType</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stintersection-geography-data-type?view=sql-server-2017">STIntersection</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stintersects-geography-data-type?view=sql-server-2017">STIntersects</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stisclosed-geography-data-type?view=sql-server-2017">STIsClosed</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stisempty-geography-data-type?view=sql-server-2017">STIsEmpty</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stisvalid-geography-data-type?view=sql-server-2017">STIsValida</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stlength-geography-data-type?view=sql-server-2017">STLength</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stnumcurves-geography-data-type?view=sql-server-2017">STNumCurves
	(geography Data Type)</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stnumgeometries-geography-data-type?view=sql-server-2017">STNumGeometries</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stnumpoints-geography-data-type?view=sql-server-2017">STNumPoints</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stpointn-geography-data-type?view=sql-server-2017">STPointN</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stsrid-geography-data-type?view=sql-server-2017">STSrid</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/ststartpoint-geography-data-type?view=sql-server-2017">STStartPoint</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stsymdifference-geography-data-type?view=sql-server-2017">STSymDifference</a></p>
	<li><p class="western"><a href="https://docs.microsoft.com/en-us/sql/t-sql/spatial-geography/stunion-geography-data-type?view=sql-server-2017">STUnion</a></p>
</ul>
<p class="western"><a name="see-also"></a><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<h1 class="western" align="center" style="page-break-before: always"><a name="__RefHeading___Toc14069_140935937"></a>
<font size="7" style="font-size: 36pt">D</font><font size="7" style="font-size: 36pt">el</font><font size="7" style="font-size: 36pt">
2<br/>
</font>Distribuerte Databaser<br/>
<br/>
<br/>
<br/>

</h1>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc18260_1557834486"></a>
<font size="6" style="font-size: 24pt">Kapittel 1</font><font size="6" style="font-size: 24pt">6</font><br/>
Introduksjon
til <br/>
Distribuerte databaser</h1>
<h2 class="western"><a name="__RefHeading___Toc18262_1557834486"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Hva er distribuerte databaser?</h2>
<p class="western">Relasjonelle databaser har tradisjonelt hatt en
hovedbegrensning: Programvare og data lever p&aring; en og bare en
server. Det betyr at man m&aring; <b>skalere opp </b><span style="font-weight: normal">n&aring;r
det begynner &aring; ga tregt, dvs. bruke mer minne, raskere
prosessor, raskere disk osv. Det betyr ogs&aring; at man til slutt
n&aring;r et tak, hvor det enten blir uforholdsmessig dyrt eller
fysisk umulig &aring; skalere videre. </span>
</p>
<p class="western"><span style="font-weight: normal">Med distribuerte
databaser lever b&aring;de progamvaren og data p&aring; flere servere
som kommuniserer med hverandre. Det vil si at man kan </span><b>skalere
ut, </b><span style="font-weight: normal">dvs. legge til en server
til (eller to) n&aring;r det begynner &aring; g&aring; tregt, eller
det rett og slett ikke er plass til data p&aring; en harddisk. Man
drar nytte av alle servernes minne og prosessorkraft og data splittes
opp - &laquo;shardes&raquo; - slik at de kan lagres over flere
maskiner, og man kan dermed h&aring;ndtere databaser p&aring;
petabyte-niv&aring;. </span>
</p>
<p class="western"><span style="font-weight: normal">Det er en mengde
egne problemstillinger knyttet til distribuerte database, og blant
annet har det v&aelig;rt vanskelig &aring; implementere
relasjonsmodellen, slik at f.eks. avanserte joins mellom mange
tabeller har v&aelig;rt enten umulig eller tatt uforholdsmessig lag
tid. </span><span style="font-weight: normal">Men dette er i ferd med
&aring; bedre seg, og vi skal se p&aring; noen teknologier som er i
ferd med &aring; etablere seg som sterke kandidater for distribuerte
databaser hvor man ogs&aring; kan bruke SQL.</span></p>
<h2 class="western"><a name="__RefHeading___Toc8276_1995625076"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Hva er NoSQL?</h2>
<p class="western">NoSQL var opprinnelig et uttrykk som beskrev en
gruppe distribuerte databaser som ikke brukte relasjonsmodellen og
ikke hadde st&oslash;tte for SQL. Relasjonsmodellen ble laget p&aring;
en tid hvor to forutsetninger var f&oslash;rende: 1) Datalagring var
dyrt og 2) Dobbeltlagring var en sannsynlig feilkilde. I dag er
lagring billig, og man taster sjelden inn data manuelt, slik at det
er liten eller ingen &oslash;kning i antall feil om man lagrer data
ett eller 20 steder. 
</p>
<p class="western">NoSQL-databaser skiller seg klart fra relasjonelle
databaser ved at data lagres flere ganger. Istedenfor &aring;
strukturere en database etter relasjonsmodellen, og s&aring; kunne
bruke den til alle typer s&oslash;k (selv om kanskje noen s&oslash;k
g&aring;r veldig tregt), strukturerer man heller databasen med en
tabell for hver type s&oslash;k. Dette inneb&aelig;rer en helt annen
m&aring;te &aring; tenke database p&aring; &ndash; man definerer
f&oslash;rst hvilke s&oslash;k som databasen skal st&oslash;tte, og
s&aring; lager man tabeller tilpasset disse s&oslash;kene. Endrer
s&oslash;kem&oslash;nstret seg, endrer man tabellene. Det er dermed
ikke uvanlig at samme data lagres 10-20 ganger i ulike tabeller
tilpasset ulike s&oslash;k. En av fordelene med denne typen
&laquo;denormale&raquo; databaser er at man unng&aring;r kostbare
joins. 
</p>
<p class="western">Med distribuerte databaser blir gevinsten enda
st&oslash;rre, siden distribuering som regel inneb&aelig;rer at
lesing av data er mer kostbart (tar lenger tid) enn skriving av data.
Det er ganske enkelt fordi data gjerne lagres p&aring; &eacute;n node
i klyngen, som s&aring; replikerer over til andre noder, mens ved
lesing kan det hende at data er splittet over flere noder, slik at et
s&oslash;k, og ikke minst en join, ofte m&aring; hente data fra en
rekke ulike servere og sette dem sammen til et s&oslash;keresultat.
Det krever netttrafikk og koordinering, som tar tid og ressurser. 
</p>
<p class="western"><br/>
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc6095_317907475"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Brewers CAP-teorem</h2>
<p class="western"><a name="__RefHeading___Toc6551_841703319"></a>Eric
Brewer lanserte sitt CAP-teorem i 2000, mens han arbeidet ved
Berkeley. Teoremet postulerer at innenfor et stort, distribuert
datasystem vil det v&aelig;re tre betingelser med et glidende
avhengighetsforhold: <b>Konsistens</b>, <b>Tilgjengelighet</b> og
<b>Partisjons-toleranse</b>.</p>
<h3 class="western"><a name="__RefHeading___Toc4523_762629072"></a>Konsistens</h3>
<p class="western">Alle databasens klienter vil f&aring; tilbake
samme verdi for samme sp&oslash;rring, selv med samtidige
oppdateringer</p>
<h3 class="western"><a name="__RefHeading___Toc4525_762629072"></a>Tilgjengelighet</h3>
<p class="western">Alle databasens klienter vil alltid v&aelig;re i
stand til &aring; lese og skrive data.</p>
<h3 class="western"><a name="__RefHeading___Toc4527_762629072"></a>Partisjons-toleranse</h3>
<p class="western">Databasen kan deles over flere maskiner og den kan
fortsette &aring; fungere selv om nettverket bryter sammen. Brewers
teorem sier at <strong>i et gitt system kan man bare ha full st&oslash;tte
for to av disse tre</strong>. Dette er p&aring; en m&aring;te analogt
til det man av og til h&oslash;rer innen programvareutvikling:&ldquo;Du
kan f&aring; den med god kvalitet, du kan f&aring; den rask, du kan
f&aring; den billig: velg to.&rdquo; Vi m&aring; velge mellom dem p&aring;
grunn av denne glidende gjensidige utelukkingen. Jo mer konsistent et
system m&aring; v&aelig;re, for eksempel, jo mindre
partisjons-tolerant vil det antagelig v&aelig;re, hvis man ikke
minsker kravene til tilgjengeligheten.</p>
<p class="western">CAP-teoremet ble formelt bevist av Seth Gilbert og
Nancy Lynch ved MIT i 2002. N&aring;r det gjelder distribuerte
systemer, er det imidlertid sannsynlig at man vil ha
nettverks-partisjonering og at maskiner vil feile p&aring; et
tidspunkt slik at andre maskiner blir utilgjengelige. Tap av
datapakker er ogs&aring; tiln&aelig;rmet uung&aring;elig. Dermed blir
konklusjonen at et distribuert system m&aring; tilstrebe &aring; v&aelig;re
Partisjons-tolerant - dvs, fortsette &aring; fungere ved
nettverksfeil. Og det gj&oslash;r at vi i realiteten bare har to ting
&aring; velge mellom: Tilgjengelighet og Konsistens.</p>
<p class="western"><img src="Introduksjon_til_SQL_html_310bb9eb599a123b.jpg" name="Bilde1" align="left" width="676" height="498" border="0"/>
<br/>
<br/>

</p>
<p class="western">Relasjonelle databaser befinner seg et sted p&aring;
linjen mellom Konsistens og Tilgjengelighet - noe som betyr at de kan
feile hvis nettverket bryter sammen (inkludert hvis en kabel
&oslash;delegges). Dette oppn&aring;s typisk ved &aring; definere en
enkel master server, eller et array av servere som i seg selv ikke
har tilstrekkelige innebygde mekanismer for &aring; fortsette &aring;
fungere hvis nettverket brytes opp.</p>
<p class="western">Grafiske databaser, som f.eks. Neo4J og databaser
avledet (i det minste delvis) fra designet til Googles Bigtable
database (slik som MongoDB, HBase, Hypertable og Redis) har alle mer
fokus p&aring; Konsistens og Partisjons-toleranse og noe mindre p&aring;
Tilgjengelighet.<br/>
<br/>
Til slutt har vi databaser som er avledet
av designet til Amazons Dynamo, inkludert Cassandra, Project
Voldemort, CouchDB og Riak. Disse har mer fokus p&aring;
Tilgjengelighet og Partisjons-toleranse og noe mindre p&aring;
Konsistens. 
</p>
<h2 class="western"><a name="__RefHeading___Toc4529_762629072"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Hva betyr dette i praksis?</h2>
<p class="western"><strong>A. Man befinner seg langs aksen Konsistens
og Tilgjengelighet (KT, eller CA)</strong><br/>
St&oslash;tter
databasen prim&aelig;rt Konsistens og Tilgjengelighet, betyr det man
mest sannsynlig brukes en to-trinns skrivemetode (two-phase commit)
for distribuerte transaksjoner. Det betyr at systemet vil hindre at
en nettverks-partisjonering inntreffer, og for &aring; f&aring; til
dette kan systemet bli begrenset til en enkelt datasenter-klynge.
Hvis databasens applikasjoner klarer seg med dette skaleringsniv&aring;et,
er dette relativt enkelt &aring; h&aring;ndtere med kjente
relasjonelle databasesystemer.</p>
<p class="western"><strong>B.</strong> <strong>Man befinner seg langs
aksen Konsistens og Partisjons-toleranse (KP, eller CP)</strong><br/>
For
prim&aelig;rt &aring; st&oslash;tte Konsistens og
Partisjons-toleranse kan arkitekturen videreutvikles til &aring;
skalere ved &aring; sette opp data shards. Data vil v&aelig;re
konsistente, men man har fremdeles en risiko for at noen data blir
utilgjengelige hvis noder i nettverket g&aring;r ned.</p>
<p class="western"><strong>C.</strong> <strong>Man befinner seg langs
aksen Tilgjengelighet og Partisjons-toleranse (TP, eller AP)</strong><br/>
Hvis
systemet prim&aelig;rt st&oslash;tter Tilgjengelighet og
Partisjons-toleranse, kan systemet returnere un&oslash;yaktige data,
men det vil alltid v&aelig;re tilgjengelig, selv hvis
nettverks-partisjonering inntreffer. DNS er kanskje det mest popul&aelig;re
eksemplet p&aring; et system som er massivt skalerbart,&nbsp; har h&oslash;y
tilgjengelighet og er partisjons-tolerant.</p>
<h2 class="western"><a name="__RefHeading___Toc18076_1687682778"></a><strong><font color="#1b75bc">&#61609;</font></strong>
BASE erstatter ACID</h2>
<p class="western"><a name="__RefHeading___Toc18078_1687682778"></a>Det
er problematisk &aring; f&aring; en distribuert database til &aring;
oppfylle ACID-kravene (ref. Kapittel 1). Derfor har mange
distribuerte databaser heller tatt sikte p&aring; &aring; oppfylle
kravene i BASE-akronymet. 
</p>
<p class="western"><a name="__RefHeading___Toc20588_588350667"></a>BASE
st&aring;r for dette:</p>
<p class="western"><a name="__RefHeading___Toc20590_588350667"></a><strong>Basic
Availability</strong>. Dette fokuserer p&aring; tilgjengeligheten av
data, selv ved feil i flere ledd. Tilgjengeligheten oppn&aring;s ved
&aring; bruke en distribuert tiln&aelig;rming til database
management. Distribuerte databaser sprer data over flere
lagrings-systemer og bruker en h&oslash;y grad av replikering. Hvis
en hard-disk feiler eller en linje g&aring;r ned, vil dermed sjansen
minimeres for at data g&aring;r tapt eller blir utilgjengelige.</p>
<p class="western"><strong>Soft State</strong>. BASE databases
abandon the consistency requirements of the ACID model pretty much
completely. One of the basic concepts behind BASE is that data
consistency is the developer's problem and should not be handled by
the database.</p>
<p class="western"><strong>Eventual Consistency</strong>. The only
requirement that NoSQL databases have regarding consistency is to
require that at some point in the future, data will converge to a
consistent state. No guarantees are made, however, about when this
will occur. That is a complete departure from the immediate
consistency requirement of ACID that prohibits a transaction from
executing until the prior transaction has completed and the database
has converged to a consistent state.</p>
<p class="western">The BASE model isn't appropriate for every
situation, but it is certainly a flexible alternative to the ACID
model for databases that don't require strict adherence to a
relational model.</p>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc13187_1590063026"></a>
<font size="6" style="font-size: 24pt">Kapittel 1</font><font size="6" style="font-size: 24pt">7</font><font size="6" style="font-size: 24pt"><br/>
</font>Apache
Hive og HiveQL</h1>
<h2 class="western"><a name="__RefHeading___Toc13979_140935937"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Apache Hive</h2>
<p class="western"><strong>Apache Hive</strong> ble opprinnelig
utviklet av Facebook for &aring; kunne bruke et SQL-liknende spr&aring;k
til sp&oslash;rringer i store, distribuerte datasett. Hive er med
tiden blitt en defacto standard for distribuerte datavarehus og
brukes n&aring; av en rekke kjente firmaer, fra Facebook, CNET og
Scribd til Netflix og Last.fm. 
</p>
<p class="western">En av spesialitetene til Hive er at
tabellstrukturen ikke m&aring; defineres n&aring;r man lagrer data
(&laquo;schema on write&raquo;), men n&aring;r man leser dem tilbake
(&laquo;schema on read&raquo;). Det vil si at vi kan kj&oslash;re SQL
mot data allerede lagret i f.eks. Komma- eller tabulator-separerte
tekstfiler, s&aring; lenge vi definerer en tabell med en struktur som
tilsvarer de lagrede dataene. Andre popul&aelig;re lagringsformater
som Hive kan h&aring;ndtere er Avro, Parquet og Hbase. 
</p>
<h2 class="western"><a name="__RefHeading___Toc13981_140935937"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Hive QL</h2>
<p class="western"><b>HiveQL</b> ble utviklet hos Facebook for &aring;
gj&oslash;re det enklere for ansatte med SQL-kompetanse &aring; kj&oslash;re
sp&oslash;rringer mot store data lagret i Hadoop-klynger. Til &aring;
begynne med inneholdt HiveQL kun den mest grunnleggende
SQL-syntaksen, men n&aring; er det i praksis ANSI SQL-kompatibelt. De
innebygde funksjonene er laget etter lest av MySQL, med en del ekstra
funksjonalitet, bl.a.  for &aring; h&aring;ndtere distribuerte data
best mulig (f.eks. partisjonering av databaser). 
</p>
<h2 class="western"><a name="__RefHeading___Toc6477_841703319"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Terminalklienten Beeline</h2>
<p class="western">Beeline er en terminalklient for HiveServer2, som
har en rekke forbedringer i forhold til HiveServer, bl.a. st&oslash;tte
for flere samtidige brukere. Beeline er en JDBC-klient som er basert
p&aring; SQLLine CLI (<a href="http://sqlline.sourceforge.net/">http://sqlline.sourceforge.net/</a>).
Det finnes en detaljert <a href="http://sqlline.sourceforge.net/#manual">dokumentasjon</a>
for SQLLine som ogs&aring; gjelder for Beeline.</p>
<p class="western">Vi starter beeline med denne kommandoen fra et
terminalvindu:</p>
<pre class="western"><strong>$ beeline</strong>
<strong><span style="font-weight: normal">Beeline version 0.14.0.2.2.0.0-2041 by Apache Hive</span></strong></pre><p class="western">
Det neste vi m&aring; gj&oslash;re er &aring; koble oss til en
HiveServer2, og det gj&oslash;r vi med denne kommandoen:</p>
<pre class="western"><strong>beeline&gt; !connect jdbc:hive2://localhost:10000 &lt;brukernavn&gt; &lt;passord&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>
<strong><span style="font-weight: normal">scan complete in 4ms</span></strong>
<strong><span style="font-weight: normal">Connecting to jdbc:hive2://localhost:10000</span></strong>
<strong><span style="font-weight: normal">SLF4J: Class path contains multiple SLF4J bindings.</span></strong>
<strong><span style="font-weight: normal">SLF4J: Found binding in [jar:file:/usr/hdp/2.2.0.0-2041/hadoop/lib/slf4j-log4j12-1.7.5.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span></strong>
<strong><span style="font-weight: normal">SLF4J: Found binding in [jar:file:/usr/hdp/2.2.0.0-2041/hive/lib/hive-jdbc-0.14.0.2.2.0.0-2041-standalone.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span></strong>
<strong><span style="font-weight: normal">SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.</span></strong>
<strong><span style="font-weight: normal">SLF4J: Actua l binding is of type [org.slf4j.impl.Log4jLoggerFactory]</span></strong>
<strong><span style="font-weight: normal">Connected to: Apache Hive (version 0.14.0.2.2.0.0-2041)</span></strong>
<strong><span style="font-weight: normal">Driver: Hive JDBC (version 0.14.0.2.2.0.0-2041)</span></strong>
<strong><span style="font-weight: normal">Transaction isolation: TRANSACTION_REPEATABLE_READ</span></strong>
<strong>0: jdbc:hive2://localhost:10000&gt;</strong></pre><p class="merk">
<strong>MERK:</strong> Hvis du vil unng&aring; &aring; ha brukernavn
og passord liggende i historien til skallet, kan du taste inn
kommandoen over uten disse, slik:</p>
<pre class="western" style="margin-top: 0cm; margin-bottom: 0.5cm"><strong>!connect jdbc:hive2://localhost:10000</strong></pre><p class="western">
S&aring; blir du spurt om &aring; taste inn brukernavn og passord.&nbsp;</p>
<p class="merk"><strong>MERK:</strong> Bytt ut localhost med
domenenavn hvis du kobler deg til en annen server</p>
<p class="western">N&aring;r vi er tilkoblet kan vi bruke de samme
kommandoene som i Hive CLI (som ogs&aring; er kjent fra
MySQL-klienten):</p>
<pre class="western">
<strong><span style="font-weight: normal">0: jdbc:hive2://localhost:10000&gt; show tables;&nbsp;</span></strong>

<strong><span style="font-weight: normal">+------------+--+</span></strong>
<strong><span style="font-weight: normal">|&nbsp; tab_name&nbsp; |</span></strong>
<strong><span style="font-weight: normal">+------------+--+</span></strong>
<strong><span style="font-weight: normal">| apachelog&nbsp; |</span></strong>
<strong><span style="font-weight: normal">+------------+--+</span></strong>
<strong><span style="font-weight: normal">1 row selected (0,139 seconds)</span></strong></pre><p class="merk">
<strong>MERK:</strong> show tables viser her tabellene i
default-databasen. Vi kan se alle databasene (gitt at vi har
tilgangsrettigheter til det) med denne kommandoen:</p>
<pre class="western"><strong><br/>
</strong><strong><span style="font-weight: normal">0: jdbc:hive2://localhost:10000&gt; show databases;</span></strong>

<strong><span style="font-weight: normal">+----------------+--+</span></strong>
<strong><span style="font-weight: normal">| database_name&nbsp; |</span></strong>
<strong><span style="font-weight: normal">+----------------+--+</span></strong>
<strong><span style="font-weight: normal">| axenna_dwh&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| terje&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| varehus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">+----------------+--+</span></strong>
<strong><span style="font-weight: normal">4 rows selected (0,035 seconds)</span></strong></pre><p class="western">
For &aring; bruke en annen database, brukes kommandoen&nbsp; <strong>use
&lt;databasenavn&gt;</strong>, slik:</p>
<pre class="western">
<strong><span style="font-weight: normal">0: jdbc:hive2://localhost:10000&gt; use varehus;<br/>
</span></strong>
<strong><span style="font-weight: normal">No rows affected (0,03 seconds)</span></strong></pre><p class="western">
Vi kan se strukturen til en tabell med kommandoen <strong>desc
&lt;tabellnavn&gt;</strong>, slik</p>
<pre class="western">
<strong><span style="font-weight: normal">0: jdbc:hive2://localhost:10000&gt; desc kontakter;</span></strong>

<strong><span style="font-weight: normal">+-----------+------------+----------+--+</span></strong>
<strong><span style="font-weight: normal">| col_name&nbsp; | data_type&nbsp; | comment&nbsp; |</span></strong>
<strong><span style="font-weight: normal">+-----------+------------+----------+--+</span></strong>
<strong><span style="font-weight: normal">| navn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | string&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| tel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | string&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| alder&nbsp;&nbsp;&nbsp;&nbsp; | int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">| epost&nbsp;&nbsp;&nbsp;&nbsp; | string&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></strong>
<strong><span style="font-weight: normal">+-----------+------------+----------+--+</span></strong>
<strong><span style="font-weight: normal">4 rows selected (0,074 seconds)</span></strong></pre><p class="merk">
<strong>MERK:</strong> Vi kan sette utf&oslash;relsen av sp&oslash;rringene
til &aring; bruke MapReduce eller Tez p&aring; samme m&aring;te som
ved Hive CLI (se ovenfor)</p>
<p class="western">Vi skal bruke beeline til mer avanserte
HiveQL-sp&oslash;rringer i andre deler av kurset. For n&aring; kan vi
stenge klienten med kommandoen:</p>
<pre class="western">
<strong><span style="font-weight: normal">0: jdbc:hive2://localhost:10000&gt; !quit</span></strong>
<strong><span style="font-weight: normal"><br/>
Closing: 0: jdbc:hive2://localhost:10000</span></strong></pre><p class="western">
<br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc13983_140935937"></a>
<font size="6" style="font-size: 24pt">Kapittel 1</font><font size="6" style="font-size: 24pt">8</font><font size="6" style="font-size: 24pt"><br/>
</font>Apache
Phoenix -<br/>
SQL for HBase</h1>
<h2 class="western"><a name="__RefHeading___Toc8278_1995625076"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Hva er Phoenix?</h2>
<p class="western">Apache Phoenix er en SQL-overbygning p&aring; den
distribuerte databasen <b>HBase. </b><span style="font-weight: normal">H&rsquo;en
i HBase st&aring;r for </span><b>Hadoop</b><span style="font-weight: normal">,
og HBase er en kolonnebasert, distribuert database som er tett
integrert med &oslash;kosystemet </span><span style="font-weight: normal">til
</span><span style="font-weight: normal">Hadoop, </span><span style="font-weight: normal">som
bl.a. omfatter Apache Spark (se neste kapittel).</span><span style="font-weight: normal">
HBase brukes bl.a. av Facebook til &aring; lagre &laquo;likes&raquo;
og til </span><span style="font-weight: normal">Facebooks
meldings-</span><span style="font-weight: normal">system. </span><span style="font-weight: normal">HBase
kan h&aring;ndtere millioner av rader og milliarder </span><span style="font-weight: normal">av
</span><span style="font-weight: normal">kolonner i en tabell.</span></p>
<p class="western"><span style="font-weight: normal">Phoenix ble
opprinnelig utviklet hos selskapet Salesforce, og s&aring; donert til
Apache Software Foundation, hvor prosjektet n&aring; videreutvikles.
</span><span style="font-weight: normal">Ved &aring; tilby st&oslash;tte
for SQL &oslash;ker </span><span style="font-weight: normal">Phoenix
</span><span style="font-weight: normal">anvendbarheten til HBase
betraktelig.</span></p>
<h2 class="western"><a name="__RefHeading___Toc13189_1590063026"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Noen eksempler</h2>
<p class="western">Eksemplene i dette kapittelet er laget med
terminalklienten til Phoenix 4.7, installert som en del av
Hortonworks Data Platform (HDP &ndash; versjon 2.5.3) med
installasjons- og konfigureringsverkt&oslash;yet Apache Ambari. Med
HDP eller en annen Hadoop-distribusjon (f.eks. Cloudera eller MapR)
f&aring;r man ogs&aring; med HBase, Hive, Spark og en rekke andre
teknologier for behandling og analyse av store datamengder spredt
over klynger av servere (eller sm&aring; data p&aring; en laptop, om
man vil).  Terminalklienten startes med denne kommandoen:</p>
<pre class="western">
phoenix-sqlline
</pre><p class="western">
Etter litt forklarende ouput til skjermen, er klienten (som vi ser er
bygget med programmet sqlline) klar til bruk:</p>
<pre class="western">
0: jdbc:phoenix:&gt; <br/>
</pre><p class="western">
La oss f&oslash;rst opprette en tabell i Phoenix, for eksempel over
brukere, og siden det er st&oslash;tte for komplekse datatyper her,
kan vi lage en kolonne med datatypen <b>varchar array</b>
(tekstbasert liste) hvor vi f.eks. kan legge inn flere epostadresser
per bruker. Slik kan SQL-setningen for &aring; opprette en slik enkel
tabell se ut (oppretter tabellen brukere i databasen terje):</p>
<pre class="western" style="font-weight: normal">
0: jdbc:phoenix:&gt; create table terje.brukere (
id integer primary key,
fornavn varchar,
etternavn varchar, 
epost varchar array);
</pre><p class="western">
<br/>
Vi kan se en beskrivelse av tabellen Phoenix har opprettet for
oss med denne kommandoen :</p>
<pre class="western" style="font-weight: normal">
0: jdbc:phoenix:&gt; !describe terje.brukere

<font size="1" style="font-size: 7pt">+------------+--------------+-------------+--------------+------------+----------------+</font>
<font size="1" style="font-size: 7pt">| TABLE_CAT  | TABLE_SCHEM  | TABLE_NAME  | COLUMN_NAME  | DATA_TYPE  |   TYPE_NAME    |</font>
<font size="1" style="font-size: 7pt">+------------+--------------+-------------+--------------+------------+----------------+</font>
<font size="1" style="font-size: 7pt">|            | TERJE        | BRUKERE     | ID           | 4          | INTEGER        |</font>
<font size="1" style="font-size: 7pt">|            | TERJE        | BRUKERE     | FORNAVN      | 12         | VARCHAR        | </font>
<font size="1" style="font-size: 7pt">|            | TERJE        | BRUKERE     | ETTERNAVN    | 12         | VARCHAR        |</font>
<font size="1" style="font-size: 7pt">|            | TERJE        | BRUKERE     | EPOST        | 2003       | VARCHAR ARRAY  |</font>
<font size="1" style="font-size: 7pt">+------------+--------------+-------------+--------------+------------+----------------+</font></pre><p class="western">
<br/>
Terminaklienten skriver ut resultatene i en tabell som default,
men den kan skrive til flere ulike formater. Det kan v&aelig;re en
fordel n&aring;r resultatene skal lagres til fil, eller hvis tabellen
er bredere enn skjermbildet (spesielt siden overskridende kolonner
blir kuttet fra tabellen). Vi kan enkelt f&aring; frem
visnings-valgene ved &aring; taste in <b>!outputormat</b> etterfulgt
av tabulatortasten to ganger:</p>
<pre class="western"><br/>
0: jdbc:phoenix:&gt; !outputformat 
csv     table      tsv       vertical    xmlattr   xmlelements <br/>
</pre><p class="western">
Vi ser at vi kan velge kommaseparert, tabell, tabulator-separert,
vertikal eller to ulike XML-fomater  - en med feltene satt inn som
attributter, og en med feltene som elementer. For skjermbruk er
<b>vertical </b><span style="font-weight: normal">et godt alternativ
til </span><b>table </b><span style="font-weight: normal">for brede
tabeller: </span>
</p>
<pre class="western"><br/>
0: jdbc:phoenix:&gt; !outputformat vertical<br/>
</pre><p class="western">
<br/>
<br/>

</p>
<p class="western">S&aring; kan vi legge inn data i tabellen. Legg
merke til at vi gj&oslash;r dette med n&oslash;kkelordene <b>UPSERT
INTO</b><span style="font-weight: normal">, som Phoenix bruker b&aring;de
til &aring; erstatte INSERT INTO og UPDATE, slik at vi har samme
syntaks for begge operasjonene. Vi skal straks se hvordan dette
fungerer i praksis:</span></p>
<pre class="western"><span style="font-weight: normal"><br/>
UPSERT INTO terje.brukere (id, fornavn, etternavn, epost) VALUES (1,'Donald','Duck',ARRAY[</span>'donald@disney.com'<span style="font-weight: normal">,'donald.duck@gmail.com']);</span>
 </pre><p class="western" style="font-weight: normal">
Og vi kan se innholdet i tabellen slik:</p>
<pre class="western"><br/>
SELECT * FROM terje.brukere;

<font size="1" style="font-size: 8pt">+-----+----------+------------+-------------------------------------------------+</font>
<font size="1" style="font-size: 8pt">| ID  | FORNAVN  | ETTERNAVN  |                      EPOST                      |</font>
<font size="1" style="font-size: 8pt">+-----+----------+------------+-------------------------------------------------+</font>
<font size="1" style="font-size: 8pt">| 1   | Donald   | Duck       | ['donald@disney.com', 'donald.duck@gmail.com']  |</font>
<font size="1" style="font-size: 7pt"><font size="1" style="font-size: 8pt">+-----+----------+------------+-------------------------------------------------+</font><br/>
</font></pre><p class="western">
<span style="font-weight: normal"><br/>
</span><span style="font-weight: normal">Eller
hvis vi har satt outputformat til vertical, slik:</span></p>
<pre class="western">
ID          1
FORNAVN     Donald
ETTERNAVN   Duck
EPOST       ['donald@disney.com', 'donald.duck@gmail.com']
</pre><p class="western" style="font-weight: normal">
<br/>
<br/>

</p>
<p class="merk"><b>MERK:</b> Dersom vi vil endre kun &eacute;n av
epostene i listen, m&aring; vi endre hele listen samtidig, med 
UPSERT INTO. Vi kan mao ikke bare endre &eacute;n del av en liste,
men m&aring; endre alle delene samtidig (i  gjeldende, det vil si
versjon 4.7 av Phoenix.)</p>
<p class="western" style="font-weight: normal">Hvis vi vil hente ut
en enkelt av epostene i listen, kan vi gj&oslash;re det ved &aring;
referere til dens plassering, som starter med 1 for den f&oslash;rste
p&aring; listen. Vi setter plasseringen i rette klammer rett etter
feltnavnet. I eksemplet under henter vi ut fornavn og etternavn sl&aring;tt
sammen til et felt: navn, og den andre eposten p&aring; listen:</p>
<pre class="western">
SELECT fornavn || ' ' || etternavn AS Navn, epost[2] AS Epost 
FROM terje.brukere;

<font size="2" style="font-size: 9pt">+--------------+------------------------+</font>
<font size="2" style="font-size: 9pt">|     NAVN     |         EPOST          |</font>
<font size="2" style="font-size: 9pt">+--------------+------------------------+</font>
<font size="2" style="font-size: 9pt">| Donald Duck  | donald.duck@gmail.com  |</font>
<font size="1" style="font-size: 8pt"><font size="2" style="font-size: 9pt">+--------------+------------------------+</font><br/>
</font></pre><p class="western" style="font-weight: normal">
Vi ser at Phoenix bruker samme syntaks for sammensl&aring;ing av felt
(concatenation) som Oracle og PostgreSQL. 
</p>
<p class="western" style="font-weight: normal">Vi kan legge til et
par nye felt med standard SQL-syntaks, f.eks. slik:</p>
<pre class="western"><br/>
ALTER TABLE terje.brukere ADD registrert timestamp, oppdatert timestamp;<br/>
</pre><p class="western" style="font-weight: normal">
S&aring; kan vi legge inn en ny rad:</p>
<pre class="western"><br/>
UPSERT INTO terje.brukere (id, fornavn, etternavn, epost, registrert) VALUES (2,'Dolly','Duck',ARRAY['daisy@disney.com','daisy.duck@gmail.com'],now());<br/>
</pre><p class="western" style="font-weight: normal">
og oppdatere epostene til Donald med en tredje, slik:</p>
<pre class="western"><br/>
UPSERT INTO terje.brukere (id, epost, oppdatert) VALUES (1, ARRAY['donald@disney.com','donald.duck@gmail.com','donald.d@yahoo.com'],
NOW());<br/>
</pre><p class="western" style="font-weight: normal">
Vi ser at Phoenix st&oslash;tter funksjonen NOW() for &aring; lagre
tidspunktet akkurat n&aring;. Phoenix har lignende dato-funksjoner
som MySQL/MariaDB og MS SQL Server:</p>
<pre class="western"><br/>
select now(), year(now()), month(now()), dayofmonth(now());<br/>

+---------------------------------+-------+----+-----+
| DATE '2017-03-31 00:22:39.975'  | 2017  | 3  | 31  |
+---------------------------------+-------+----+-----+
| 2017-03-31 00:22:39.975         | 2017  | 3  | 31  |
+---------------------------------+-------+----+-----+ <br/>
</pre><p class="western" style="font-weight: normal">
<br/>
S&aring; kan vi hente ut f.eks. navn og f&oslash;rste epost,
samt n&aring;r siste oppdateringer ble gjort, slik:</p>
<pre class="western"><br/>
SELECT fornavn || ' ' || etternavn AS Navn, epost[1] AS Epost, oppdatert  FROM terje.brukere;
<br/>
+--------------+--------------------+--------------------------+
|     NAVN     |       EPOST        |        OPPDATERT         |
+--------------+--------------------+--------------------------+
| Donald Duck  | donald@disney.com  | 2017-03-31 00:13:12.358  |
| Dolly Duck   | daisy@disney.com   |                          |
+--------------+--------------------+--------------------------+<br/>
</pre><p class="western" style="font-weight: normal">
<br/>
Phoenix har ogs&aring; st&oslash;tte for indekser. Det blir
automatisk opprettet en indeks p&aring; prim&aelig;rn&oslash;kkelen,
men vi kan ogs&aring; opprette sekund&aelig;r-indekser (dvs. indekser
p&aring; andre felt enn prim&aelig;rn&oslash;kkel):</p>
<pre class="western">create index etternavn_idx on terje.brukere (etternavn);</pre><p class="western" style="font-weight: normal">
Og du kan opprette indekser p&aring; en plassering i en liste, f.eks.
f&oslash;rste epost i epost-feltet:</p>
<pre class="western">create index epost_idx on terje.brukere (epost[1]);</pre><p class="western">
MERK: Phoenix har ulike 2 typer indekser &ndash; en global og en
lokal. For &aring; ruke en global indeks, som er det som lages med
kommandoene ovenfor, m&aring; vi sette in et &laquo;hint&raquo; i
SQL-setningen for &aring; gi Phoenix beskjed om at den skal bruke
indeksen. Slik gj&oslash;res det:</p>
<pre class="western">select <b>/*+ INDEX(hr.employees employees_last_name_idx) */</b> first_name, last_name from hr.employees where last_name like 'Sin%';</pre><p class="western">
Men vi kan ogs&aring; opprette en <b>lokal indeks</b>, ved &aring;
legge til n&oslash;kelordet <b>local</b><span style="font-weight: normal">,,
slik.</span></p>
<pre class="western">create <b>local</b> index local_last_name_idx on hr.employees (last_name);</pre><p class="western" style="font-weight: normal">
Og da vil Phoenix bruke denne uten hint, som vi kan se ved &aring;
bruke explain f&oslash;r select:</p>
<pre class="western">explain select first_name, last_name from hr.employees where last_name = 'Sigstam'; 
<br/>
<font size="1" style="font-size: 7pt">+---------------------------------------------------------------------------------------+ <br/>
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PLAN &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
+---------------------------------------------------------------------------------------+ <br/>
| CLIENT 1-CHUNK PARALLEL 1-WAY ROUND ROBIN RANGE SCAN OVER HR.EMPLOYEES [1,'Sigstam'] &nbsp;| <br/>
| &nbsp;&nbsp;&nbsp;&nbsp;SERVER FILTER BY FIRST KEY ONLY &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
+---------------------------------------------------------------------------------------+</font></pre><p class="western">
<br/>
<br/>

</p>
<h3 class="western"><a name="__RefHeading___Toc19959_1644708593"></a>Selv-&oslash;kende
felt ved bruk av sekvenser</h3>
<p class="western">Phoenix har st&oslash;tte for felt med selv&oslash;kende
verdier ved at man oppretter en <b>sekvens</b> og bruker den til &aring;
fylle inn verdien for feltet - i likhet med slik det gj&oslash;res
med bl.a. Oracle. En sekvens opprettes slik:</p>
<pre class="western">create sequence &lt;navn&gt; [evt startverdi, intervall for &oslash;kning, sluttverdi]</pre><p class="western">
Vi kan angi hvilken verdi sekvensen skal starte p&aring;, og siden vi
allerede har lagt inn 2 rader i bruker-tabellen ovenfor kan vi
opprette en sekvens som starter p&aring; 3 og bruke den til &aring;
fylle inn id-feltet, slik:</p>
<pre class="western">create sequence terje.brukere start with 3;</pre><p class="western">
Slik kan vi bruke sekvensen:</p>
<pre class="western">upsert into terje.brukere (id, fornavn, etternavn, registrert) 
values (<b>next value for terje.brukere</b>, 'Petter','Smart',now());</pre><p class="western">
Og som vi ser har den innsatte raden f&aring;tt id = 3:</p>
<pre class="western">select id, fornavn, etternavn, registrert from terje.brukere; <br/>

+-----+----------+------------+--------------------------+ <br/>
| ID &nbsp;| FORNAVN &nbsp;| ETTERNAVN &nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REGISTRERT &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <br/>
+-----+----------+------------+--------------------------+ <br/>
| 1 &nbsp;&nbsp;| Donald &nbsp;&nbsp;| Duck &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2017-11-06 14:32:33.644 &nbsp;| <br/>
| 2 &nbsp;&nbsp;| Dolly &nbsp;&nbsp;&nbsp;| Duck &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2017-03-31 00:10:00.848 &nbsp;| <br/>
| 3 &nbsp;&nbsp;| Petter &nbsp;&nbsp;| Smart &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2018-04-29 12:43:24.585 &nbsp;| <br/>
+-----+----------+------------+--------------------------+</pre><p class="western">
<br/>
<br/>

</p>
<p class="ressurs" align="center"><b>Eksterne ressurser</b></p>
<p class="ressurs"><span style="font-weight: normal">Apache Phoenix
offisielle nettsider: <a href="http://phoenix.apache.org/">http://phoenix.apache.org</a></span></p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<h1 class="western" style="page-break-before: always"><a name="__RefHeading___Toc13987_140935937"></a>
<font size="6" style="font-size: 24pt">Kapittel 1</font><font size="6" style="font-size: 24pt">9</font><font size="6" style="font-size: 24pt"><br/>
</font>Spark
SQL 
</h1>
<h2 class="western"><a name="__RefHeading___Toc8282_1995625076"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Hva er Spark?</h2>
<p class="western"><span style="font-style: normal">Fra prosjektets
hjemmeside: </span><i><b>Apache Spark&trade;</b> is a fast and
general engine for large-scale data processing. </i>
</p>
<p class="western">Apache Spark ble opprinnelig skrevet som et
studentprosjekt ved UC Berkeley av Matei Zaharia. Utviklere fra mer
enn 200 selskaper involvert i videreutviklingen av Spark, og siden
lanseringen i 2009 har mer enn 1000 utviklere bidratt til &aring;
gj&oslash;re Spark en suksess. Kort fortalt er Spark en teknologi som
lar deg behandle store mengder data med Java, Scala, Python, R eller
SQL. 
</p>
<p class="western"><img src="Introduksjon_til_SQL_html_9205f25719a51f81.png" name="Bilde6" align="right" width="273" height="129" border="0"/>
Spark
har 4 hovedkomponenter: Spark Streaming, Spark MLlib. Spark GraphX og
Spark SQL &ndash; som h&aring;ndterer henholdsvis data i bevegelse,
maskinl&aelig;ring, analyser av grafiske data og SQL mot st&oslash;ttede
databaser og filer.</p>
<p class="western">Se <b>Vedlegg XXX </b>for veiledning til
installasjon av Spark</p>
<h2 class="western"><a name="__RefHeading___Toc15659_820443553"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Hva er Spark SQL?</h2>
<p class="western">Spark SQL er Spark-komponenten som lar deg bruke
SQL mot alle datakilder som er tilgjengelige for Spark, gjerne lagret
p&aring; klynger av servere, f.eks. i et distribuert filsystem som
<b>Hadoop</b><b> </b><b>Distributed File System</b> (HDFS) og i et
format som f.eks. <b>Parquet</b>, <b>Avro</b>, <b>Hive, </b><b>Cassandra,
HBase, S3</b><b> </b>eller rett og slett en kommaseparert tekstfil.</p>
<h2 class="western"><a name="__RefHeading___Toc8284_1995625076"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Sparks terminalklienter</h2>
<p class="western">Spark inneholder flere terminalklienter som gj&oslash;r
det enkelt &aring; skrive SQL direkte mot f.eks. Hive-tabeller eller
andre datakilder. Terminalklienten for Spark SQL gir oss en terminal
der vi kan begynne &aring; skrive SQL direkte. Men du kan ogs&aring;
skrive SQL med terminalklienten for Scala, Python og R (se eksempler
nedenfor). 
</p>
<p class="western">Terminalklienten til Spark SQL startes med
kommandoen <b>spark-sql</b>, som gir oss en prompt tilbake:</p>
<pre class="western" style="font-weight: normal"><font face="monospace">$ spark-sql</font>

<font face="monospace">s</font><font face="monospace">park-sql&gt; </font> 
</pre><p class="western">
Vi kan se hvilke Hive-databaser som er tilgjengelig med denne
kommandoen, som for&oslash;vrig er den samme som for terminalklienten
til MySQL/MariaDB:</p>
<pre class="western" style="font-weight: normal">spark-sql&gt; show databases;

default
hr
hrpq
....
</pre><p class="western">
<br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western">S&aring; kan vi g&aring; inn i databasen hr, og se
hvilke tabeller den inneholder, slik:</p>
<pre class="western">
spark-sql&gt; use hr;
spark-sql&gt; show tables;

<font color="#000000"><font face="monospace"><span style="background: transparent">departments	false </span></font></font><font face="monospace"><br/>
dept_emp		false <br/>
dept_manager	false <br/>
employees		false <br/>
salaries		false <br/>
titles		false <br/>
Time taken: 0.396 seconds, Fetched 6 row(s) <br/>
17/01/28 16:52:05 INFO CliDriver: Time taken: 0.396 seconds, Fetched 6 row(s)</font>
</pre><p class="western">
 Og vi kan bruke standard SQL-setninger for &aring; s&oslash;ke i
tabellene:</p>
<pre class="western">spark-sql&gt; SELECT * from salaries limit 3;

<font color="#000000"><span style="background: transparent">10001 &nbsp;&nbsp;60117 &nbsp;&nbsp;1986-06-26 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1987-06-26 </span></font><br/>
10001 &nbsp;&nbsp;62102 &nbsp;&nbsp;1987-06-26 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1988-06-25 <br/>
10001 &nbsp;&nbsp;66074 &nbsp;&nbsp;1988-06-25 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1989-06-25 
<br/>
Time taken: 0.297 seconds, Fetched 3 row(s) <br/>
17/01/28 16:57:38 INFO CliDriver: Time taken: 0.297 seconds, Fetched 3 row(s)<br/>
</pre><p class="western">
<br/>
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc8286_1995625076"></a><strong><font color="#1b75bc">&#61609;</font></strong>
SQL direkte mot en fil</h2>
<p class="western">Vi kan ogs&aring; kj&oslash;re SQL-setninger
direkte mot en fil, som f.eks. en Parquet-fil eller komma-separert
fil:</p>
<p class="western">Eksempel p&aring; SQL direkte mot en Parquet-fil
lagret i HDFS:</p>
<pre class="western"><span style="background: transparent"><font color="#000000">spark-sql&gt; </font><font color="#000000">select * from parquet.`hitsPerDay.p</font><font color="#000000">ar</font><font color="#000000">q</font><font color="#000000">uet</font><font color="#000000">` limit 3;</font></span>

2016-11-20 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2529 <br/>
2016-11-21 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1234 <br/>
2016-11-22 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7472 <br/>

Time taken: 3.075 seconds, Fetched 3 row(s) <br/>
17/01/28 17:03:29 INFO CliDriver: Time taken: 3.075 seconds, Fetched 3 row(s)
<br/>
</pre><p class="western">
<br/>
<br/>

</p>
<p class="western">Eksempel p&aring; SQL direkte mot en kommaseparert
fil hvor skilletegnet er | - lagret i HDFS:</p>
<pre class="western"><span style="font-weight: normal">spark-sql&gt; </span><font color="#000000"><font face="monospace"><span style="font-weight: normal"><span style="background: transparent">select * from csv.`avd.csv` </span></span></font></font><font color="#000000"><font face="monospace"><span style="font-weight: normal"><span style="background: transparent">limit </span></span></font></font><font color="#000000"><font face="monospace"><span style="font-weight: normal"><span style="background: transparent">3</span></span></font></font><font color="#000000"><font face="monospace"><span style="font-weight: normal"><span style="background: transparent">;</span></span></font></font><font face="monospace"><br/>
</font>
<font color="#000000"><font face="monospace"><span style="background: transparent">avdeling|ansatte|leder|kj&oslash;nn|alder </span></font></font><font face="monospace"><br/>
Development|61386|Leon DasSarma|F|52 years 5 mons 2 days <br/>
Production|53304|Oscar Ghazalie|M|53 years 2 mons <br/>
Sales|37701|Hauke Zhang|M|61 years 6 mons 11 days <br/>
(</font><font face="monospace">3</font><font face="monospace"> rows) <br/>
</font>
<font face="monospace">Time taken: 0.445 seconds, Fetched </font><font face="monospace">5</font><font face="monospace"> row(s) <br/>
17/01/28 17:09:54 INFO CliDriver: Time taken: 0.445 seconds, Fetched </font><font face="monospace">5</font><font face="monospace"> row(s)<br/>
</font></pre><p class="western">
<br/>
<br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc8288_1995625076"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Spark SQL via Scala, Python, Java og R</h2>
<p class="western">Vi kan ogs&aring; kj&oslash;re SQL-setninger fra
Spark-programmer skrevet i Scala, Python, Java eller R.</p>
<p class="western">Eksempel p&aring; SQL mot Parquet-fil med <b>Scala</b>:</p>
<p class="western">Start f.eks. Scala-terminalklienten med
kommandoen: <b>spark-shell</b></p>
<pre class="western"><font color="#000000"><span style="background: transparent">Welcome to </span></font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;____ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;/ __/__ &nbsp;___ _____/ /__ <br/>
&nbsp;&nbsp;&nbsp;_\ \/ _ \/ _ `/ __/ &nbsp;'_/ <br/>
&nbsp;&nbsp;/___/ .__/\_,_/_/ /_/\_\ &nbsp;&nbsp;version 2.0.0.2.5.0.0-1245 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/_/ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
Using Scala version 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_60) <br/>
Type in expressions to have them evaluated. <br/>
Type :help for more information. <br/>
<br/>
scala&gt; val sqlDF = spark.sql(&quot;SELECT * FROM parquet.`hitsPerDay.parquet`&quot;)
<br/>
sqlDF: org.apache.spark.sql.DataFrame = [day: string, count: bigint] <br/>
<br/>
scala&gt; sqlDF.printSchema() <br/>
root <br/>
|-- day: string (nullable = true) <br/>
|-- count: long (nullable = true) 

<font color="#000000"><font face="monospace"><span style="font-weight: normal"><span style="background: transparent">scala&gt; sqlDF.show(5) </span></span></font></font><font face="monospace"><span style="font-weight: normal"><br/>
</span></font><font face="monospace">+----------+-----+ <br/>
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;day|count| <br/>
+----------+-----+ <br/>
|2015-11-20| 2529| <br/>
|2015-11-21| 1234| <br/>
|2015-11-22| 7472| <br/>
|2015-11-23| 2642| <br/>
|2015-11-24| 6854| <br/>
+----------+-----+ <br/>
only showing top 5 rows</font></pre><p class="western">
Eksempel p&aring; SQL mot Parquet-fil med <b>Python</b>:</p>
<p class="western">Start f.eks. Python-terminalklienten med
kommandoen: <b>pyspark</b></p>
<pre class="western"><font color="#000000"><font face="monospace"><span style="background: transparent">Welcome to </span></font></font><font face="monospace"><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;____ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;/ __/__ &nbsp;___ _____/ /__ <br/>
&nbsp;&nbsp;&nbsp;_\ \/ _ \/ _ `/ __/ &nbsp;'_/ <br/>
&nbsp;&nbsp;/__ / .__/\_,_/_/ /_/\_\ &nbsp;&nbsp;version 2.0.0.2.5.0.0-1245 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/_/ <br/>
<br/>
Using Python version 2.7.5 (default, Nov &nbsp;6 2016 00:28:07) <br/>
SparkSession available as 'spark'. <br/>
</font>
<font face="monospace">&gt;&gt;&gt; </font>df = spark.sql(&quot;SELECT * FROM parquet.`hitsPerDay.parquet`&quot;)
<font color="#000000"><span style="background: transparent">&gt;&gt;&gt; df.printSchema()   // </span></font><font color="#000000"><span style="background: transparent">print tabellstrukturen til skjerm</span></font><br/>
root <br/>
|-- day: string (nullable = true) <br/>
|-- count: long (nullable = true) <br/>
<br/>
&gt;&gt;&gt; df.show(5)   	     // Vis de 5 f&oslash;rste radene av tabellen<br/>
+----------+-----+ <br/>
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;day|count| <br/>
+----------+-----+ <br/>
|2015-11-20| 2529| <br/>
|2015-11-21| 1234| <br/>
|2015-11-22| 7472| <br/>
|2015-11-23| 2642| <br/>
|2015-11-24| 6854| <br/>
+----------+-----+ <br/>
only showing top 5 rows<br/>
</pre><p class="western">
<br/>
Eksempel p&aring; SQL mot Parquet-fil med <b>Java</b>:</p>
<pre class="western">Dataset&lt;Row&gt; sqlDF =
spark.sql(&quot;SELECT * FROM parquet.`hitsPerDay.parquet`&quot;);</pre><p class="western">
<br/>
Eksempel p&aring; SQL mot Parquet-fil med <b>R</b>:</p>
<p class="western">Start feks. R-terminalklienten med kommandoen:
<b>sparkR</b></p>
<pre class="western"><font color="#000000"><span style="background: transparent">Welcome to </span></font><br/>
&nbsp;&nbsp;&nbsp;____ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__ &nbsp;<br/>
&nbsp;&nbsp;/ __/__ &nbsp;___ _____/ /__ &nbsp;<br/>
&nbsp;_\ \/ _ \/ _ `/ __/ &nbsp;'_/ &nbsp;<br/>
/___/ .__/\_,_/_/ /_/\_\ &nbsp;&nbsp;version &nbsp;2.0.0.2.5.0.0-1245 &nbsp;<br/>
&nbsp;&nbsp;&nbsp;/_/ &nbsp;<br/>
<br/>
<br/>
Spark context is available as sc, SQL context is available as sqlContext <br/>
During startup - Warning messages: <br/>
1: 'SparkR::sparkR.init' is deprecated. <br/>
Use 'sparkR.session' instead. <br/>
See help(&quot;Deprecated&quot;) &nbsp;<br/>
2: 'SparkR::sparkRSQL.init' is deprecated. <br/>
Use 'sparkR.session' instead. <br/>
See help(&quot;Deprecated&quot;) &nbsp;<br/>

<font face="monospace">&gt; </font>df &lt;- sql(&quot;SELECT * FROM parquet.`hitsPerDay.parquet`&quot;)

<font color="#000000"><span style="background: transparent">&gt; names(df)           	// </span></font><font color="#000000"><span style="background: transparent">print kolonnenavnene til skjerm</span></font><br/>
[1] &quot;day&quot; &nbsp;&nbsp;&quot;count&quot;<br/>

<font color="#000000"><span style="background: transparent">&gt; head(df,5) &nbsp;		</span></font><font color="#000000"><font size="1" style="font-size: 8pt"><span style="background: transparent">// </span></font></font><font color="#000000"><font size="1" style="font-size: 8pt"><span style="background: transparent">print de 5 f&oslash;rste radene i tabellen (datarammen)</span></font></font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;day 	   count <br/>
1 2015-11-20 &nbsp;2529 <br/>
2 2015-11-21 &nbsp;1234 <br/>
3 2015-11-22 &nbsp;7472 <br/>
4 2015-11-23 &nbsp;2642 <br/>
5 2015-11-24 &nbsp;6854
</pre><p class="western">
<br/>
<br/>

</p>
<p class="ressurs" align="center"><b>Eksterne Ressurser</b></p>
<p class="ressurs"><span style="font-weight: normal">- Spark SQL
dokumentasjon:
</span><a href="http://spark.apache.org/docs/latest/sql-programming-guide.html"><span style="font-weight: normal">http://spark.apache.org/docs/latest/sql-programming-guide.html</span></a><b><br/>
-
</b>Spark SQL offisielle nettsider: <a href="http://spark.apache.org/sql">http://spark.apache.org/</a><a href="http://spark.apache.org/sql">sql</a><br/>
-
Hadoop offisielle nettsider: <a href="http://hadoop.apache.org/">http://hadoop.apache.org</a><br/>
-
Parquet offisielle nettsider: <a href="http://parquet.apache.org/">http://parquet.apache.org</a></p>
<h1 class="western" align="center" style="page-break-before: always"><a name="__RefHeading___Toc9929_2115805896"></a>
Vedlegg 1<br/>
<font size="4" style="font-size: 14pt">Installasjon og
konfigurering av  MySQL, MariaDB, PostgreSQL, Oracle Express og MS
SQL Server</font></h1>
<h2 class="western"><a name="__RefHeading___Toc19553_1580825334"></a><strong><font color="#1b75bc">&#61609;</font></strong><strong>
</strong><strong> </strong><strong><span style="font-weight: normal">MySQL</span></strong></h2>
<p class="western"><strong>MySQL</strong> kan lastes ned og
installeres fra denne lenken: <a href="http://dev.mysql.com/downloads/mysql/" target="_blank">http://dev.mysql.com/downloads/mysql/</a></p>
<p class="western">Velg ditt operativsystem og 32 eller 64s versjon,
last ned og kj&oslash;r installasjonsprogrammet. Velg
default-innstillingene. 
</p>
<p class="western"><strong>MySQL Workbench</strong> kan lastes ned og
installeres fra denne lenken:
<a href="http://dev.mysql.com/downloads/workbench/" target="_blank">http://dev.mysql.com/downloads/workbench/</a></p>
<h3 class="western"><a name="__RefHeading___Toc5706_920682125"></a>Linux</h3>
<h4 class="western"><a name="__RefHeading___Toc19081_2730267216"></a>Ubuntu
/ Debian / Linux Mint</h4>
<p class="western">&Aring;pne et terminalvindu og tast inn: <strong>sudo
apt install mysql-server mysql-workbench</strong></p>
<h4 class="western"><a name="__RefHeading___Toc19083_2730267216"></a>Fedora
/ Red Hat / Centos: 
</h4>
<ol>
	<li><p class="western" style="margin-bottom: 0cm">Siden MariaDB er
	standard for disse operativsystemene, m&aring; du legge inn
	Repo-data fra mysql f&oslash;r du installer MySQL. Informasjon
	ligger her:
	<a href="https://dev.mysql.com/doc/mysql-repo-excerpt/5.6/en/linux-installation-yum-repo.html" target="_blank">https://dev.mysql.com/doc/mysql-repo-excerpt/5.6/en/linux-installation-yum-repo.html</a></p>
	<li><p class="western">&Aring;pne et terminalvindu og tast inn: <strong>sudo
	yum install mysql-server mysql-workbench </strong>eller: <strong>sudo
	dnf install mysql-server mysql-workbench </strong>(for nyere
	versjoner)</p>
</ol>
<h4 class="western"><a name="__RefHeading___Toc19085_2730267216"></a>SuSE
/ OpenSuse 
</h4>
<p class="western">&Aring;pne et terminalvindu og tast inn: <strong>sudo
zypper install mysql-server mysql-workbench</strong></p>
<p class="merk"><strong>MERK: </strong>Installasjon av MySQL-server
vil fjerne evt. eksisterende installasjoner av MariaDB-server p&aring;
en Fedora/Red Hat/Centos-maskin.</p>
<h2 class="western" style="font-weight: normal"><a name="__RefHeading___Toc5708_920682125"></a>
<strong><font color="#1b75bc">&#61609;</font></strong> Installasjon
av MariaDB</h2>
<h3 class="western"><a name="__RefHeading___Toc5710_920682125"></a>Windows
/ Mac</h3>
<p class="western">MariaDB kan lastes ned fra denne lenken:
<a href="https://downloads.mariadb.org/" target="_blank">https://downloads.mariadb.org/</a></p>
<h3 class="western"><a name="__RefHeading___Toc5712_920682125"></a>Linux</h3>
<h4 class="western"><a name="__RefHeading___Toc19087_2730267216"></a>Ubuntu
/ Debian / Linux Mint</h4>
<p class="western">&Aring;pne et terminalvindu og tast inn: <strong>sudo
apt install mariadb-server</strong></p>
<h4 class="western"><a name="__RefHeading___Toc19089_2730267216"></a>Fedora
/ Red Hat / Centos 
</h4>
<p class="western">&Aring;pne et terminalvindu og tast inn: <strong>sudo
yum install mariadb-server&nbsp; </strong>eller: <strong>sudo dnf
install mariadb-server </strong>(for nyere versjoner)</p>
<h4 class="western"><a name="__RefHeading___Toc19091_2730267216"></a>SuSE
/ OpenSuse 
</h4>
<p class="western">&Aring;pne et terminalvindu og tast inn: <strong>sudo
zypper install mariadb-server </strong>
</p>
<p class="merk"><strong>MERK: </strong>Installasjon av MariaDB-server
vil fjerne evt. eksisterende installasjoner av MySQL-server p&aring;
en Ubuntu-maskin.</p>
<h2 class="western" style="font-weight: normal"><a name="__RefHeading___Toc6017_317907475"></a>
<strong><font color="#1b75bc">&#61609;</font></strong> Installasjon
av PostgreSQL og pgAdmin</h2>
<p class="western">Her er informasjon om hvordan du kan installere
<b>PostgreSQL</b> og administrasjons-verkt&oslash;yet <b>pgAdmin </b>p&aring;
egen maskin.</p>
<h3 class="western"><a name="__RefHeading___Toc6019_317907475"></a>Windows
/ Mac 
</h3>
<p class="western">PostgreSQL kan lastes ned og installeres fra denne
lenken:
<a href="http://www.enterprisedb.com/products-services-training/pgdownload#linux">http://www.enterprisedb.com/products-services-training/pgdownload</a></p>
<p class="western">Last ned og kj&oslash;r installasjonsprogrammet
for ditt operativsystem og velg default-instillingene. 
</p>
<p class="western"><b>pgAdmin </b>f&oslash;lger med som en del av
installasjonsprogrammet til PostgreSQL.</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"><br/>
<br/>

</p>
<p class="western"> 
</p>
<h2 class="western"><a name="__RefHeading___Toc16240_413252541"></a><strong><font color="#1b75bc">&#61609;</font></strong>
Installere PostgreSQL p&aring; en Linux-server (eller laptop e.l.)</h2>
<p class="western">Det er lett &aring; installere PostgreSQL  p&aring;
en Linux-maskin, siden de aller fleste Linux-distribusjoner har
ferdig kompilerte pakker for PostgreSQL.  Installasjon via systemets
pakkeh&aring;ndterer kan gj&oslash;re fra et terminalvindu, med en av
disse kommandoene:</p>
<h3 class="western"><a name="__RefHeading___Toc12583_268258650"></a>Red
Hat (RHEL) / Centos 
</h3>
<p class="western"><b>sudo yum install postgresql-server
postgresql-contrib postgresql-doc </b>
</p>
<h3 class="western"><a name="__RefHeading___Toc12585_268258650"></a>Fedora</h3>
<p class="western"><b>sudo dnf install postgresql-server
postgresql-contrib postgresql-doc </b>
</p>
<h3 class="western"><a name="__RefHeading___Toc12587_268258650"></a>Ubuntu
/ Debian</h3>
<p class="western"><b>sudo apt install postgresql-server
postgresql-contrib postgresql-doc </b>
</p>
<h3 class="western"><a name="__RefHeading___Toc12589_268258650"></a>OpenSuSE
/ SuSE Linux Enterprise Server (SLES)</h3>
<p class="western"><b>sudo zypper in postgresql-server
postgresql-contrib postgresql-doc </b>
</p>
<p class="western">Kommandoene over installerer den versjonen av
PostgreSQL som er testet og stabil for den serveren du bruker &ndash;
men som regel er ikke dette siste stabile versjon av PostgreSQL.
&Oslash;nsker du nyere versjon, kan du installere den ved &aring;
legge inn en egen programvare-br&oslash;nn fra PostgreSQL sine
nettsider, og installere &oslash;nsket versjon gjennom denne. Sjekk
<a href="http://www.postgresql.org/">www.postgresql.org</a> for
informasjon om hvordan dette gj&oslash;res.</p>
<h2 class="western" style="page-break-before: always"><a name="__RefHeading___Toc9931_2115805896"></a>
<strong><font color="#1b75bc">&#61609;</font></strong> Installere
Microsoft SQL-server p&aring; en Linux-server</h2>
<p class="western">Det er forbl&oslash;ffende enkelt &aring;
installere Microsoft SQL-server p&aring; en Linux-server (eller p&aring;
din Linux laptop hvis du vil teste den ut)</p>
<p class="western">Installasjonen nedenfor er gjort via et
terminalvindu &ndash; du kan evt. bruke putty e.l. hvis du er p&aring;
en Windows-maskin som vil kontakte en Linux-maskin.</p>
<p class="western">Det f&oslash;rste du gj&oslash;r er &aring;
installere SQL-serverens pakkebr&oslash;nn &ndash; en yum repo-fil
som du henter og installerer (dvs. kopierer til rett mappe) med denne
kommandoen (som rot-bruker eller med sudo): 
</p>
<pre class="western"><b>curl https://packages.microsoft.com/config/rhel/7/mssql-server.repo &gt; /etc/yum.repos.d/mssql-server.repo</b>
 
 % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   220  100   220    0     0    919      0 --:--:-- --:--:-- --:--:-- 916
</pre><p class="western">
Med denne p&aring; plass kan vi installere SQL-serveren med denne
enkle kommandoen:</p>
<pre class="western"><b>yum install mssql-server</b>

Tillegg som er i bruk:fastestmirror
packages-microsoft-com-mssql-server                                                                            | 2.9 kB  00:00:00     
packages-microsoft-com-mssql-server/primary_db                                                                 | 3.9 kB  00:00:00     
Loading mirror speeds from cached hostfile
 * base: mirrors.cicku.me
 * epel: mirrors.n-ix.net
 * extras: mirrors.cicku.me
 * updates: mirrors.cicku.me
L&oslash;ser avhengigheter
--&gt; Utf&oslash;rer sjekk av transaksjonen
---&gt; Package mssql-server.x86_64 0:14.0.200.24-2 will be installert
--&gt; Beregner avhengighet: bzip2 for pakke: mssql-server-14.0.200.24-2.x86_64
--&gt; Beregner avhengighet: gdb for pakke: mssql-server-14.0.200.24-2.x86_64
--&gt; Utf&oslash;rer sjekk av transaksjonen
---&gt; Package bzip2.x86_64 0:1.0.6-13.el7 will be installert
---&gt; Package gdb.x86_64 0:7.6.1-94.el7 will be installert
--&gt; Alle avhengigheter er l&oslash;st

Alle avhengigheter er l&oslash;st

======================================================================================================================================
 Package                    Arkitektur           Versjon                      Pakkeoversikt                                     St&oslash;rrelse
======================================================================================================================================
Installerer:
 mssql-server               x86_64               14.0.200.24-2                packages-microsoft-com-mssql-server               142 M
Legges inn p&aring; grunn avhengigheter:
 bzip2                      x86_64               1.0.6-13.el7                 base                                               52 k
 gdb                        x86_64               7.6.1-94.el7                 base                                              2.4 M

Transaksjonsammendrag
======================================================================================================================================
Install  1 Package (+2 Dependent packages)

Totale st&oslash;rrelse p&aring; pakker som hentes: 145 M
Installed size: 149 M

<b>Is this ok [y/d/N]: y</b>

Downloading packages:
(1/3): bzip2-1.0.6-13.el7.x86_64.rpm                                                                           |  52 kB  00:00:00     
(2/3): gdb-7.6.1-94.el7.x86_64.rpm                                                                             | 2.4 MB  00:00:00     
warning: /var/cache/yum/x86_64/7/packages-microsoft-com-mssql-server/packages/mssql-server-14.0.200.24-2.x86_64.rpm: Header V4 RSA/SHA256 Signature, key ID be1229cf: NOKEY
Offentlig n&oslash;kkel for mssql-server-14.0.200.24-2.x86_64.rpm er ikke lagt inn
(3/3): mssql-server-14.0.200.24-2.x86_64.rpm                                                                   | 142 MB  00:00:05     
--------------------------------------------------------------------------------------------------------------------------------------
Totalt 26 MB/s | 145 MB  00:00:05     

Retrieving key from https://packages.microsoft.com/keys/microsoft.asc
Importing GPG key 0xBE1229CF:
 Userid     : &quot;Microsoft (Release signing) &lt;gpgsecurity@microsoft.com&gt;&quot;
 Fingerprint: bc52 8686 b50d 79e3 39d3 721c eb3e 94ad be12 29cf
 From       : https://packages.microsoft.com/keys/microsoft.asc

<b>Er dette ok [j/N]:j</b>

Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Installerer   : bzip2-1.0.6-13.el7.x86_64                                                                                       1/3 
  Installerer   : gdb-7.6.1-94.el7.x86_64                                                                                         2/3 
  Installerer   : mssql-server-14.0.200.24-2.x86_64                                                                               3/3 

+-------------------------------------------------------------------+
| Please run /opt/mssql/bin/sqlservr-setup to complete the setup of |
|                  Microsoft(R) SQL Server(R).                      |
+-------------------------------------------------------------------+

  Verifying     : gdb-7.6.1-94.el7.x86_64                                                                                         1/3 
  Verifying     : mssql-server-14.0.200.24-2.x86_64                                                                               2/3 
  Verifying     : bzip2-1.0.6-13.el7.x86_64                                                                                       3/3 

Installert:
  mssql-server.x86_64 0:14.0.200.24-2                                                                                                 

Lagt inn p&aring; grunn av avhengighet:
  bzip2.x86_64 0:1.0.6-13.el7                                        gdb.x86_64 0:7.6.1-94.el7                                       

Ferdig!
</pre><p class="western">
<br/>
<br/>

</p>
<p class="western">Da er den installert, og neste trinn er &aring;
sette den opp, som gj&oslash;res med denne kommandoen:</p>
<pre class="western"><b>/opt/mssql/bin/sqlservr-setup</b>

Microsoft(R) SQL Server(R) Setup

You can abort setup at anytime by pressing Ctrl-C. Start this program
with the --help option for information about running it in unattended
mode.

The license terms for this product can be downloaded from
http://go.microsoft.com/fwlink/?LinkId=746388 and found
in /usr/share/doc/mssql-server/LICENSE.TXT.

<b>Do you accept the license terms? If so, please type &quot;YES&quot;: YES</b>

<b>Please enter a password for the system administrator (SA) account: </b>
<b>Please confirm the password for the system administrator (SA) account:</b> 

Setting system administrator (SA) account password...

<b>Do you wish to start the SQL Server service now? [y/n]: y</b>
<b>Do you wish to enable SQL Server to start on boot? [y/n]: y</b>

Created symlink from /etc/systemd/system/multi-user.target.wants/mssql-server.service to /usr/lib/systemd/system/mssql-server.service.
Created symlink from /etc/systemd/system/multi-user.target.wants/mssql-server-telemetry.service to /usr/lib/systemd/system/mssql-server-telemetry.service.

Setup completed successfully.
</pre><p class="western">
S&aring; kan vi sjekke at den er oppe og g&aring;r med denne
kommandoen:</p>
<pre class="western">
<b>systemctl status mssql-server</b>

&#9679; mssql-server.service - Microsoft(R) SQL Server(R) Database Engine
   Loaded: loaded (/usr/lib/systemd/system/mssql-server.service; enabled; vendor preset: disabled)
   Active: active (running) since to. 2017-02-02 11:44:52 CET; 5min ago
 Main PID: 19573 (sqlservr)
   CGroup: /system.slice/mssql-server.service
           &#9500;&#9472;19573 /opt/mssql/bin/sqlservr
           &#9492;&#9472;19582 /opt/mssql/bin/sqlservr
    ....</pre><p class="western">
Vi kan starte, stoppe og restarte den ved &aring; bytte ut status i
kommandoen over med henholdsvis start, stop eller restart, f.eks.
slik:</p>
<pre class="western">
<b>systemctl stop mssql-server</b>

<b>systemctl start mssql-server</b>

<b>systemctl restart mssql-server</b>
</pre><p class="western">
<br/>
<br/>

</p>
<p class="western">S&aring; kan vi installere komandolinje-tools hvis
vi vil bruke terminal-klienten til SQL-serveren:</p>
<p class="western">F&oslash;rst installerer vi repo-filen for tools,
med denne kommandoen:</p>
<pre class="western">
<code class="western"><b>curl https://packages.microsoft.com/config/rhel/7/prod.repo &gt; /etc/yum.repos.d/msprod.repo</b></code>
</pre><p class="western">
<br/>
<br/>

</p>
<p class="western">S&aring; er det denne kommandoen som installerer
tools</p>
<pre class="western"><b>yum install mssql-tools</b>

Tillegg som er i bruk:fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.cicku.me
 * epel: mirrors.n-ix.net
 * extras: mirrors.cicku.me
 * updates: mirrors.cicku.me
L&oslash;ser avhengigheter
--&gt; Utf&oslash;rer sjekk av transaksjonen
---&gt; Package mssql-tools.x86_64 0:14.0.2.0-1 will be installert
--&gt; Utf&oslash;rer sjekk av transaksjonen
---&gt; Package libtool-ltdl.x86_64 0:2.4.2-21.el7_2 will be installert
--&gt; Alle avhengigheter er l&oslash;st

Alle avhengigheter er l&oslash;st

======================================================================================================================================
 Package                       Arkitektur            Versjon                         Pakkeoversikt                              St&oslash;rrelse
======================================================================================================================================
Installerer:
 mssql-tools                   x86_64                14.0.2.0-1                       libtool-ltdl                  x86_64                2.4.2-21.el7_2                  base                                        49 k

Transaksjonsammendrag
======================================================================================================================================
Install  2 Packages (+3 Dependent packages)

Totale st&oslash;rrelse p&aring; pakker som hentes: 4.6 M
Installed size: 5.5 M
Is this ok [y/d/N]: y
Downloading packages:
(1/5): libtool-ltdl-2.4.2-21.el7_2.x86_64.rpm                                                                  |  49 kB  00:00:00     
(4/5): mssql-tools-14.0.2.0-1.x86_64.rpm                                                                       | 248 kB  00:00:00     
----------------------------------------------------------
Totalt                                                                                                8.6 MB/s | 4.6 MB  00:00:00     
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Installerer   : libtool-ltdl-2.4.2-21.el7_2.x86_64                                                                              1/5 
The license terms for this product can be downloaded from
http://go.microsoft.com/fwlink/?LinkId=746949 and found in
/usr/share/doc/mssql-tools/LICENSE.txt . By entering 'YES',
you indicate that you accept the license terms.

Do you accept the license terms? (Enter YES or NO)
YES
  Installerer   : mssql-tools-14.0.2.0-1.x86_64                                                                                   4/5 

  Verifying     : libtool-ltdl-2.4.2-21.el7_2.x86_64 1/5 
Verifying     : mssql-tools-14.0.2.0-1.x86_64                                                                                   5/5 

Installert:
  mssql-tools.x86_64 0:14.0.2.0-1                                 

Lagt inn p&aring; grunn av avhengighet:
  libtool-ltdl.x86_64 0:2.4.2-21.el7_2                     

Ferdig!
</pre><p class="western">
Et par symlinker er kjekt &aring; legge inn samtidig, slik at det
blir enklere &aring; logge seg p&aring; databasen:</p>
<pre class="western">
ln -sfn /opt/mssql-tools/bin/sqlcmd-13.0.1.0 /usr/bin/sqlcmd 
ln -sfn /opt/mssql-tools/bin/bcp-13.0.1.0 /usr/bin/bcp
</pre><p class="western">
<br/>
<br/>

</p>
<p class="western">S&aring; kan vi logge oss p&aring; serveren og
starte &aring; jobbe med den:</p>
<pre class="western">
[root@server4 ~]# sqlcmd -S localhost -U SA
Password: 

Sjekk hvilke databaser som finnes der fra f&oslash;r:

1&gt; SELECT Name from sys.Databases;
2&gt; GO
Name                                                                                                                            
--------------------------------------------------------------------------------------------------------------------------------
master                                                                                                                          
tempdb                                                                                                                          
model                                                                                                                           
msdb                                                                                                                            

(4 rows affected)
1&gt; 
Create database kurs;
2&gt; GO
1&gt; select  Name from sys.Databases;
2&gt; go
Name                                                                                                                            
--------------------------------------------------------------------------------------------------------------------------------
master                                                                                                                          
tempdb                                                                                                                          
model                                                                                                                           
msdb                                                                                                                            
kurs                                                                                                                            

(5 rows affected)
1&gt; use kurs;
2&gt; go
Changed database context to 'kurs'.
1&gt; </pre>
</body>
</html>